)]}'
{"version":3,"sources":["angular:angular-aria/angular-aria.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,G;AACA,6B;AACA,kD;AACA,e;AACA,G;AACA,oD;;AAEA,G;AACA,gB;AACA,e;AACA,e;AACA,E;AACA,kD;AACA,oG;AACA,uF;AACA,qD;AACA,E;AACA,6C;AACA,E;AACA,W;AACA,E;AACA,kG;AACA,iB;AACA,0F;AACA,E;AACA,0E;AACA,E;AACA,2I;AACA,2I;AACA,2I;AACA,2I;AACA,2I;AACA,2I;AACA,2I;AACA,wJ;AACA,wJ;AACA,E;AACA,gE;AACA,sD;AACA,E;AACA,Y;AACA,gC;AACA,U;AACA,uC;AACA,M;AACA,W;AACA,U;AACA,4D;AACA,M;AACA,E;AACA,yB;AACA,0E;AACA,+E;AACA,+C;AACA,G;AACA,2B;AACA,oD;AACA,yD;;AAEA,G;AACA,kB;AACA,sB;AACA,E;AACA,e;AACA,E;AACA,2E;AACA,E;AACA,Q;AACA,uE;AACA,2B;AACA,uB;AACA,sB;AACA,Q;AACA,M;AACA,K;AACA,E;AACA,kB;AACA,sD;AACA,E;AACA,G;AACA,0B;AACA,gB;AACA,qB;AACA,sB;AACA,uB;AACA,uB;AACA,sB;AACA,wB;AACA,oB;AACA,mB;AACA,sB;AACA,I;;AAEA,K;AACA,kB;AACA,+B;AACA,I;AACA,6E;AACA,I;AACA,wE;AACA,0E;AACA,4E;AACA,4E;AACA,0E;AACA,8E;AACA,0G;AACA,mE;AACA,qG;AACA,2C;AACA,I;AACA,iB;AACA,6C;AACA,K;AACA,qC;AACA,+C;AACA,I;;AAEA,kD;AACA,wC;AACA,oD;AACA,0D;AACA,wD;AACA,uB;AACA,+B;AACA,W;AACA,uC;AACA,W;AACA,O;AACA,M;AACA,G;;AAEA,K;AACA,mB;AACA,gB;AACA,I;AACA,iB;AACA,kB;AACA,I;AACA,kE;AACA,0E;AACA,I;AACA,8F;AACA,gG;AACA,oD;AACA,I;AACA,S;AACA,qE;AACA,+D;AACA,Q;AACA,O;AACA,sF;AACA,iF;AACA,gG;AACA,wF;AACA,4F;AACA,kB;AACA,I;AACA,wF;AACA,4F;AACA,kF;AACA,I;AACA,4D;AACA,kB;AACA,iB;AACA,iB;AACA,kB;AACA,qB;AACA,qB;AACA,qB;AACA,I;AACA,mG;AACA,e;AACA,I;AACA,I;AACA,oB;AACA,wD;AACA,K;AACA,0B;AACA,Y;AACA,6B;AACA,2B;AACA,Q;AACA,4B;AACA,M;AACA,I;AACA,C;;;AAGA,4D;AACA,0D;AACA,G;AACA,gD;AACA,2D;AACA,G;AACA,iD;;AAEA,yD;AACA,4D;AACA,G;;AAEA,yC;AACA,gG;AACA,G;;AAEA,iC;AACA,yB;AACA,yB;;AAEA,wF;AACA,kF;AACA,qG;AACA,gG;AACA,G;;AAEA,U;AACA,kB;AACA,wB;AACA,yG;AACA,gD;AACA,uC;AACA,yE;;AAEA,wC;AACA,mC;AACA,O;;AAEA,mC;AACA,4B;AACA,gC;AACA,uD;AACA,6D;AACA,+C;AACA,gD;AACA,Y;AACA,gB;AACA,uD;AACA,0E;AACA,Y;AACA,S;AACA,O;;AAEA,+C;AACA,yE;AACA,O;;AAEA,sB;AACA,qB;AACA,wB;AACA,8C;AACA,qC;AACA,W;AACA,sE;AACA,mE;AACA,6D;AACA,W;AACA,gB;AACA,qB;AACA,8C;AACA,wC;AACA,W;AACA,0C;AACA,0D;AACA,mD;AACA,a;AACA,0D;AACA,mD;AACA,a;AACA,8C;AACA,2F;AACA,mD;AACA,iB;AACA,a;AACA,W;AACA,gB;AACA,yB;AACA,0E;AACA,8C;AACA,W;AACA,gB;AACA,O;;AAEA,0B;AACA,iC;AACA,O;;AAEA,oG;AACA,qD;AACA,yC;AACA,oD;AACA,+C;AACA,W;AACA,O;;AAEA,kE;AACA,oD;AACA,kC;AACA,mD;AACA,8C;AACA,W;AACA,O;AACA,K;AACA,I;AACA,G;AACA,oD;AACA,0D;AACA,G;AACA,qC;AACA,U;AACA,kB;AACA,2B;AACA,mD;AACA,oC;AACA,4C;AACA,O;AACA,K;AACA,I;AACA,E;AACA,kE;AACA,U;AACA,kB;AACA,mC;AACA,0F;AACA,0C;;AAEA,iE;;AAEA,mD;AACA,+D;AACA,wB;AACA,W;AACA,S;AACA,sE;AACA,sC;AACA,S;;AAEA,iE;AACA,mC;AACA,S;;AAEA,oG;AACA,+C;AACA,+D;AACA,qC;AACA,a;;AAEA,iC;AACA,2C;AACA,a;AACA,a;AACA,S;AACA,Q;AACA,K;AACA,I;AACA,G;AACA,oD;AACA,sC;AACA,6D;AACA,+B;AACA,K;AACA,I;AACA,I;;;AAGA,2B","file":"/packages/angular_angular-aria.js","sourcesContent":["/**\n * @license AngularJS v1.3.15\n * (c) 2010-2014 Google, Inc. http://angularjs.org\n * License: MIT\n */\n(function(window, angular, undefined) {'use strict';\n\n/**\n * @ngdoc module\n * @name ngAria\n * @description\n *\n * The `ngAria` module provides support for common\n * [<abbr title=\"Accessible Rich Internet Applications\">ARIA</abbr>](http://www.w3.org/TR/wai-aria/)\n * attributes that convey state or semantic information about the application for users\n * of assistive technologies, such as screen readers.\n *\n * <div doc-module-components=\"ngAria\"></div>\n *\n * ## Usage\n *\n * For ngAria to do its magic, simply include the module as a dependency. The directives supported\n * by ngAria are:\n * `ngModel`, `ngDisabled`, `ngShow`, `ngHide`, `ngClick`, `ngDblClick`, and `ngMessages`.\n *\n * Below is a more detailed breakdown of the attributes handled by ngAria:\n *\n * | Directive                                   | Supported Attributes                                                                   |\n * |---------------------------------------------|----------------------------------------------------------------------------------------|\n * | {@link ng.directive:ngDisabled ngDisabled}  | aria-disabled                                                                          |\n * | {@link ng.directive:ngShow ngShow}          | aria-hidden                                                                            |\n * | {@link ng.directive:ngHide ngHide}          | aria-hidden                                                                            |\n * | {@link ng.directive:ngDblclick ngDblclick}  | tabindex                                                                               |\n * | {@link module:ngMessages ngMessages}        | aria-live                                                                              |\n * | {@link ng.directive:ngModel ngModel}        | aria-checked, aria-valuemin, aria-valuemax, aria-valuenow, aria-invalid, aria-required, input roles |\n * | {@link ng.directive:ngClick ngClick}        | tabindex, keypress event, button role                                                               |\n *\n * Find out more information about each directive by reading the\n * {@link guide/accessibility ngAria Developer Guide}.\n *\n * ##Example\n * Using ngDisabled with ngAria:\n * ```html\n * <md-checkbox ng-disabled=\"disabled\">\n * ```\n * Becomes:\n * ```html\n * <md-checkbox ng-disabled=\"disabled\" aria-disabled=\"true\">\n * ```\n *\n * ##Disabling Attributes\n * It's possible to disable individual attributes added by ngAria with the\n * {@link ngAria.$ariaProvider#config config} method. For more details, see the\n * {@link guide/accessibility Developer Guide}.\n */\n /* global -ngAriaModule */\nvar ngAriaModule = angular.module('ngAria', ['ng']).\n                        provider('$aria', $AriaProvider);\n\n/**\n * @ngdoc provider\n * @name $ariaProvider\n *\n * @description\n *\n * Used for configuring the ARIA attributes injected and managed by ngAria.\n *\n * ```js\n * angular.module('myApp', ['ngAria'], function config($ariaProvider) {\n *   $ariaProvider.config({\n *     ariaValue: true,\n *     tabindex: false\n *   });\n * });\n *```\n *\n * ## Dependencies\n * Requires the {@link ngAria} module to be installed.\n *\n */\nfunction $AriaProvider() {\n  var config = {\n    ariaHidden: true,\n    ariaChecked: true,\n    ariaDisabled: true,\n    ariaRequired: true,\n    ariaInvalid: true,\n    ariaMultiline: true,\n    ariaValue: true,\n    tabindex: true,\n    bindKeypress: true\n  };\n\n  /**\n   * @ngdoc method\n   * @name $ariaProvider#config\n   *\n   * @param {object} config object to enable/disable specific ARIA attributes\n   *\n   *  - **ariaHidden** – `{boolean}` – Enables/disables aria-hidden tags\n   *  - **ariaChecked** – `{boolean}` – Enables/disables aria-checked tags\n   *  - **ariaDisabled** – `{boolean}` – Enables/disables aria-disabled tags\n   *  - **ariaRequired** – `{boolean}` – Enables/disables aria-required tags\n   *  - **ariaInvalid** – `{boolean}` – Enables/disables aria-invalid tags\n   *  - **ariaMultiline** – `{boolean}` – Enables/disables aria-multiline tags\n   *  - **ariaValue** – `{boolean}` – Enables/disables aria-valuemin, aria-valuemax and aria-valuenow tags\n   *  - **tabindex** – `{boolean}` – Enables/disables tabindex tags\n   *  - **bindKeypress** – `{boolean}` – Enables/disables keypress event binding on `&lt;div&gt;` and\n   *    `&lt;li&gt;` elements with ng-click\n   *\n   * @description\n   * Enables/disables various ARIA attributes\n   */\n  this.config = function(newConfig) {\n    config = angular.extend(config, newConfig);\n  };\n\n  function watchExpr(attrName, ariaAttr, negate) {\n    return function(scope, elem, attr) {\n      var ariaCamelName = attr.$normalize(ariaAttr);\n      if (config[ariaCamelName] && !attr[ariaCamelName]) {\n        scope.$watch(attr[attrName], function(boolVal) {\n          if (negate) {\n            boolVal = !boolVal;\n          }\n          elem.attr(ariaAttr, boolVal);\n        });\n      }\n    };\n  }\n\n  /**\n   * @ngdoc service\n   * @name $aria\n   *\n   * @description\n   * @priority 200\n   *\n   * The $aria service contains helper methods for applying common\n   * [ARIA](http://www.w3.org/TR/wai-aria/) attributes to HTML directives.\n   *\n   * ngAria injects common accessibility attributes that tell assistive technologies when HTML\n   * elements are enabled, selected, hidden, and more. To see how this is performed with ngAria,\n   * let's review a code snippet from ngAria itself:\n   *\n   *```js\n   * ngAriaModule.directive('ngDisabled', ['$aria', function($aria) {\n   *   return $aria.$$watchExpr('ngDisabled', 'aria-disabled');\n   * }])\n   *```\n   * Shown above, the ngAria module creates a directive with the same signature as the\n   * traditional `ng-disabled` directive. But this ngAria version is dedicated to\n   * solely managing accessibility attributes. The internal `$aria` service is used to watch the\n   * boolean attribute `ngDisabled`. If it has not been explicitly set by the developer,\n   * `aria-disabled` is injected as an attribute with its value synchronized to the value in\n   * `ngDisabled`.\n   *\n   * Because ngAria hooks into the `ng-disabled` directive, developers do not have to do\n   * anything to enable this feature. The `aria-disabled` attribute is automatically managed\n   * simply as a silent side-effect of using `ng-disabled` with the ngAria module.\n   *\n   * The full list of directives that interface with ngAria:\n   * * **ngModel**\n   * * **ngShow**\n   * * **ngHide**\n   * * **ngClick**\n   * * **ngDblclick**\n   * * **ngMessages**\n   * * **ngDisabled**\n   *\n   * Read the {@link guide/accessibility ngAria Developer Guide} for a thorough explanation of each\n   * directive.\n   *\n   *\n   * ## Dependencies\n   * Requires the {@link ngAria} module to be installed.\n   */\n  this.$get = function() {\n    return {\n      config: function(key) {\n        return config[key];\n      },\n      $$watchExpr: watchExpr\n    };\n  };\n}\n\n\nngAriaModule.directive('ngShow', ['$aria', function($aria) {\n  return $aria.$$watchExpr('ngShow', 'aria-hidden', true);\n}])\n.directive('ngHide', ['$aria', function($aria) {\n  return $aria.$$watchExpr('ngHide', 'aria-hidden', false);\n}])\n.directive('ngModel', ['$aria', function($aria) {\n\n  function shouldAttachAttr(attr, normalizedAttr, elem) {\n    return $aria.config(normalizedAttr) && !elem.attr(attr);\n  }\n\n  function shouldAttachRole(role, elem) {\n    return !elem.attr('role') && (elem.attr('type') === role) && (elem[0].nodeName !== 'INPUT');\n  }\n\n  function getShape(attr, elem) {\n    var type = attr.type,\n        role = attr.role;\n\n    return ((type || role) === 'checkbox' || role === 'menuitemcheckbox') ? 'checkbox' :\n           ((type || role) === 'radio'    || role === 'menuitemradio') ? 'radio' :\n           (type === 'range'              || role === 'progressbar' || role === 'slider') ? 'range' :\n           (type || role) === 'textbox'   || elem[0].nodeName === 'TEXTAREA' ? 'multiline' : '';\n  }\n\n  return {\n    restrict: 'A',\n    require: '?ngModel',\n    priority: 200, //Make sure watches are fired after any other directives that affect the ngModel value\n    link: function(scope, elem, attr, ngModel) {\n      var shape = getShape(attr, elem);\n      var needsTabIndex = shouldAttachAttr('tabindex', 'tabindex', elem);\n\n      function ngAriaWatchModelValue() {\n        return ngModel.$modelValue;\n      }\n\n      function getRadioReaction() {\n        if (needsTabIndex) {\n          needsTabIndex = false;\n          return function ngAriaRadioReaction(newVal) {\n            var boolVal = (attr.value == ngModel.$viewValue);\n            elem.attr('aria-checked', boolVal);\n            elem.attr('tabindex', 0 - !boolVal);\n          };\n        } else {\n          return function ngAriaRadioReaction(newVal) {\n            elem.attr('aria-checked', (attr.value == ngModel.$viewValue));\n          };\n        }\n      }\n\n      function ngAriaCheckboxReaction(newVal) {\n        elem.attr('aria-checked', !ngModel.$isEmpty(ngModel.$viewValue));\n      }\n\n      switch (shape) {\n        case 'radio':\n        case 'checkbox':\n          if (shouldAttachRole(shape, elem)) {\n            elem.attr('role', shape);\n          }\n          if (shouldAttachAttr('aria-checked', 'ariaChecked', elem)) {\n            scope.$watch(ngAriaWatchModelValue, shape === 'radio' ?\n                getRadioReaction() : ngAriaCheckboxReaction);\n          }\n          break;\n        case 'range':\n          if (shouldAttachRole(shape, elem)) {\n            elem.attr('role', 'slider');\n          }\n          if ($aria.config('ariaValue')) {\n            if (attr.min && !elem.attr('aria-valuemin')) {\n              elem.attr('aria-valuemin', attr.min);\n            }\n            if (attr.max && !elem.attr('aria-valuemax')) {\n              elem.attr('aria-valuemax', attr.max);\n            }\n            if (!elem.attr('aria-valuenow')) {\n              scope.$watch(ngAriaWatchModelValue, function ngAriaValueNowReaction(newVal) {\n                elem.attr('aria-valuenow', newVal);\n              });\n            }\n          }\n          break;\n        case 'multiline':\n          if (shouldAttachAttr('aria-multiline', 'ariaMultiline', elem)) {\n            elem.attr('aria-multiline', true);\n          }\n          break;\n      }\n\n      if (needsTabIndex) {\n        elem.attr('tabindex', 0);\n      }\n\n      if (ngModel.$validators.required && shouldAttachAttr('aria-required', 'ariaRequired', elem)) {\n        scope.$watch(function ngAriaRequiredWatch() {\n          return ngModel.$error.required;\n        }, function ngAriaRequiredReaction(newVal) {\n          elem.attr('aria-required', !!newVal);\n        });\n      }\n\n      if (shouldAttachAttr('aria-invalid', 'ariaInvalid', elem)) {\n        scope.$watch(function ngAriaInvalidWatch() {\n          return ngModel.$invalid;\n        }, function ngAriaInvalidReaction(newVal) {\n          elem.attr('aria-invalid', !!newVal);\n        });\n      }\n    }\n  };\n}])\n.directive('ngDisabled', ['$aria', function($aria) {\n  return $aria.$$watchExpr('ngDisabled', 'aria-disabled');\n}])\n.directive('ngMessages', function() {\n  return {\n    restrict: 'A',\n    require: '?ngMessages',\n    link: function(scope, elem, attr, ngMessages) {\n      if (!elem.attr('aria-live')) {\n        elem.attr('aria-live', 'assertive');\n      }\n    }\n  };\n})\n.directive('ngClick',['$aria', '$parse', function($aria, $parse) {\n  return {\n    restrict: 'A',\n    compile: function(elem, attr) {\n      var fn = $parse(attr.ngClick, /* interceptorFn */ null, /* expensiveChecks */ true);\n      return function(scope, elem, attr) {\n\n        var nodeBlackList = ['BUTTON', 'A', 'INPUT', 'TEXTAREA'];\n\n        function isNodeOneOf(elem, nodeTypeArray) {\n          if (nodeTypeArray.indexOf(elem[0].nodeName) !== -1) {\n            return true;\n          }\n        }\n        if (!elem.attr('role') && !isNodeOneOf(elem, nodeBlackList)) {\n          elem.attr('role', 'button');\n        }\n\n        if ($aria.config('tabindex') && !elem.attr('tabindex')) {\n          elem.attr('tabindex', 0);\n        }\n\n        if ($aria.config('bindKeypress') && !attr.ngKeypress && !isNodeOneOf(elem, nodeBlackList)) {\n          elem.on('keypress', function(event) {\n            if (event.keyCode === 32 || event.keyCode === 13) {\n              scope.$apply(callback);\n            }\n\n            function callback() {\n              fn(scope, { $event: event });\n            }\n          });\n        }\n      };\n    }\n  };\n}])\n.directive('ngDblclick', ['$aria', function($aria) {\n  return function(scope, elem, attr) {\n    if ($aria.config('tabindex') && !elem.attr('tabindex')) {\n      elem.attr('tabindex', 0);\n    }\n  };\n}]);\n\n\n})(window, window.angular);\n"]}