)]}'
{"version":3,"sources":["angular:angular-material/bower_components/angular-material/angular-material.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,G;AACA,0B;AACA,sC;AACA,e;AACA,S;AACA,G;AACA,wC;AACA,a;;AAEA,Y;AACA,a;;AAEA,4gC;AACA,K;AACA,Y;AACA,a;;;AAGA,G;AACA,qD;AACA,gB;AACA,G;AACA,O;AACA,iF;AACA,6B;;;AAGA,wD;;AAEA,2D;;AAEA,qC;AACA,6B;AACA,0B;AACA,uB;AACA,+B;AACA,C;AACA,6D;;AAEA,oC;AACA,K;AACA,oD;AACA,4E;AACA,kB;AACA,I;AACA,qE;AACA,sE;AACA,yE;AACA,2C;AACA,I;AACA,oD;AACA,K;AACA,qC;AACA,mD;AACA,iC;AACA,4B;AACA,qB;AACA,mB;AACA,2B;AACA,6B;AACA,8B;AACA,4C;AACA,gC;AACA,W;AACA,O;AACA,M;AACA,I;AACA,mB;AACA,C;;AAEA,K;AACA,Y;AACA,a;;AAEA,+B;AACA,2C;;AAEA,6C;;AAEA,qD;AACA,iC;AACA,0F;AACA,G;;AAEA,U;AACA,e;AACA,gB;AACA,iB;AACA,gB;AACA,sB;AACA,oB;AACA,uB;AACA,sB;AACA,c;AACA,mB;AACA,gB;AACA,M;AACA,U;AACA,qB;AACA,8E;AACA,2E;;AAEA,6C;AACA,0D;AACA,+C;AACA,gE;AACA,iE;AACA,8D;AACA,sD;AACA,kE;AACA,+D;AACA,M;AACA,Y;AACA,iC;AACA,oC;AACA,wD;AACA,oC;AACA,yD;AACA,oC;AACA,M;AACA,qB;AACA,c;AACA,W;AACA,c;AACA,W;AACA,c;AACA,U;AACA,K;AACA,I;AACA,C;AACA,kD;;AAEA,K;AACA,Y;AACA,a;;AAEA,S;AACA,4B;AACA,6C;AACA,wE;AACA,c;AACA,kF;AACA,iC;AACA,c;AACA,2C;;AAEA,4B;AACA,U;AACA,U;AACA,S;;AAEA,K;AACA,wE;AACA,I;AACA,+D;AACA,qF;AACA,K;AACA,sC;AACA,6C;;AAEA,2C;AACA,gD;AACA,K;;AAEA,sB;AACA,8B;;AAEA,oB;AACA,Y;AACA,sB;AACA,mB;;AAEA,uB;AACA,yB;AACA,uB;AACA,qB;;AAEA,qB;;AAEA,e;AACA,qB;;AAEA,mB;AACA,iB;AACA,0D;AACA,6D;;AAEA,+B;AACA,sB;;AAEA,M;;AAEA,O;AACA,yC;AACA,yB;AACA,O;AACA,yB;AACA,+B;AACA,K;;AAEA,O;AACA,mC;AACA,uC;AACA,O;AACA,sB;AACA,2B;AACA,K;;AAEA,O;AACA,mC;AACA,mB;AACA,+C;AACA,O;AACA,6B;AACA,yE;AACA,K;;AAEA,O;AACA,yE;AACA,0B;AACA,M;AACA,kB;AACA,+C;AACA,O;AACA,4B;AACA,uD;AACA,K;;AAEA,O;AACA,6E;AACA,0B;AACA,M;AACA,kB;AACA,+C;AACA,O;AACA,gC;AACA,uD;AACA,K;;AAEA,O;AACA,2C;AACA,mB;AACA,mB;AACA,O;AACA,4B;AACA,mD;AACA,K;;AAEA,O;AACA,oD;AACA,4B;AACA,M;AACA,iB;AACA,iB;AACA,M;AACA,oB;AACA,O;AACA,+B;AACA,2C;AACA,iC;AACA,S;AACA,K;;AAEA,O;AACA,uB;AACA,kB;AACA,mB;AACA,mB;AACA,O;AACA,+B;AACA,6B;;AAEA,qC;AACA,8B;AACA,O;;AAEA,oC;;AAEA,2B;AACA,K;;AAEA,O;AACA,+B;AACA,kB;AACA,O;AACA,2B;AACA,4B;AACA,wC;AACA,O;AACA,K;;AAEA,O;AACA,kD;AACA,kB;AACA,mB;AACA,O;AACA,4B;AACA,kC;AACA,K;;AAEA,O;AACA,8B;AACA,kB;AACA,yB;AACA,O;AACA,6B;AACA,0C;AACA,K;;AAEA,O;AACA,oC;AACA,mB;AACA,O;AACA,sB;AACA,8C;AACA,K;;AAEA,O;AACA,sC;AACA,mB;AACA,O;AACA,qB;AACA,8D;AACA,K;;AAEA,O;AACA,+F;AACA,oG;AACA,uE;AACA,M;AACA,2F;AACA,wE;AACA,0D;AACA,kD;AACA,M;AACA,+C;AACA,O;AACA,mE;AACA,oC;;AAEA,mC;AACA,oB;AACA,4C;;AAEA,wD;AACA,6B;AACA,iC;AACA,wC;AACA,4B;AACA,mD;AACA,yC;AACA,S;;AAEA,uE;AACA,kD;;AAEA,0D;;AAEA,6B;AACA,O;AACA,K;AACA,G;;;AAGA,K;AACA,Y;AACA,a;;AAEA,+B;AACA,qC;;AAEA,G;AACA,iB;AACA,iB;AACA,wB;AACA,E;AACA,e;AACA,wF;AACA,kG;AACA,2B;AACA,E;AACA,kG;AACA,kD;AACA,E;AACA,mG;AACA,E;AACA,S;AACA,mB;AACA,8D;AACA,yE;AACA,8B;AACA,Q;AACA,E;AACA,2C;AACA,0D;AACA,yD;AACA,M;AACA,U;AACA,G;;AAEA,2D;AACA,mB;AACA,gB;AACA,mB;AACA,0B;;AAEA,2D;AACA,+B;AACA,iE;;AAEA,kB;;AAEA,4B;AACA,mC;AACA,yC;AACA,mD;AACA,K;;AAEA,oC;AACA,sC;AACA,8B;AACA,K;;AAEA,kB;AACA,G;;AAEA,4B;AACA,sC;AACA,qE;AACA,G;;AAEA,uB;AACA,yD;AACA,sC;AACA,sD;AACA,G;;AAEA,iC;AACA,sC;AACA,6C;AACA,O;AACA,G;;AAEA,2B;AACA,sB;AACA,G;;AAEA,oD;AACA,iE;AACA,oD;AACA,8C;AACA,iB;AACA,O;;AAEA,gF;AACA,kC;AACA,qC;AACA,O;AACA,K;;AAEA,6B;AACA,qD;AACA,G;;AAEA,iE;AACA,wB;AACA,0C;AACA,8D;AACA,kC;AACA,wB;AACA,iF;AACA,O;;AAEA,gD;AACA,8E;AACA,qC;AACA,iB;AACA,S;;AAEA,kG;AACA,O;AACA,O;;AAEA,+B;AACA,gD;AACA,M;AACA,G;;AAEA,sC;AACA,+C;AACA,sC;AACA,gE;AACA,G;AACA,C;AACA,kE;;AAEA,K;AACA,Y;AACA,a;;AAEA,E;AACA,iE;AACA,8D;AACA,+D;AACA,sB;AACA,G;AACA,iC;;AAEA,+B;AACA,uK;AACA,W;;AAEA,wB;AACA,uB;AACA,G;;AAEA,iB;AACA,6B;AACA,gE;AACA,e;;AAEA,+D;AACA,kC;AACA,iF;AACA,kD;;AAEA,iF;AACA,qD;AACA,qC;AACA,8C;AACA,iD;AACA,c;AACA,8C;AACA,2C;AACA,8B;AACA,+B;AACA,Q;AACA,M;AACA,iD;AACA,0D;AACA,M;AACA,2E;AACA,gF;AACA,mD;AACA,4C;AACA,0E;AACA,6B;AACA,wB;;AAEA,oD;AACA,wE;AACA,oC;AACA,uD;AACA,S;AACA,O;;AAEA,uD;AACA,2B;AACA,0C;AACA,6D;AACA,O;;AAEA,6C;AACA,mC;AACA,c;AACA,sC;AACA,O;;AAEA,6G;AACA,uC;AACA,qH;AACA,oE;AACA,gE;AACA,wE;AACA,oC;AACA,gF;AACA,0C;AACA,4C;AACA,sC;AACA,uC;AACA,W;AACA,yE;AACA,qD;;AAEA,+C;AACA,mD;AACA,+C;;AAEA,yC;AACA,kC;AACA,sC;AACA,8D;AACA,kD;AACA,U;;AAEA,oE;AACA,0E;AACA,4C;AACA,mC;AACA,iD;AACA,+B;AACA,yC;AACA,W;AACA,S;;AAEA,oC;AACA,6B;AACA,S;AACA,O;;AAEA,oH;AACA,oC;AACA,qE;AACA,mD;;AAEA,oC;AACA,4B;AACA,wB;AACA,8B;AACA,mC;AACA,W;;AAEA,yC;AACA,4D;AACA,iD;AACA,U;AACA,O;;AAEA,yC;AACA,iC;AACA,sC;AACA,S;AACA,O;;AAEA,gC;AACA,sD;AACA,iD;AACA,O;AACA,M;;AAEA,oC;AACA,yD;AACA,4K;AACA,mD;AACA,4G;AACA,0B;AACA,O;AACA,4C;AACA,M;;AAEA,6E;AACA,mC;AACA,uC;;AAEA,oE;AACA,8C;AACA,uB;AACA,wC;AACA,8B;AACA,0D;AACA,S;AACA,e;;AAEA,yD;AACA,2E;AACA,4D;AACA,gC;AACA,6B;AACA,mC;AACA,M;;AAEA,mD;AACA,wB;AACA,gC;AACA,0D;AACA,6B;AACA,qE;AACA,8C;AACA,+D;AACA,6B;AACA,S;AACA,O;AACA,yD;AACA,8B;AACA,M;;AAEA,6B;AACA,c;AACA,oB;AACA,kC;AACA,wC;AACA,kC;AACA,8B;AACA,oE;AACA,U;AACA,mC;AACA,2C;AACA,U;AACA,qB;AACA,wB;AACA,iC;AACA,6B;AACA,Q;AACA,M;;AAEA,gF;AACA,gF;AACA,sB;AACA,sG;AACA,8E;AACA,yD;AACA,gB;;AAEA,mC;AACA,4B;AACA,uD;;AAEA,+B;AACA,qC;;AAEA,4B;AACA,oC;;AAEA,qC;AACA,Q;AACA,M;;AAEA,gF;AACA,8E;AACA,qD;AACA,8C;AACA,iB;AACA,mC;AACA,2B;AACA,6B;AACA,6B;;AAEA,gD;AACA,oC;AACA,uB;AACA,S;AACA,Q;AACA,M;;AAEA,O;AACA,6E;AACA,0D;AACA,O;AACA,6B;AACA,6B;AACA,W;AACA,gC;AACA,M;;AAEA,O;AACA,gC;AACA,gG;AACA,mG;AACA,6F;AACA,yE;AACA,M;AACA,8C;AACA,O;AACA,yB;AACA,sC;AACA,gB;;AAEA,qB;AACA,gB;AACA,kD;AACA,kC;AACA,oC;AACA,uC;AACA,S;AACA,mC;AACA,oC;AACA,gB;AACA,+D;AACA,uC;AACA,S;AACA,O;AACA,gC;AACA,mC;AACA,M;;AAEA,6E;AACA,0E;AACA,sD;AACA,yB;;AAEA,mF;AACA,wC;AACA,qC;;AAEA,iC;AACA,kC;;AAEA,2B;AACA,iF;AACA,iF;AACA,uF;AACA,uF;;AAEA,uD;;AAEA,M;;AAEA,iD;AACA,oD;AACA,yB;;AAEA,wE;AACA,wC;AACA,wC;;AAEA,wB;;AAEA,iC;AACA,mC;AACA,yC;AACA,+C;AACA,+B;AACA,iD;AACA,mC;AACA,c;AACA,wD;AACA,O;AACA,M;;AAEA,M;AACA,wG;AACA,M;AACA,sD;AACA,oE;AACA,O;AACA,8D;AACA,oD;AACA,sC;AACA,yC;AACA,2B;AACA,U;AACA,sC;AACA,oB;AACA,S;AACA,mC;AACA,kB;AACA,M;;AAEA,O;AACA,mE;AACA,uF;AACA,O;AACA,wD;AACA,2D;AACA,4D;AACA,6C;AACA,S;AACA,O;AACA,qB;AACA,M;;AAEA,O;AACA,uE;AACA,O;AACA,+D;AACA,kC;AACA,yE;AACA,mE;AACA,+E;;AAEA,kF;AACA,U;AACA,U;AACA,K;;AAEA,I;;AAEA,I;;AAEA,E;AACA,yF;AACA,E;AACA,qF;AACA,E;AACA,+D;AACA,G;;AAEA,iF;AACA,oB;AACA,oB;AACA,G;AACA,c;AACA,E;AACA,+E;AACA,oB;AACA,mB;AACA,G;AACA,c;AACA,E;;AAEA,K;AACA,Y;AACA,a;;;AAGA,+B;AACA,mC;;AAEA,E;AACA,Y;AACA,G;AACA,4C;;AAEA,U;AACA,mB;AACA,6B;AACA,kC;AACA,I;;AAEA,K;AACA,kF;AACA,mB;AACA,oB;AACA,gF;AACA,K;AACA,oD;AACA,qC;;AAEA,wE;AACA,e;AACA,wC;AACA,oD;AACA,8C;;AAEA,+E;AACA,gC;AACA,6C;AACA,c;AACA,6G;AACA,O;;AAEA,K;AACA,G;;AAEA,+D;AACA,uF;AACA,gE;AACA,oF;AACA,sB;AACA,sD;AACA,O;AACA,G;;AAEA,8C;AACA,+C;AACA,8B;AACA,O;AACA,G;;AAEA,6B;AACA,iC;AACA,G;;AAEA,8C;AACA,2C;AACA,wB;;AAEA,2B;AACA,mF;AACA,wC;AACA,K;;AAEA,qB;AACA,qC;AACA,2C;AACA,gC;AACA,kE;AACA,+B;AACA,2B;AACA,W;AACA,S;AACA,O;AACA,K;AACA,mB;AACA,G;AACA,C;AACA,mD;;AAEA,K;AACA,Y;AACA,a;;AAEA,+B;AACA,6C;;AAEA,yF;AACA,8B;;AAEA,I;AACA,mB;AACA,sB;AACA,0B;AACA,iB;AACA,+F;AACA,6E;AACA,I;AACA,W;AACA,qB;AACA,0B;AACA,iC;AACA,+B;AACA,gB;AACA,gC;AACA,Q;AACA,oC;AACA,kE;AACA,wE;AACA,Q;AACA,Y;AACA,K;;AAEA,K;AACA,mB;AACA,+B;AACA,4F;AACA,wB;AACA,+E;AACA,K;AACA,+F;AACA,4F;AACA,kG;AACA,4D;AACA,iE;AACA,kE;AACA,uG;AACA,wF;AACA,uE;AACA,oG;AACA,mG;AACA,gG;AACA,+C;AACA,2F;AACA,4F;AACA,8F;AACA,wF;AACA,0C;AACA,K;AACA,+F;AACA,kD;AACA,K;AACA,wF;AACA,yF;AACA,yE;AACA,mG;AACA,yF;AACA,qG;AACA,M;AACA,oC;AACA,0C;AACA,0C;AACA,wC;AACA,4C;AACA,wC;AACA,sC;AACA,0E;AACA,oD;;AAEA,6C;AACA,2E;AACA,wF;AACA,mD;AACA,oC;AACA,4C;AACA,c;AACA,+C;AACA,O;AACA,O;AACA,8D;AACA,oE;AACA,oC;;AAEA,sB;AACA,yE;AACA,kC;AACA,+B;AACA,W;AACA,Y;AACA,4C;AACA,K;;AAEA,+D;AACA,kD;;AAEA,yD;AACA,iG;AACA,qC;;AAEA,kF;AACA,c;AACA,uB;AACA,yB;AACA,oC;AACA,gC;;AAEA,sE;AACA,2B;AACA,mE;AACA,mC;AACA,0D;AACA,a;AACA,oC;AACA,qD;AACA,0D;AACA,qE;;AAEA,+B;AACA,yC;AACA,a;AACA,W;AACA,+B;AACA,S;AACA,Q;AACA,O;;AAEA,I;AACA,C;AACA,sG;;AAEA,K;AACA,Y;AACA,a;;AAEA,oB;AACA,uC;AACA,2D;AACA,gE;AACA,0D;AACA,K;AACA,yD;;AAEA,2E;AACA,4B;AACA,E;AACA,S;AACA,0C;AACA,8C;AACA,oD;AACA,6B;;AAEA,K;AACA,qB;AACA,+B;AACA,qC;AACA,M;AACA,mB;AACA,qG;AACA,+G;AACA,e;AACA,M;AACA,uB;AACA,kD;AACA,M;AACA,8D;AACA,8D;AACA,gD;AACA,M;AACA,Y;AACA,c;AACA,M;AACA,O;AACA,kC;;AAEA,iC;;AAEA,mE;AACA,4C;AACA,iC;AACA,yC;AACA,M;;AAEA,O;AACA,sD;AACA,gB;AACA,O;AACA,sG;AACA,mE;AACA,M;AACA,I;;;;AAIA,K;AACA,4C;AACA,c;AACA,K;AACA,2D;AACA,4E;AACA,qD;AACA,gD;AACA,mG;;AAEA,gB;AACA,0B;AACA,yB;AACA,mF;AACA,oF;AACA,M;;AAEA,iC;AACA,6B;AACA,kB;AACA,wB;AACA,U;AACA,uC;AACA,kE;AACA,4C;AACA,W;AACA,S;AACA,S;AACA,K;;AAEA,M;AACA,mD;AACA,4E;AACA,6E;AACA,2F;AACA,M;AACA,uE;AACA,8F;AACA,O;AACA,sD;AACA,gE;AACA,qB;AACA,yF;AACA,mE;AACA,O;AACA,uD;AACA,K;;AAEA,M;AACA,8C;AACA,O;AACA,2C;AACA,iD;AACA,0C;AACA,+B;;AAEA,kB;AACA,K;;AAEA,M;AACA,kF;AACA,mF;AACA,mC;AACA,2B;AACA,O;AACA,e;AACA,Q;AACA,qE;AACA,wE;AACA,S;AACA,yB;AACA,yC;AACA,kD;AACA,U;AACA,uC;AACA,gD;AACA,S;AACA,Q;;AAEA,Q;AACA,mF;AACA,oD;AACA,qF;AACA,gE;AACA,S;AACA,wB;AACA,kB;AACA,yB;AACA,oB;AACA,U;AACA,+B;AACA,8C;AACA,U;AACA,yC;AACA,mF;AACA,iE;AACA,iE;;AAEA,wD;AACA,mF;AACA,+C;AACA,wC;AACA,+C;AACA,U;AACA,wC;AACA,iD;AACA,2F;AACA,6F;AACA,8B;AACA,8B;;AAEA,qF;AACA,2B;AACA,gD;AACA,gD;AACA,wE;AACA,0B;AACA,W;AACA,U;AACA,4B;AACA,0B;AACA,S;AACA,Q;;AAEA,Q;AACA,qG;AACA,mF;AACA,iH;AACA,iI;AACA,gF;AACA,S;AACA,wB;AACA,kB;AACA,yB;AACA,2B;AACA,+B;AACA,U;AACA,gC;AACA,mF;AACA,0D;AACA,U;AACA,wC;AACA,4C;AACA,qF;AACA,2F;AACA,6F;AACA,8B;AACA,8B;;AAEA,wC;AACA,gD;AACA,6F;AACA,gI;AACA,oB;AACA,6F;AACA,gI;AACA,a;;AAEA,kC;AACA,4G;AACA,4D;AACA,6D;AACA,8E;;AAEA,sC;AACA,4B;AACA,a;AACA,kB;AACA,sC;AACA,W;AACA,U;AACA,6E;AACA,wD;AACA,4E;AACA,qC;AACA,2D;AACA,uE;AACA,W;AACA,W;AACA,uC;AACA,uC;AACA,2D;AACA,0E;AACA,W;AACA,S;AACA,Q;;AAEA,Q;AACA,iF;AACA,oD;AACA,2F;AACA,S;AACA,yB;AACA,kB;AACA,4B;AACA,yB;AACA,U;AACA,uC;AACA,6E;AACA,2E;AACA,8F;AACA,8C;AACA,W;AACA,S;AACA,S;;AAEA,G;AACA,kE;;AAEA,K;AACA,qB;AACA,8E;AACA,sE;AACA,I;AACA,+E;AACA,sD;AACA,I;AACA,0F;AACA,qE;AACA,K;AACA,kC;AACA,qB;AACA,oB;AACA,G;;AAEA,+B;AACA,mG;;AAEA,gC;AACA,kB;AACA,yF;AACA,0C;AACA,4E;;AAEA,uD;AACA,4B;AACA,2B;AACA,0B;AACA,6B;;AAEA,qF;AACA,wD;AACA,qC;AACA,yC;AACA,4D;AACA,6D;AACA,2F;;AAEA,sB;AACA,0B;AACA,sF;AACA,yE;AACA,4F;AACA,wC;AACA,U;AACA,kC;AACA,Q;AACA,oC;AACA,0C;AACA,iC;AACA,Q;AACA,mC;AACA,0C;AACA,gC;AACA,qC;AACA,Q;AACA,sC;AACA,mC;AACA,wB;AACA,Q;;AAEA,+E;AACA,iF;AACA,yC;AACA,2B;AACA,yB;AACA,sD;AACA,2B;AACA,W;AACA,uC;AACA,S;AACA,oB;AACA,Q;;AAEA,yF;AACA,qF;AACA,oE;AACA,oD;AACA,wB;AACA,4D;AACA,yD;AACA,0C;;AAEA,yB;;AAEA,8B;AACA,kD;AACA,6C;AACA,S;AACA,O;AACA,M;;AAEA,0B;;AAEA,M;AACA,oC;AACA,iD;AACA,M;AACA,sE;AACA,uF;AACA,sE;AACA,O;AACA,qE;AACA,6C;AACA,0D;;AAEA,gC;AACA,sC;AACA,mC;;AAEA,gC;AACA,gC;AACA,gC;AACA,gC;AACA,gC;AACA,8B;AACA,8B;AACA,kC;AACA,gC;AACA,oC;AACA,iC;AACA,S;AACA,6D;AACA,K;;AAEA,M;AACA,+D;AACA,sE;AACA,uF;AACA,sE;AACA,O;AACA,qE;AACA,6C;AACA,mB;;AAEA,kC;AACA,uD;AACA,gC;AACA,uD;AACA,yE;AACA,iF;AACA,yD;AACA,U;;AAEA,c;AACA,uD;AACA,4D;AACA,O;AACA,gC;AACA,sC;AACA,mC;AACA,kD;AACA,K;;AAEA,G;;AAEA,K;AACA,iE;AACA,c;AACA,K;AACA,+D;;AAEA,2C;AACA,yB;AACA,+D;AACA,0C;AACA,O;;AAEA,0D;AACA,Q;AACA,0E;AACA,yF;AACA,wE;AACA,4E;AACA,iG;AACA,S;AACA,qE;AACA,8D;AACA,mD;AACA,S;AACA,qE;AACA,8D;AACA,6D;AACA,8B;AACA,+B;AACA,S;AACA,e;AACA,M;AACA,2B;AACA,K;;AAEA,mD;AACA,0D;AACA,wD;AACA,uF;;AAEA,6B;AACA,qC;AACA,mC;AACA,iC;AACA,oB;AACA,6D;AACA,qC;AACA,S;;AAEA,M;AACA,+E;AACA,yC;AACA,+E;AACA,+E;AACA,O;AACA,+C;AACA,kB;AACA,kC;AACA,iC;AACA,qD;;AAEA,yC;AACA,sD;AACA,6B;AACA,W;AACA,gD;;AAEA,S;AACA,O;AACA,K;;AAEA,M;AACA,0G;AACA,6F;AACA,0G;AACA,uB;AACA,O;AACA,+B;AACA,6C;AACA,0B;;AAEA,4B;;AAEA,wF;AACA,gG;AACA,8F;AACA,e;AACA,O;;AAEA,qC;;AAEA,+B;AACA,K;AACA,M;AACA,mG;AACA,0G;AACA,O;AACA,8B;AACA,uD;;AAEA,sC;AACA,8B;AACA,K;AACA,M;AACA,4H;AACA,O;AACA,6B;AACA,uD;;AAEA,sC;AACA,oC;;AAEA,6B;;AAEA,4B;AACA,qB;AACA,K;;AAEA,G;AACA,kE;;AAEA,yB;AACA,qB;AACA,yB;;AAEA,I;AACA,wD;AACA,K;AACA,iC;AACA,kC;AACA,wB;AACA,6B;AACA,wB;AACA,6D;AACA,6B;AACA,M;AACA,uD;AACA,uD;AACA,wB;AACA,G;;AAEA,I;AACA,gE;AACA,gF;AACA,K;AACA,oC;AACA,+D;AACA,G;;AAEA,I;AACA,4D;AACA,iD;AACA,K;AACA,4C;AACA,kC;AACA,oC;AACA,oC;;AAEA,2C;AACA,2C;AACA,iC;AACA,mF;AACA,M;;AAEA,+F;AACA,4F;;AAEA,uD;AACA,6D;AACA,6D;AACA,G;;AAEA,I;AACA,kF;AACA,yD;AACA,K;AACA,8B;AACA,yD;AACA,2C;AACA,oD;AACA,S;AACA,G;;AAEA,K;AACA,Y;AACA,a;;AAEA,+B;AACA,wD;;AAEA,E;AACA,iB;AACA,yB;AACA,wB;AACA,E;AACA,e;AACA,E;AACA,+D;AACA,qF;AACA,6E;AACA,Y;AACA,E;AACA,Q;AACA,uD;AACA,0D;AACA,qB;AACA,M;AACA,M;AACA,gG;AACA,E;AACA,uC;AACA,E;AACA,G;;AAEA,mC;AACA,4D;AACA,yJ;AACA,sC;;AAEA,K;AACA,8E;AACA,4E;AACA,+F;AACA,K;AACA,6D;AACA,2D;;AAEA,2B;AACA,0B;AACA,iB;AACA,M;;AAEA,oB;AACA,+B;AACA,2B;AACA,2B;AACA,mB;AACA,M;;AAEA,O;AACA,6D;AACA,O;AACA,iC;AACA,wD;AACA,6E;AACA,O;;AAEA,oE;AACA,oB;;AAEA,O;AACA,+E;AACA,O;AACA,sC;AACA,yD;AACA,kF;AACA,sB;AACA,K;;AAEA,O;AACA,wF;AACA,O;;AAEA,kC;AACA,+B;AACA,sB;AACA,K;;AAEA,O;AACA,6E;AACA,O;AACA,0C;AACA,oC;AACA,oD;AACA,2E;;AAEA,4C;AACA,4F;AACA,O;AACA,wD;AACA,wF;AACA,O;AACA,sC;AACA,4D;AACA,2C;AACA,uC;AACA,Q;AACA,sB;AACA,K;;AAEA,O;AACA,yF;AACA,O;AACA,mB;AACA,6D;AACA,yB;AACA,yB;AACA,qD;;AAEA,Q;AACA,2D;AACA,wE;AACA,wD;AACA,S;AACA,2B;AACA,yC;AACA,6C;AACA,gC;AACA,Q;;AAEA,oD;AACA,oE;AACA,wE;;AAEA,4C;AACA,yD;AACA,iC;AACA,S;;AAEA,0E;AACA,0E;AACA,8E;;AAEA,+E;AACA,gD;AACA,8D;AACA,wD;;AAEA,yE;AACA,wE;AACA,yD;AACA,U;AACA,mB;AACA,yB;AACA,6F;AACA,0C;AACA,a;AACA,gC;AACA,sC;AACA,wC;AACA,a;AACA,U;AACA,wF;AACA,+B;AACA,mE;AACA,S;AACA,uD;AACA,oD;AACA,wC;AACA,wB;AACA,Y;AACA,W;;AAEA,wD;AACA,mC;AACA,iF;AACA,qD;AACA,kD;AACA,8C;AACA,Y;AACA,S;;AAEA,8D;AACA,6C;AACA,gF;AACA,wF;AACA,Y;AACA,iF;AACA,mF;AACA,mF;AACA,sC;AACA,6D;AACA,kB;AACA,mC;AACA,W;;AAEA,U;AACA,S;;AAEA,2B;;AAEA,yC;AACA,iF;AACA,+C;AACA,wD;AACA,0C;AACA,kD;AACA,U;AACA,O;;AAEA,S;AACA,6E;AACA,uB;AACA,8E;AACA,4D;AACA,uE;AACA,S;AACA,mD;AACA,wB;AACA,mD;AACA,0F;AACA,O;;AAEA,K;;AAEA,G;;AAEA,iB;AACA,6F;AACA,0E;AACA,iD;AACA,6C;AACA,+E;AACA,gG;;AAEA,mD;AACA,Q;AACA,uB;AACA,wC;AACA,Q;AACA,qB;AACA,kF;AACA,Q;AACA,S;AACA,qB;AACA,kB;AACA,wB;AACA,mB;AACA,mB;AACA,sB;AACA,Q;;AAEA,Q;AACA,sB;AACA,6C;AACA,uB;AACA,Q;AACA,qB;AACA,sG;AACA,2C;AACA,Q;AACA,kD;AACA,2B;AACA,Q;AACA,S;AACA,8B;AACA,2B;AACA,mD;AACA,iC;AACA,a;AACA,gB;AACA,2D;AACA,qC;AACA,wD;AACA,mD;AACA,a;AACA,S;AACA,O;;AAEA,Q;AACA,sB;AACA,6C;AACA,uB;AACA,Q;AACA,qB;AACA,iG;AACA,Q;AACA,iE;AACA,qF;AACA,Q;AACA,S;AACA,+B;AACA,2C;AACA,0E;AACA,oD;AACA,W;AACA,O;;AAEA,Q;AACA,sB;AACA,+C;AACA,uB;AACA,Q;AACA,qB;AACA,gG;AACA,Q;AACA,0D;AACA,mF;AACA,Q;AACA,S;AACA,+B;AACA,2C;AACA,kF;AACA,iD;AACA,Y;AACA,O;;;AAGA,Q;AACA,wC;AACA,mE;AACA,S;AACA,wC;AACA,iB;AACA,uD;;AAEA,gC;AACA,kC;AACA,+B;AACA,wE;AACA,qD;AACA,2D;AACA,Y;AACA,uD;AACA,0E;AACA,8C;AACA,mE;AACA,W;AACA,oB;;AAEA,+B;AACA,+D;AACA,S;;AAEA,uB;AACA,2B;AACA,+B;AACA,4B;AACA,+B;AACA,sC;AACA,sD;AACA,yB;AACA,6B;AACA,8D;AACA,mB;AACA,iB;AACA,oB;AACA,4D;AACA,a;;AAEA,yE;AACA,+D;;AAEA,wD;;AAEA,sE;AACA,uD;AACA,iF;AACA,4D;AACA,6F;AACA,e;;AAEA,kF;AACA,gC;AACA,mD;AACA,uB;AACA,uE;AACA,yE;AACA,iB;AACA,8C;AACA,gD;AACA,yC;AACA,iB;AACA,qD;AACA,e;;AAEA,wD;AACA,wE;AACA,iC;AACA,iC;AACA,yE;AACA,wF;AACA,qC;AACA,mB;;AAEA,2C;AACA,wC;AACA,6E;AACA,iB;AACA,e;AACA,oF;AACA,Y;AACA,qC;AACA,8B;AACA,2C;AACA,sC;AACA,a;AACA,Y;AACA,8B;AACA,iC;AACA,mE;AACA,2F;AACA,mD;AACA,qE;AACA,kC;AACA,iB;AACA,e;AACA,W;AACA,U;AACA,O;AACA,M;;AAEA,M;AACA,oG;AACA,sG;AACA,mF;AACA,M;AACA,oE;AACA,6F;AACA,O;AACA,gD;AACA,wD;AACA,0E;AACA,K;AACA,G;;AAEA,C;;AAEA,K;AACA,Y;AACA,a;;AAEA,K;AACA,kB;AACA,0C;AACA,I;AACA,iB;AACA,+C;AACA,wE;AACA,K;AACA,iC;AACA,wD;;AAEA,I;AACA,a;AACA,mB;AACA,4B;AACA,4C;AACA,I;AACA,K;AACA,wC;;AAEA,a;AACA,wB;AACA,uB;;AAEA,mB;AACA,S;AACA,0E;AACA,S;AACA,uC;AACA,2D;AACA,Q;AACA,S;AACA,qD;AACA,S;AACA,gC;AACA,yB;AACA,Q;;AAEA,S;AACA,mC;AACA,8E;AACA,S;AACA,6B;AACA,8C;;AAEA,2B;AACA,sD;AACA,kC;AACA,8C;AACA,4B;AACA,W;AACA,S;AACA,oB;AACA,Q;;AAEA,S;AACA,8B;AACA,iD;AACA,iE;AACA,S;AACA,4C;AACA,2C;;AAEA,qC;AACA,iC;AACA,sB;;AAEA,0B;;AAEA,W;AACA,8C;AACA,W;AACA,+B;AACA,kD;AACA,6B;AACA,uC;AACA,W;AACA,S;;AAEA,W;AACA,yD;AACA,W;AACA,gC;AACA,qC;AACA,sB;AACA,oC;AACA,oC;AACA,W;AACA,S;AACA,Q;;AAEA,S;AACA,wD;AACA,6D;AACA,uD;AACA,S;AACA,+B;AACA,kC;AACA,oC;AACA,0C;;AAEA,4B;AACA,yC;AACA,kB;AACA,wC;AACA,W;;AAEA,kC;AACA,S;AACA,6D;AACA,O;;AAEA,M;;AAEA,+B;AACA,uC;AACA,K;;AAEA,G;AACA,6C;;AAEA,K;AACA,Y;AACA,a;;AAEA,a;AACA,e;;AAEA,K;AACA,mB;AACA,6B;AACA,0B;AACA,I;AACA,iB;AACA,6G;AACA,I;AACA,4D;AACA,gF;AACA,0G;AACA,K;;AAEA,iC;AACA,sD;;AAEA,4C;AACA,Y;AACA,oB;AACA,M;;AAEA,8C;AACA,sD;AACA,0F;AACA,M;;AAEA,yC;AACA,+C;AACA,gB;AACA,uD;AACA,0B;AACA,sB;AACA,U;AACA,c;AACA,gB;AACA,uD;AACA,6B;AACA,S;AACA,O;AACA,M;AACA,G;AACA,gD;AACA,K;;AAEA,K;AACA,Y;AACA,a;;AAEA,a;AACA,e;;AAEA,O;AACA,mB;AACA,+B;AACA,0B;AACA,I;AACA,iB;AACA,+G;AACA,I;AACA,4D;AACA,gF;AACA,0G;AACA,K;;AAEA,iC;AACA,0D;;AAEA,8C;AACA,Y;AACA,oB;AACA,M;;AAEA,8C;AACA,iE;AACA,qB;AACA,6B;AACA,uB;AACA,mB;AACA,M;AACA,G;AACA,kD;AACA,K;;AAEA,K;AACA,Y;AACA,a;;AAEA,a;AACA,e;;AAEA,K;AACA,mB;AACA,2B;AACA,0B;AACA,I;AACA,iB;AACA,2G;AACA,I;AACA,4D;AACA,gF;AACA,0G;AACA,K;;AAEA,iC;AACA,kD;;AAEA,0C;AACA,Y;AACA,oB;AACA,M;;AAEA,8C;AACA,iE;AACA,sB;AACA,4B;AACA,uB;AACA,0B;AACA,mB;AACA,M;AACA,G;AACA,8C;AACA,K;;AAEA,K;AACA,Y;AACA,a;;AAEA,+B;AACA,4C;AACA,+C;AACA,0C;AACA,0C;AACA,+C;;AAEA,uE;AACA,U;AACA,6B;AACA,2C;AACA,uD;AACA,oD;AACA,c;AACA,kD;AACA,O;AACA,K;AACA,I;AACA,C;AACA,4E;;AAEA,8C;;AAEA,U;AACA,kB;AACA,I;;AAEA,4C;AACA,2D;;AAEA,8B;AACA,4B;AACA,sB;AACA,kB;AACA,kB;AACA,oB;AACA,8B;AACA,2B;AACA,qB;AACA,uB;AACA,wB;AACA,sB;AACA,gB;;AAEA,mB;AACA,6D;AACA,oB;AACA,qB;AACA,oB;AACA,oD;AACA,yB;AACA,uB;AACA,0B;AACA,2D;AACA,kL;;AAEA,gC;AACA,kB;AACA,kC;AACA,c;AACA,qB;AACA,mC;AACA,c;AACA,K;;AAEA,wC;AACA,4B;AACA,8C;AACA,sC;AACA,K;;AAEA,2C;;AAEA,uB;AACA,iE;AACA,4B;AACA,0C;AACA,kE;AACA,S;AACA,gD;AACA,S;AACA,K;;AAEA,+C;AACA,8B;AACA,+C;AACA,uC;AACA,oC;AACA,M;;AAEA,O;AACA,wC;AACA,qE;AACA,M;AACA,0D;AACA,O;AACA,mC;AACA,yD;AACA,sC;AACA,uE;AACA,gC;AACA,oD;AACA,uB;AACA,K;;AAEA,gC;AACA,yB;AACA,0F;AACA,+D;AACA,+D;;AAEA,S;AACA,+C;AACA,Q;AACA,kE;AACA,Q;AACA,oD;AACA,S;AACA,iC;AACA,oE;AACA,+B;AACA,mC;AACA,qC;AACA,oC;AACA,wB;AACA,qB;AACA,qB;AACA,qB;AACA,S;AACA,yG;AACA,O;;AAEA,S;AACA,0C;AACA,Q;AACA,yC;AACA,Q;AACA,oD;AACA,S;AACA,iC;AACA,+D;AACA,O;;AAEA,K;;AAEA,wC;AACA,+C;AACA,iC;AACA,0D;AACA,O;AACA,4D;AACA,K;;AAEA,kC;AACA,wC;AACA,sC;AACA,+D;AACA,6D;AACA,0D;AACA,2C;AACA,wB;AACA,8C;AACA,8B;AACA,oB;AACA,qC;AACA,sC;AACA,iD;AACA,+C;AACA,a;AACA,S;AACA,yD;AACA,O;AACA,K;;AAEA,O;AACA,mD;AACA,M;AACA,2C;AACA,0C;AACA,M;AACA,8D;AACA,O;AACA,sC;;AAEA,iJ;;AAEA,2C;AACA,0C;AACA,8C;AACA,uC;AACA,wC;AACA,sC;;AAEA,wB;;AAEA,6B;;AAEA,4B;AACA,oC;AACA,oD;AACA,S;AACA,2D;AACA,8B;AACA,oB;AACA,6C;AACA,6C;AACA,2C;AACA,a;AACA,gB;AACA,gD;AACA,S;AACA,4B;AACA,8B;AACA,kC;AACA,8B;AACA,iD;AACA,mB;;AAEA,kB;;AAEA,S;AACA,yD;AACA,Q;AACA,qD;AACA,Q;AACA,gE;AACA,S;AACA,sC;AACA,+F;AACA,8B;AACA,4C;AACA,+B;AACA,6B;AACA,oB;AACA,O;;AAEA,S;AACA,kC;AACA,Q;AACA,qD;AACA,S;AACA,yC;AACA,kD;AACA,oD;AACA,mC;AACA,iC;AACA,qE;AACA,qC;AACA,8C;AACA,4B;AACA,0B;AACA,+C;AACA,+C;AACA,yE;AACA,gB;AACA,sD;AACA,kF;AACA,kC;AACA,iD;AACA,W;AACA,S;AACA,oB;AACA,O;;AAEA,S;AACA,iC;AACA,Q;AACA,mD;AACA,+C;AACA,8C;AACA,Q;AACA,iG;AACA,S;AACA,8C;AACA,gD;AACA,oB;AACA,gD;AACA,4C;AACA,iC;AACA,iC;AACA,c;;AAEA,8B;AACA,wB;AACA,yB;AACA,gB;AACA,gE;AACA,S;;AAEA,6B;AACA,qC;AACA,gB;AACA,gG;AACA,8F;AACA,S;;AAEA,mB;;AAEA,W;AACA,gE;AACA,U;AACA,qC;AACA,U;AACA,sC;AACA,W;AACA,mC;AACA,yE;AACA,S;AACA,O;AACA,K;;AAEA,O;AACA,+C;AACA,M;AACA,O;AACA,8B;AACA,qC;;AAEA,+C;AACA,oB;AACA,K;AACA,0B;AACA,qB;AACA,iD;AACA,iE;AACA,K;;AAEA,O;AACA,0C;AACA,M;AACA,qE;AACA,O;AACA,gC;AACA,mC;AACA,oD;AACA,2D;AACA,2G;AACA,kC;AACA,0E;AACA,O;AACA,K;;AAEA,G;AACA,C;AACA,mD;;AAEA,G;AACA,oE;AACA,uE;AACA,qE;AACA,E;AACA,S;AACA,qB;AACA,qB;AACA,sB;AACA,a;AACA,Y;AACA,U;AACA,E;AACA,mB;AACA,2C;AACA,a;AACA,0C;AACA,oD;AACA,kC;AACA,kC;AACA,yB;AACA,0E;AACA,U;AACA,yB;AACA,0E;AACA,U;AACA,Q;AACA,O;AACA,M;AACA,U;AACA,G;AACA,4B;AACA,qB;AACA,Y;AACA,8B;AACA,M;AACA,I;AACA,C;;AAEA,K;AACA,Y;AACA,a;;AAEA,a;AACA,e;;AAEA,O;AACA,mB;AACA,0B;AACA,0B;AACA,I;AACA,iB;AACA,2G;AACA,I;AACA,4D;AACA,gF;AACA,0G;AACA,K;;AAEA,iC;AACA,gD;;AAEA,yC;AACA,Y;AACA,oB;AACA,M;;AAEA,8C;AACA,iE;AACA,sB;AACA,4B;AACA,uB;AACA,0B;AACA,mB;AACA,M;AACA,G;AACA,6C;AACA,K;;AAEA,K;AACA,Y;AACA,a;;AAEA,mD;AACA,8B;AACA,U;AACA,oB;AACA,qB;AACA,qB;AACA,qB;AACA,qB;AACA,qB;AACA,qB;AACA,qB;AACA,qB;AACA,qB;AACA,sB;AACA,sB;AACA,sB;AACA,sB;AACA,oC;AACA,oD;AACA,6D;AACA,I;AACA,W;AACA,oB;AACA,qB;AACA,qB;AACA,qB;AACA,qB;AACA,qB;AACA,qB;AACA,qB;AACA,qB;AACA,qB;AACA,sB;AACA,sB;AACA,sB;AACA,sB;AACA,oC;AACA,oD;AACA,yD;AACA,I;AACA,a;AACA,oB;AACA,qB;AACA,qB;AACA,qB;AACA,qB;AACA,qB;AACA,qB;AACA,qB;AACA,qB;AACA,qB;AACA,sB;AACA,sB;AACA,sB;AACA,sB;AACA,oC;AACA,4C;AACA,yD;AACA,I;AACA,kB;AACA,oB;AACA,qB;AACA,qB;AACA,qB;AACA,qB;AACA,qB;AACA,qB;AACA,qB;AACA,qB;AACA,qB;AACA,sB;AACA,sB;AACA,sB;AACA,sB;AACA,oC;AACA,4C;AACA,+C;AACA,I;AACA,a;AACA,oB;AACA,qB;AACA,qB;AACA,qB;AACA,qB;AACA,qB;AACA,qB;AACA,qB;AACA,qB;AACA,qB;AACA,sB;AACA,sB;AACA,sB;AACA,sB;AACA,oC;AACA,4C;AACA,oD;AACA,I;AACA,W;AACA,oB;AACA,qB;AACA,qB;AACA,qB;AACA,qB;AACA,qB;AACA,qB;AACA,qB;AACA,qB;AACA,qB;AACA,sB;AACA,sB;AACA,sB;AACA,sB;AACA,oC;AACA,iD;AACA,6D;AACA,I;AACA,iB;AACA,oB;AACA,qB;AACA,qB;AACA,qB;AACA,qB;AACA,qB;AACA,qB;AACA,qB;AACA,qB;AACA,qB;AACA,sB;AACA,sB;AACA,sB;AACA,sB;AACA,mC;AACA,sD;AACA,uD;AACA,I;AACA,W;AACA,oB;AACA,qB;AACA,qB;AACA,qB;AACA,qB;AACA,qB;AACA,qB;AACA,qB;AACA,qB;AACA,qB;AACA,sB;AACA,sB;AACA,sB;AACA,sB;AACA,mC;AACA,iD;AACA,kD;AACA,I;AACA,W;AACA,oB;AACA,qB;AACA,qB;AACA,qB;AACA,qB;AACA,qB;AACA,qB;AACA,qB;AACA,qB;AACA,qB;AACA,sB;AACA,sB;AACA,sB;AACA,sB;AACA,mC;AACA,iD;AACA,8C;AACA,I;AACA,Y;AACA,oB;AACA,qB;AACA,qB;AACA,qB;AACA,qB;AACA,qB;AACA,qB;AACA,qB;AACA,qB;AACA,qB;AACA,sB;AACA,sB;AACA,sB;AACA,sB;AACA,mC;AACA,iD;AACA,8C;AACA,I;AACA,kB;AACA,oB;AACA,qB;AACA,qB;AACA,qB;AACA,qB;AACA,qB;AACA,qB;AACA,qB;AACA,qB;AACA,qB;AACA,sB;AACA,sB;AACA,sB;AACA,sB;AACA,mC;AACA,qC;AACA,0C;AACA,I;AACA,W;AACA,oB;AACA,qB;AACA,qB;AACA,qB;AACA,qB;AACA,qB;AACA,qB;AACA,qB;AACA,qB;AACA,qB;AACA,sB;AACA,sB;AACA,sB;AACA,sB;AACA,mC;AACA,iC;AACA,sC;AACA,I;AACA,a;AACA,oB;AACA,qB;AACA,qB;AACA,qB;AACA,qB;AACA,qB;AACA,qB;AACA,qB;AACA,qB;AACA,qB;AACA,sB;AACA,sB;AACA,sB;AACA,sB;AACA,kC;AACA,I;AACA,Y;AACA,oB;AACA,qB;AACA,qB;AACA,qB;AACA,qB;AACA,qB;AACA,qB;AACA,qB;AACA,qB;AACA,qB;AACA,sB;AACA,sB;AACA,sB;AACA,sB;AACA,kC;AACA,I;AACA,a;AACA,oB;AACA,qB;AACA,qB;AACA,qB;AACA,qB;AACA,qB;AACA,qB;AACA,qB;AACA,qB;AACA,qB;AACA,sB;AACA,sB;AACA,sB;AACA,sB;AACA,mC;AACA,qC;AACA,0C;AACA,I;AACA,kB;AACA,oB;AACA,qB;AACA,qB;AACA,qB;AACA,qB;AACA,qB;AACA,qB;AACA,qB;AACA,qB;AACA,qB;AACA,sB;AACA,sB;AACA,sB;AACA,sB;AACA,oC;AACA,yD;AACA,gE;AACA,I;AACA,Y;AACA,oB;AACA,qB;AACA,qB;AACA,qB;AACA,qB;AACA,qB;AACA,qB;AACA,qB;AACA,qB;AACA,qB;AACA,sB;AACA,sB;AACA,sB;AACA,sB;AACA,oC;AACA,uC;AACA,0C;AACA,I;AACA,W;AACA,oB;AACA,qB;AACA,qB;AACA,qB;AACA,qB;AACA,qB;AACA,qB;AACA,qB;AACA,qB;AACA,qB;AACA,sB;AACA,sB;AACA,sB;AACA,sB;AACA,sB;AACA,mC;AACA,4C;AACA,I;AACA,gB;AACA,oB;AACA,qB;AACA,qB;AACA,qB;AACA,qB;AACA,qB;AACA,qB;AACA,qB;AACA,qB;AACA,qB;AACA,sB;AACA,sB;AACA,sB;AACA,sB;AACA,oC;AACA,2C;AACA,0C;AACA,G;AACA,G;;AAEA,K;AACA,Y;AACA,a;;AAEA,0E;AACA,yC;AACA,6C;AACA,0C;AACA,uB;;AAEA,G;AACA,kB;AACA,2B;AACA,wB;AACA,E;AACA,+D;AACA,G;;AAEA,G;AACA,gB;AACA,2C;AACA,sG;AACA,G;;AAEA,G;AACA,gB;AACA,4C;AACA,wF;AACA,iF;AACA,G;;AAEA,yC;AACA,0C;AACA,E;AACA,2E;AACA,E;AACA,4D;AACA,6D;AACA,gF;AACA,6D;AACA,wG;AACA,uE;AACA,qI;AACA,0E;AACA,E;AACA,oE;AACA,E;AACA,2C;AACA,qD;AACA,4C;AACA,uC;AACA,E;AACA,G;;AAEA,0D;AACA,oB;;AAEA,kG;AACA,a;AACA,W;;AAEA,uB;AACA,e;AACA,0B;AACA,0B;AACA,0B;AACA,yB;AACA,E;AACA,wB;AACA,gB;AACA,+B;AACA,+B;AACA,+B;AACA,+B;AACA,E;;AAEA,+E;AACA,sB;;AAEA,+D;AACA,qE;AACA,uE;;AAEA,oE;AACA,mC;;AAEA,+E;AACA,0B;AACA,a;AACA,sB;AACA,oB;AACA,oB;AACA,mB;AACA,I;AACA,iB;AACA,sB;AACA,mB;AACA,mB;AACA,kB;AACA,G;AACA,E;;AAEA,yB;AACA,iB;AACA,qB;AACA,mB;AACA,mB;AACA,kB;AACA,G;AACA,E;AACA,+C;AACA,gF;AACA,4B;AACA,qB;AACA,mB;AACA,mB;AACA,mB;AACA,I;AACA,yF;AACA,uF;AACA,G;;AAEA,wB;AACA,iD;AACA,qD;AACA,E;;AAEA,2C;AACA,iB;AACA,e;;AAEA,sB;AACA,+B;AACA,+B;;AAEA,6B;AACA,4C;;AAEA,qC;;AAEA,kD;AACA,4B;AACA,iC;AACA,iC;AACA,yB;;AAEA,sC;AACA,2B;AACA,M;AACA,6C;AACA,qC;AACA,M;AACA,yB;AACA,4C;AACA,0C;AACA,wB;AACA,oB;AACA,4B;AACA,e;AACA,I;;AAEA,kF;AACA,qC;AACA,oB;AACA,kD;AACA,2B;AACA,G;;AAEA,wF;AACA,sB;AACA,4F;AACA,qC;AACA,oF;AACA,G;;AAEA,iD;AACA,yC;AACA,iE;AACA,yB;AACA,O;AACA,+B;AACA,wD;AACA,8D;AACA,4C;AACA,K;;AAEA,e;AACA,G;;AAEA,yF;AACA,gC;AACA,8C;AACA,oE;AACA,6C;AACA,0C;;AAEA,2C;;AAEA,0F;AACA,gC;;AAEA,sB;AACA,sE;AACA,mC;AACA,2B;AACA,sE;AACA,oC;AACA,8C;AACA,U;AACA,S;AACA,K;AACA,yB;;AAEA,iB;AACA,G;;AAEA,wB;AACA,oB;AACA,qB;AACA,qB;;AAEA,wB;AACA,mB;;AAEA,8B;AACA,wD;;AAEA,4B;AACA,yC;;AAEA,2B;;AAEA,gF;AACA,uE;;AAEA,2D;AACA,0E;AACA,4F;AACA,yE;AACA,gF;AACA,gF;AACA,wE;AACA,2C;AACA,oD;AACA,oB;AACA,2C;AACA,+D;AACA,yD;AACA,a;AACA,W;AACA,S;AACA,S;;AAEA,kB;AACA,K;;AAEA,mD;AACA,0F;AACA,gF;AACA,8C;AACA,4B;AACA,qD;AACA,U;;AAEA,wD;AACA,mC;AACA,sG;AACA,kC;AACA,uC;AACA,yC;AACA,iE;AACA,c;AACA,W;AACA,W;AACA,mD;AACA,iC;AACA,uC;AACA,yD;AACA,wG;AACA,sC;AACA,uC;AACA,uC;AACA,yC;AACA,yD;AACA,c;AACA,W;AACA,W;AACA,oB;AACA,Q;;AAEA,8C;AACA,yD;AACA,+F;AACA,wF;AACA,6D;AACA,Q;AACA,O;AACA,G;;AAEA,K;AACA,mB;AACA,qB;AACA,I;AACA,iB;AACA,I;AACA,2E;AACA,I;AACA,U;AACA,6D;AACA,e;AACA,uB;AACA,2C;AACA,0B;AACA,U;AACA,S;AACA,Q;AACA,Q;AACA,6C;AACA,K;AACA,iB;AACA,6C;;AAEA,+C;AACA,8C;;AAEA,qD;AACA,kG;AACA,4D;AACA,uD;AACA,wB;AACA,2C;AACA,c;AACA,0D;AACA,2B;AACA,O;;AAEA,mC;AACA,iC;AACA,+E;AACA,oE;AACA,S;AACA,+C;AACA,iE;AACA,8C;AACA,uC;AACA,O;AACA,M;;AAEA,mD;AACA,kE;AACA,uC;;AAEA,sB;;AAEA,oC;AACA,mE;AACA,wD;AACA,K;;AAEA,oC;AACA,iE;AACA,6B;AACA,mB;AACA,0B;AACA,O;AACA,gC;AACA,2B;AACA,O;AACA,iC;AACA,K;AACA,G;AACA,C;AACA,8C;;AAEA,2D;AACA,U;AACA,kB;AACA,W;AACA,uC;AACA,oB;AACA,sC;AACA,gD;AACA,iF;AACA,a;AACA,kC;AACA,W;AACA,U;AACA,4C;AACA,2D;AACA,kD;AACA,O;AACA,K;AACA,I;AACA,C;AACA,kE;;AAEA,wC;AACA,oB;AACA,C;AACA,2C;;AAEA,8C;AACA,sC;;AAEA,mD;AACA,0B;AACA,sC;;AAEA,uE;AACA,uC;AACA,mH;AACA,wG;AACA,qC;;AAEA,yF;AACA,0B;AACA,6C;AACA,uF;AACA,qC;AACA,4B;AACA,sC;AACA,c;AACA,4E;AACA,O;AACA,K;AACA,mC;AACA,8C;AACA,K;AACA,wF;AACA,K;;AAEA,2F;AACA,2D;AACA,uB;AACA,0E;AACA,4F;AACA,S;AACA,gC;AACA,8F;AACA,K;AACA,iC;AACA,K;;AAEA,wB;AACA,C;;AAEA,yE;AACA,oC;;AAEA,sD;AACA,wD;AACA,sF;;AAEA,4B;AACA,4F;;AAEA,+E;AACA,6C;;AAEA,2F;AACA,4B;;AAEA,wC;AACA,uB;AACA,sB;AACA,4C;AACA,yE;AACA,qE;;;AAGA,mF;;AAEA,4C;AACA,2B;AACA,K;;;AAGA,2F;AACA,gC;AACA,2C;AACA,0F;AACA,6D;AACA,6C;AACA,yC;AACA,O;AACA,K;;AAEA,gG;AACA,Y;AACA,mD;AACA,oC;AACA,yC;AACA,O;AACA,K;;AAEA,mC;AACA,mD;AACA,K;;AAEA,2D;AACA,4D;;AAEA,6C;AACA,qC;;;AAGA,uD;AACA,kF;AACA,uC;AACA,wD;AACA,uD;AACA,6E;AACA,iD;AACA,W;AACA,W;;;AAGA,oE;AACA,qF;AACA,2E;AACA,S;;AAEA,qC;AACA,O;AACA,O;;;AAGA,8B;AACA,uB;AACA,8B;;AAEA,2E;AACA,mG;AACA,qC;AACA,uD;AACA,wD;AACA,oE;AACA,sD;;AAEA,yD;AACA,8E;AACA,gG;AACA,2E;;AAEA,8B;AACA,wC;AACA,uC;AACA,6C;AACA,sC;;AAEA,mG;AACA,0D;AACA,kE;AACA,qC;AACA,gD;AACA,sB;AACA,qG;AACA,gD;AACA,oD;AACA,iD;AACA,O;;AAEA,0B;AACA,wB;AACA,oC;AACA,Q;AACA,mC;AACA,0C;AACA,iD;AACA,uC;AACA,kB;AACA,wF;AACA,qC;AACA,W;AACA,gB;AACA,kD;AACA,wF;AACA,qC;AACA,kB;AACA,uC;AACA,W;AACA,S;AACA,O;AACA,O;AACA,G;;;AAGA,C;AACA,uC;;AAEA,8C;AACA,sE;AACA,0D;AACA,oB;AACA,+F;AACA,8C;AACA,6C;AACA,oE;AACA,M;AACA,G;AACA,C;;AAEA,gC;AACA,0D;AACA,yB;AACA,uF;AACA,kE;AACA,O;AACA,G;AACA,mD;AACA,oD;;AAEA,2B;AACA,+B;AACA,iC;AACA,gC;AACA,kB;AACA,e;AACA,e;AACA,e;AACA,G;AACA,mE;AACA,C;;AAEA,kC;AACA,yC;;AAEA,6B;AACA,sC;AACA,wD;AACA,G;AACA,oG;AACA,wD;AACA,sC;AACA,C;;;AAGA,K;AACA,Y;AACA,a;;AAEA,G;AACA,gB;AACA,yC;AACA,G;AACA,E;AACA,iD;AACA,G;AACA,oD;AACA,kB;AACA,4B;AACA,G;;AAEA,K;AACA,Y;AACA,a;;AAEA,E;AACA,gB;AACA,qC;AACA,wB;AACA,G;;AAEA,G;AACA,mB;AACA,mB;AACA,uC;AACA,E;AACA,c;AACA,E;AACA,e;AACA,mG;AACA,0E;AACA,E;AACA,G;;AAEA,gD;AACA,iB;AACA,E;AACA,8C;;AAEA,wC;AACA,oB;AACA,C;AACA,2C;;AAEA,K;AACA,Y;AACA,a;;AAEA,G;AACA,gB;AACA,wC;AACA,e;AACA,c;AACA,G;AACA,mD;AACA,kB;AACA,gC;AACA,E;AACA,qD;AACA,qD;;AAEA,mC;AACA,U;AACA,iB;AACA,I;AACA,C;;AAEA,G;AACA,iB;AACA,uB;AACA,0C;AACA,E;AACA,e;AACA,wF;AACA,E;AACA,kB;AACA,E;AACA,gF;AACA,mE;AACA,mE;AACA,E;AACA,S;AACA,qB;AACA,qC;AACA,6C;AACA,2B;AACA,iB;AACA,S;AACA,U;AACA,mB;AACA,mD;AACA,oE;AACA,0C;AACA,4B;AACA,8D;AACA,U;AACA,O;AACA,M;AACA,U;AACA,G;;AAEA,I;AACA,gB;AACA,4B;AACA,E;AACA,e;AACA,kD;AACA,E;AACA,4E;AACA,E;AACA,8E;AACA,gF;AACA,6C;AACA,8E;AACA,qB;AACA,qI;AACA,2G;AACA,kH;AACA,sF;AACA,kF;AACA,2E;AACA,iF;AACA,U;AACA,+F;AACA,2F;AACA,uB;AACA,qF;AACA,mE;AACA,uF;AACA,sH;AACA,uH;AACA,2E;AACA,yG;AACA,oB;AACA,E;AACA,oF;AACA,2C;AACA,G;;AAEA,G;AACA,gB;AACA,4B;AACA,E;AACA,e;AACA,uE;AACA,uG;AACA,E;AACA,6D;AACA,E;AACA,G;;AAEA,G;AACA,gB;AACA,8B;AACA,E;AACA,e;AACA,sE;AACA,2B;AACA,E;AACA,6D;AACA,E;AACA,G;;AAEA,0D;AACA,iE;AACA,6B;AACA,kC;;AAEA,6J;AACA,mD;AACA,kB;AACA,uE;AACA,kC;AACA,O;;AAEA,iB;AACA,0I;AACA,iB;;AAEA,Y;AACA,qB;AACA,wB;AACA,qB;AACA,yB;AACA,0B;AACA,+B;AACA,M;;;AAGA,8C;;AAEA,yE;;AAEA,gD;AACA,6F;AACA,uC;AACA,wC;AACA,S;AACA,mD;;AAEA,qD;;AAEA,iE;AACA,wC;;AAEA,sC;AACA,gF;AACA,8D;;AAEA,wC;AACA,8D;AACA,iD;AACA,O;;AAEA,gE;AACA,0B;AACA,0C;AACA,iD;AACA,4C;AACA,kD;AACA,Y;AACA,4B;;AAEA,sC;AACA,4D;AACA,8D;AACA,gD;AACA,e;AACA,c;AACA,uE;AACA,W;AACA,W;;AAEA,K;;AAEA,gD;;AAEA,4C;;AAEA,+B;AACA,kE;AACA,0C;AACA,+D;AACA,sC;AACA,S;;AAEA,8B;;AAEA,wB;AACA,mF;AACA,S;AACA,K;;AAEA,O;AACA,qE;AACA,O;AACA,2C;AACA,kF;AACA,6C;AACA,+B;AACA,sC;;AAEA,c;AACA,yB;AACA,qC;AACA,uB;AACA,kD;AACA,oC;AACA,2C;AACA,S;AACA,Q;;AAEA,gC;AACA,iE;AACA,gE;AACA,O;;AAEA,2B;AACA,6C;AACA,4B;AACA,0E;AACA,wD;AACA,S;AACA,mG;AACA,O;;AAEA,8B;AACA,uC;AACA,+F;AACA,sF;AACA,kG;AACA,sF;AACA,0C;AACA,gB;AACA,+D;AACA,qD;AACA,S;AACA,O;AACA,K;;AAEA,G;;AAEA,C;AACA,6D;;AAEA,K;AACA,Y;AACA,a;;AAEA,G;AACA,gB;AACA,mC;AACA,e;AACA,E;AACA,S;AACA,G;AACA,O;AACA,8D;AACA,8C;;AAEA,G;AACA,mB;AACA,iB;AACA,qC;AACA,E;AACA,c;AACA,E;AACA,e;AACA,mF;AACA,E;AACA,qG;AACA,0J;AACA,qH;AACA,0B;AACA,E;AACA,sE;AACA,sE;AACA,8G;AACA,0G;AACA,yD;AACA,E;AACA,S;AACA,E;AACA,mB;AACA,E;AACA,qB;AACA,wC;AACA,+D;AACA,4D;AACA,+D;AACA,e;AACA,oD;AACA,kB;AACA,gB;AACA,U;AACA,E;AACA,e;AACA,E;AACA,qB;AACA,+C;AACA,oD;AACA,gB;AACA,qB;AACA,4D;AACA,oD;AACA,gB;AACA,iC;AACA,sE;AACA,wD;AACA,gB;AACA,U;AACA,G;AACA,+E;;AAEA,U;AACA,mB;AACA,kB;AACA,qB;AACA,0B;AACA,kB;AACA,I;;AAEA,2B;AACA,8I;AACA,G;;AAEA,uC;AACA,2B;AACA,sD;AACA,+D;AACA,G;;AAEA,2C;AACA,0B;AACA,wB;AACA,8C;;AAEA,iD;AACA,0B;AACA,4C;AACA,K;;AAEA,qE;AACA,0B;AACA,gE;AACA,0D;AACA,sD;AACA,S;AACA,K;;AAEA,kD;AACA,oC;AACA,mC;AACA,2B;AACA,qC;AACA,O;AACA,O;;AAEA,4C;AACA,8B;AACA,wC;AACA,iC;AACA,4B;AACA,oC;AACA,gB;AACA,Q;AACA,+B;AACA,2E;AACA,Q;AACA,qE;AACA,G;;AAEA,C;AACA,wF;;AAEA,K;AACA,Y;AACA,a;;AAEA,G;AACA,gB;AACA,iC;AACA,E;AACA,e;AACA,mB;AACA,G;AACA,4C;AACA,iB;AACA,E;AACA,wC;;;;AAIA,G;AACA,mB;AACA,e;AACA,mC;AACA,E;AACA,c;AACA,E;AACA,e;AACA,0F;AACA,E;AACA,qG;AACA,6F;AACA,gF;AACA,E;AACA,uG;AACA,yD;AACA,E;AACA,kG;AACA,mF;AACA,E;AACA,S;AACA,+B;AACA,qB;AACA,Y;AACA,wE;AACA,qB;AACA,4B;AACA,yB;AACA,sB;AACA,oB;AACA,iB;AACA,qB;AACA,a;AACA,U;AACA,E;AACA,uB;AACA,qB;AACA,Y;AACA,wE;AACA,qB;AACA,4B;AACA,yB;AACA,sB;AACA,mE;AACA,qC;AACA,qC;AACA,U;AACA,a;AACA,U;AACA,E;AACA,G;AACA,sC;AACA,U;AACA,kB;AACA,6C;AACA,2B;AACA,K;AACA,I;AACA,C;AACA,yC;;AAEA,K;AACA,Y;AACA,a;;AAEA,G;AACA,gB;AACA,qC;AACA,gC;AACA,G;AACA,O;AACA,4D;AACA,gD;;AAEA,G;AACA,mB;AACA,mB;AACA,uC;AACA,c;AACA,E;AACA,e;AACA,kI;AACA,E;AACA,mH;AACA,6F;AACA,0B;AACA,E;AACA,0E;AACA,wF;AACA,oG;AACA,yG;AACA,kI;AACA,mF;AACA,wE;AACA,sF;AACA,E;AACA,S;AACA,qB;AACA,4D;AACA,e;AACA,iB;AACA,E;AACA,wE;AACA,mB;AACA,iB;AACA,E;AACA,+E;AACA,a;AACA,iB;AACA,E;AACA,U;AACA,E;AACA,G;AACA,iH;AACA,qC;AACA,iC;;AAEA,U;AACA,kB;AACA,qB;AACA,wB;AACA,sC;AACA,c;AACA,yE;AACA,uC;AACA,gB;AACA,mD;AACA,oB;AACA,I;;AAEA,+D;AACA,oB;AACA,+D;;AAEA,uC;;AAEA,6B;AACA,6C;AACA,uC;;AAEA,iE;AACA,yD;AACA,0B;;AAEA,2B;AACA,qB;AACA,oD;AACA,uD;AACA,U;AACA,O;AACA,6C;AACA,mB;AACA,4B;AACA,S;AACA,oD;;AAEA,6E;AACA,6E;AACA,kB;AACA,sC;AACA,yB;AACA,a;AACA,8B;;AAEA,gC;AACA,mC;AACA,wC;AACA,qC;AACA,mC;AACA,8B;AACA,sC;AACA,kB;AACA,U;AACA,iC;AACA,6E;AACA,U;AACA,uE;;AAEA,mC;;AAEA,uD;AACA,yB;AACA,kD;AACA,iC;AACA,qD;AACA,a;AACA,a;AACA,S;AACA,O;;AAEA,oC;AACA,6C;AACA,+F;AACA,8B;AACA,kF;AACA,uB;AACA,S;AACA,O;AACA,6B;AACA,wD;;AAEA,iC;AACA,yC;AACA,kF;;AAEA,+D;AACA,gC;AACA,W;AACA,O;;AAEA,yB;AACA,oC;AACA,wC;AACA,gB;AACA,2C;AACA,S;AACA,O;AACA,M;AACA,G;AACA,C;AACA,gI;;AAEA,K;AACA,Y;AACA,a;;AAEA,G;AACA,gB;AACA,kC;AACA,G;AACA,E;AACA,0C;AACA,G;AACA,6C;AACA,kB;AACA,oC;AACA,G;;AAEA,K;AACA,Y;AACA,a;;AAEA,G;AACA,gB;AACA,oC;AACA,E;AACA,e;AACA,qB;AACA,G;AACA,+C;AACA,iB;AACA,E;AACA,8C;;AAEA,G;AACA,mB;AACA,kB;AACA,sC;AACA,E;AACA,c;AACA,E;AACA,e;AACA,oF;AACA,E;AACA,S;AACA,E;AACA,qE;AACA,E;AACA,qB;AACA,+B;AACA,sD;AACA,iB;AACA,U;AACA,E;AACA,G;;AAEA,yC;AACA,U;AACA,kB;AACA,0D;AACA,0C;AACA,4B;;AAEA,0B;AACA,oD;;AAEA,+B;AACA,K;AACA,I;;AAEA,gD;AACA,yB;AACA,6B;AACA,G;AACA,C;AACA,4C;;AAEA,6B;AACA,a;AACA,wE;AACA,6E;AACA,6E;AACA,0D;AACA,wB;AACA,wC;AACA,6D;AACA,wC;AACA,mC;;AAEA,+B;AACA,yB;AACA,0E;AACA,0B;AACA,K;AACA,K;AACA,C;;AAEA,K;AACA,Y;AACA,a;;AAEA,G;AACA,gB;AACA,mC;AACA,G;AACA,8C;AACA,kB;AACA,gC;AACA,E;AACA,2C;AACA,2C;;AAEA,+C;AACA,U;AACA,kB;AACA,0C;AACA,0B;AACA,wB;AACA,oE;AACA,qE;AACA,kD;AACA,S;AACA,S;AACA,K;AACA,I;AACA,C;AACA,oD;;AAEA,G;AACA,iB;AACA,kB;AACA,qC;AACA,E;AACA,e;AACA,gG;AACA,oF;AACA,8B;AACA,E;AACA,kB;AACA,E;AACA,iD;AACA,oE;AACA,mF;AACA,iE;AACA,mF;AACA,gE;AACA,E;AACA,Y;AACA,6E;AACA,+D;AACA,E;AACA,S;AACA,qB;AACA,6D;AACA,U;AACA,mE;AACA,wB;AACA,qB;AACA,W;AACA,U;AACA,kE;AACA,sB;AACA,qB;AACA,W;AACA,U;AACA,sF;AACA,oB;AACA,mB;AACA,W;AACA,U;AACA,gF;AACA,uB;AACA,qB;AACA,W;AACA,S;AACA,U;AACA,E;AACA,gC;AACA,mB;AACA,iC;AACA,kB;AACA,E;AACA,Y;AACA,wC;AACA,4C;AACA,E;AACA,gD;AACA,iB;AACA,oC;AACA,sC;AACA,gC;AACA,E;AACA,yB;AACA,6B;AACA,kC;AACA,8B;AACA,qE;AACA,sB;AACA,Y;AACA,E;AACA,kB;AACA,yB;AACA,gC;AACA,+B;AACA,c;AACA,Q;AACA,E;AACA,oC;AACA,wD;AACA,0B;AACA,6B;AACA,gC;AACA,qB;AACA,sD;AACA,sC;AACA,8B;AACA,+D;AACA,+C;AACA,iC;AACA,+B;AACA,wC;AACA,4C;AACA,6E;AACA,oC;AACA,kC;AACA,0B;AACA,6B;AACA,qB;AACA,iC;AACA,c;AACA,wC;AACA,Y;AACA,6D;AACA,+B;AACA,2C;AACA,8B;AACA,Y;AACA,U;AACA,Q;AACA,E;AACA,e;AACA,U;AACA,E;AACA,6D;AACA,mB;AACA,iC;AACA,kB;AACA,E;AACA,Y;AACA,yC;AACA,wD;AACA,6D;AACA,E;AACA,iF;AACA,E;AACA,iD;AACA,iB;AACA,E;AACA,oC;AACA,sC;AACA,gD;AACA,E;AACA,uD;AACA,oD;AACA,E;AACA,wD;AACA,sC;AACA,E;AACA,6B;AACA,kC;AACA,kD;AACA,qE;AACA,wB;AACA,E;AACA,kB;AACA,2B;AACA,kC;AACA,iC;AACA,gB;AACA,Q;AACA,E;AACA,8E;AACA,2E;AACA,uC;AACA,E;AACA,8B;AACA,6C;AACA,2B;AACA,Q;AACA,E;AACA,8E;AACA,E;AACA,4C;AACA,2B;AACA,iC;AACA,sB;AACA,8B;AACA,E;AACA,iF;AACA,E;AACA,6C;AACA,8E;AACA,uC;AACA,mC;AACA,2B;AACA,8B;AACA,8C;AACA,4C;AACA,kD;AACA,c;AACA,E;AACA,oD;AACA,E;AACA,iE;AACA,6D;AACA,Y;AACA,Q;AACA,E;AACA,kF;AACA,+E;AACA,yD;AACA,E;AACA,sC;AACA,E;AACA,0B;AACA,uC;AACA,E;AACA,kE;AACA,4E;;AAEA,iF;AACA,6E;AACA,qD;AACA,E;AACA,sC;AACA,gD;AACA,wD;AACA,iD;AACA,sC;AACA,E;AACA,uE;AACA,gD;AACA,kC;AACA,gB;AACA,c;AACA,a;AACA,Q;AACA,E;AACA,M;AACA,E;AACA,2F;AACA,E;AACA,+D;AACA,mE;AACA,kC;AACA,E;AACA,wC;AACA,oD;AACA,qD;AACA,0B;AACA,S;AACA,M;AACA,E;AACA,e;AACA,U;AACA,G;;AAEA,I;AACA,gB;AACA,wB;AACA,E;AACA,e;AACA,4D;AACA,E;AACA,gF;AACA,E;AACA,yD;AACA,uE;AACA,iE;AACA,iE;AACA,E;AACA,G;;AAEA,I;AACA,gB;AACA,0B;AACA,E;AACA,e;AACA,uG;AACA,6E;AACA,E;AACA,gF;AACA,E;AACA,mD;AACA,E;AACA,yD;AACA,uE;AACA,iE;AACA,uE;AACA,iE;AACA,E;AACA,G;;AAEA,G;AACA,gB;AACA,uB;AACA,E;AACA,e;AACA,4C;AACA,E;AACA,mG;AACA,mE;AACA,0F;AACA,mB;AACA,+F;AACA,+F;AACA,6F;AACA,yB;AACA,mG;AACA,0C;AACA,qG;AACA,kH;AACA,mG;AACA,oB;AACA,kG;AACA,oB;AACA,6F;AACA,+B;AACA,6F;AACA,oB;AACA,kG;AACA,6F;AACA,wB;AACA,8F;AACA,8F;AACA,mG;AACA,8F;AACA,iG;AACA,wC;AACA,kG;AACA,qE;AACA,8F;AACA,8D;AACA,uF;AACA,0F;AACA,8C;AACA,+F;AACA,gB;AACA,E;AACA,+E;AACA,sC;AACA,G;;AAEA,G;AACA,gB;AACA,uB;AACA,E;AACA,e;AACA,oF;AACA,E;AACA,6D;AACA,G;;AAEA,G;AACA,gB;AACA,yB;AACA,E;AACA,e;AACA,mF;AACA,E;AACA,6D;AACA,G;;AAEA,qD;;AAEA,mE;;AAEA,8D;AACA,sK;AACA,8C;AACA,kB;AACA,uH;AACA,mC;AACA,M;AACA,yB;AACA,gE;AACA,oC;AACA,M;AACA,2B;AACA,0E;AACA,oC;AACA,O;;AAEA,iB;AACA,yD;AACA,Y;AACA,iB;AACA,wF;AACA,8D;AACA,2D;AACA,0C;AACA,iC;AACA,qC;AACA,8D;AACA,uE;AACA,oC;AACA,2B;AACA,sE;AACA,gC;AACA,2B;AACA,mB;AACA,sB;AACA,iB;AACA,2C;AACA,gC;AACA,+B;AACA,U;AACA,iC;AACA,6B;AACA,U;AACA,Q;AACA,6B;AACA,6B;AACA,sC;AACA,M;AACA,G;;AAEA,iB;AACA,+I;AACA,Y;AACA,wB;AACA,yB;AACA,qB;AACA,yB;AACA,iC;AACA,0B;AACA,wB;AACA,wB;AACA,gC;AACA,6C;AACA,yE;AACA,O;AACA,M;;AAEA,4B;AACA,uD;;AAEA,kD;AACA,sC;AACA,uB;AACA,O;AACA,K;;AAEA,iC;AACA,8C;AACA,0E;AACA,mE;;AAEA,6E;AACA,uD;;AAEA,gF;AACA,0C;;AAEA,gC;AACA,wB;AACA,iG;AACA,uI;AACA,yD;AACA,iG;AACA,wD;AACA,6D;AACA,yD;AACA,+C;AACA,O;;AAEA,0B;AACA,uC;;AAEA,sC;AACA,6B;AACA,2D;AACA,O;;AAEA,8D;;AAEA,0D;;AAEA,wC;AACA,8D;AACA,iD;AACA,O;;AAEA,yB;AACA,gB;AACA,uB;AACA,gF;AACA,O;AACA,wB;;AAEA,2C;;AAEA,oC;AACA,0D;AACA,4D;AACA,yC;AACA,a;AACA,Y;AACA,qE;AACA,S;;AAEA,0C;AACA,6D;AACA,6E;AACA,2C;AACA,yC;AACA,a;AACA,Y;AACA,kE;AACA,S;;AAEA,kC;AACA,iC;AACA,S;AACA,S;;;AAGA,kC;AACA,qE;AACA,oE;AACA,oE;AACA,2B;AACA,gF;AACA,kE;AACA,S;AACA,4C;AACA,O;;AAEA,K;;AAEA,yC;AACA,gD;AACA,6E;;AAEA,6B;AACA,yC;AACA,O;AACA,wC;AACA,6D;AACA,oC;AACA,O;AACA,kC;AACA,oE;AACA,O;AACA,wC;AACA,iE;AACA,O;;AAEA,0C;;AAEA,6D;;AAEA,0B;AACA,gB;AACA,uB;AACA,gF;AACA,yB;AACA,yB;AACA,2D;AACA,S;;AAEA,K;;AAEA,O;AACA,8D;AACA,O;AACA,oD;;AAEA,oB;AACA,qB;AACA,wB;AACA,S;;AAEA,4D;AACA,sC;AACA,gC;AACA,O;;AAEA,2E;AACA,yC;AACA,iD;;AAEA,8B;AACA,iE;AACA,O;AACA,Y;AACA,+D;AACA,wD;AACA,uE;AACA,iC;AACA,W;AACA,O;AACA,K;AACA,O;AACA,mD;AACA,O;AACA,+C;AACA,wD;AACA,oB;AACA,O;AACA,K;AACA,O;AACA,+D;AACA,+B;AACA,M;AACA,6D;AACA,0B;AACA,O;AACA,kD;AACA,oC;;AAEA,yB;AACA,2B;;AAEA,iC;AACA,oC;AACA,0C;AACA,mB;AACA,W;AACA,qD;AACA,qD;AACA,kE;AACA,uC;AACA,4F;AACA,yD;AACA,a;AACA,W;;AAEA,gD;AACA,S;AACA,O;AACA,uB;AACA,K;;AAEA,kE;AACA,iD;;AAEA,sC;AACA,sD;;AAEA,wB;AACA,0C;AACA,8C;AACA,S;;AAEA,oD;AACA,K;;AAEA,mE;AACA,iD;;AAEA,uE;AACA,sD;;AAEA,oD;AACA,K;;AAEA,8D;AACA,yB;AACA,gE;AACA,6D;;AAEA,uE;AACA,yE;;AAEA,gE;AACA,gG;AACA,gG;AACA,mD;AACA,U;AACA,O;AACA,K;;AAEA,4C;AACA,gC;AACA,2D;AACA,6B;AACA,oE;AACA,wC;AACA,gE;AACA,6B;AACA,S;AACA,O;AACA,8B;AACA,K;;AAEA,G;AACA,C;AACA,wD;;AAEA,K;AACA,Y;AACA,a;;AAEA,G;AACA,gB;AACA,oC;AACA,+B;AACA,G;AACA,+C;AACA,iB;AACA,E;AACA,8C;;AAEA,G;AACA,mB;AACA,kB;AACA,sC;AACA,c;AACA,E;AACA,e;AACA,yM;AACA,E;AACA,qF;AACA,S;AACA,qB;AACA,4B;AACA,E;AACA,qC;AACA,U;AACA,E;AACA,G;AACA,yC;AACA,U;AACA,kB;AACA,oB;AACA,I;AACA,C;AACA,4C;;AAEA,K;AACA,Y;AACA,a;;AAEA,G;AACA,gB;AACA,qC;AACA,G;AACA,iE;AACA,kD;AACA,kD;AACA,+D;AACA,+D;AACA,oD;;AAEA,G;AACA,mB;AACA,mB;AACA,uC;AACA,c;AACA,e;AACA,gF;AACA,8D;AACA,E;AACA,6E;AACA,gF;AACA,mB;AACA,E;AACA,yE;AACA,iE;AACA,E;AACA,gJ;AACA,uG;AACA,gJ;AACA,qE;AACA,E;AACA,iE;AACA,E;AACA,gF;AACA,E;AACA,4B;AACA,E;AACA,6E;AACA,+E;AACA,sE;AACA,E;AACA,+E;AACA,uE;AACA,6E;AACA,yB;AACA,E;AACA,yD;AACA,uC;AACA,O;AACA,kE;AACA,2D;AACA,iC;AACA,yE;AACA,sC;AACA,Q;AACA,4E;AACA,oB;AACA,+E;AACA,6E;AACA,E;AACA,S;AACA,S;AACA,qB;AACA,iE;AACA,kC;AACA,kB;AACA,U;AACA,E;AACA,qB;AACA,qB;AACA,uD;AACA,kC;AACA,kB;AACA,U;AACA,E;AACA,Y;AACA,qB;AACA,4E;AACA,kC;AACA,kB;AACA,U;AACA,E;AACA,+B;AACA,qB;AACA,gB;AACA,qB;AACA,qB;AACA,qB;AACA,yB;AACA,W;AACA,kC;AACA,kB;AACA,U;AACA,G;AACA,gF;AACA,U;AACA,kB;AACA,mC;AACA,Y;AACA,qB;AACA,M;AACA,kB;AACA,I;;AAEA,kD;AACA,sB;AACA,iC;;AAEA,4D;AACA,yC;;AAEA,qE;AACA,oC;AACA,0C;;AAEA,O;AACA,sE;AACA,O;AACA,2B;AACA,gD;AACA,0C;AACA,uD;AACA,2C;AACA,O;AACA,gD;AACA,mE;AACA,K;;AAEA,6B;AACA,yC;;AAEA,qB;AACA,gD;AACA,uD;AACA,8C;AACA,O;AACA,K;;AAEA,O;AACA,2E;AACA,yB;AACA,O;AACA,4C;AACA,8B;AACA,qE;AACA,wD;AACA,gC;AACA,uC;AACA,gC;AACA,O;AACA,K;;AAEA,wB;;AAEA,O;AACA,qE;AACA,qB;AACA,M;AACA,gE;AACA,gF;AACA,6E;AACA,uB;AACA,O;AACA,+C;AACA,oC;AACA,mB;AACA,uC;AACA,mC;AACA,8B;AACA,kC;AACA,2B;AACA,Q;;AAEA,wE;AACA,e;AACA,O;;AAEA,uB;AACA,6D;AACA,kD;AACA,oB;AACA,qB;AACA,iC;AACA,6D;AACA,iE;AACA,gB;AACA,wD;AACA,wB;AACA,qD;AACA,4D;AACA,qD;AACA,mE;AACA,iB;AACA,gB;AACA,a;AACA,Y;AACA,mB;AACA,yB;;AAEA,sB;AACA,wB;AACA,iB;AACA,kC;AACA,S;AACA,S;;AAEA,8B;AACA,K;;AAEA,gF;;AAEA,iD;AACA,6C;;AAEA,iF;AACA,4B;AACA,+C;AACA,K;;AAEA,4F;AACA,iG;AACA,+F;AACA,sF;AACA,+F;AACA,uF;AACA,0G;;AAEA,+F;AACA,0F;AACA,2B;AACA,mH;;AAEA,gG;AACA,iG;AACA,gG;AACA,kC;AACA,8I;;AAEA,O;AACA,mF;AACA,2F;AACA,qF;AACA,sD;AACA,mD;AACA,4F;AACA,0B;AACA,kE;AACA,mE;AACA,8D;AACA,mF;AACA,mG;AACA,mG;AACA,8F;AACA,0E;AACA,O;AACA,4F;AACA,oE;;AAEA,4E;AACA,wC;;AAEA,+D;AACA,mD;;AAEA,0C;AACA,mF;;AAEA,kG;AACA,6D;AACA,mB;AACA,8E;AACA,2E;AACA,iB;AACA,uB;AACA,sB;AACA,gB;AACA,kB;AACA,Q;;AAEA,wB;AACA,qB;AACA,2D;AACA,0F;AACA,yF;AACA,gB;;AAEA,qB;AACA,iG;AACA,+F;AACA,0C;;AAEA,yC;AACA,yF;;AAEA,qF;AACA,2F;AACA,uF;AACA,wF;AACA,4F;AACA,gB;;AAEA,mB;AACA,mE;AACA,uD;;AAEA,2E;AACA,4C;;AAEA,yC;AACA,uF;;AAEA,oF;AACA,mF;AACA,gB;AACA,O;;AAEA,mB;AACA,K;;AAEA,2E;AACA,mB;AACA,mB;AACA,yB;AACA,Q;;AAEA,uB;AACA,qB;AACA,wF;AACA,gB;;AAEA,qB;AACA,wC;AACA,4E;AACA,4C;AACA,gD;AACA,yF;;AAEA,0F;AACA,gB;;AAEA,mB;AACA,4C;AACA,gB;AACA,O;;AAEA,mB;AACA,K;;AAEA,gC;AACA,+D;AACA,6C;AACA,S;AACA,K;;AAEA,O;AACA,iF;AACA,mD;AACA,O;AACA,yC;AACA,sD;AACA,iE;AACA,gB;AACA,wB;AACA,mF;AACA,wB;AACA,kF;AACA,U;AACA,S;AACA,K;;AAEA,+B;AACA,qF;AACA,4B;AACA,gG;AACA,O;AACA,sB;AACA,K;;AAEA,0B;AACA,wF;AACA,K;;AAEA,6B;AACA,8E;AACA,6B;AACA,qB;AACA,6C;AACA,qB;AACA,6C;AACA,iE;AACA,mB;AACA,0B;AACA,O;AACA,K;;AAEA,2B;AACA,8E;AACA,+B;AACA,qB;AACA,iD;AACA,uB;AACA,c;AACA,uB;AACA,O;AACA,K;;AAEA,oC;AACA,gD;AACA,K;AACA,G;AACA,C;AACA,yF;;AAEA,e;AACA,uC;AACA,iC;AACA,gC;AACA,4B;AACA,qC;AACA,C;AACA,0C;;AAEA,gC;AACA,+B;AACA,iC;AACA,4B;AACA,I;;AAEA,gC;AACA,iC;AACA,a;AACA,K;AACA,kC;AACA,oD;AACA,I;;AAEA,sB;AACA,S;AACA,iD;AACA,e;AACA,qC;AACA,oC;AACA,K;AACA,G;AACA,E;;;AAGA,e;AACA,qC;AACA,yC;;AAEA,K;AACA,qC;AACA,K;AACA,qD;AACA,8F;AACA,I;;AAEA,oB;;AAEA,K;AACA,4B;AACA,K;AACA,4C;AACA,wE;;AAEA,4C;AACA,2D;AACA,S;;AAEA,qB;;AAEA,W;AACA,2E;AACA,W;AACA,gC;AACA,4B;AACA,U;;AAEA,W;AACA,4E;AACA,6B;AACA,W;AACA,iC;AACA,6C;AACA,yC;AACA,mE;AACA,a;AACA,sB;AACA,U;;AAEA,W;AACA,iF;AACA,kF;AACA,qB;AACA,U;AACA,+G;AACA,W;AACA,sC;AACA,gD;AACA,yD;AACA,wD;AACA,a;AACA,sB;AACA,U;;AAEA,W;AACA,iD;AACA,W;AACA,iC;AACA,kB;AACA,wC;AACA,mC;AACA,6B;AACA,mC;AACA,wD;AACA,Y;AACA,S;AACA,Q;AACA,K;;AAEA,K;AACA,oE;AACA,mE;AACA,S;AACA,I;AACA,oB;AACA,4C;AACA,O;AACA,I;AACA,K;AACA,0C;AACA,iC;AACA,+B;AACA,6B;AACA,M;AACA,G;;AAEA,K;AACA,uC;AACA,I;AACA,oC;AACA,2E;AACA,2E;AACA,6E;AACA,6E;AACA,wE;AACA,0E;AACA,kB;AACA,I;AACA,0E;AACA,4E;AACA,qE;AACA,K;AACA,kD;AACA,mB;AACA,mB;AACA,yC;;AAEA,Y;AACA,qD;AACA,gB;AACA,uB;AACA,0C;AACA,U;AACA,S;AACA,2D;AACA,M;;AAEA,qC;AACA,iC;AACA,yE;AACA,kE;AACA,iC;AACA,O;;AAEA,oB;AACA,kB;;AAEA,sE;AACA,4E;AACA,8E;AACA,2E;AACA,2C;AACA,uC;AACA,iC;AACA,oB;AACA,mB;AACA,S;;AAEA,gD;AACA,gE;AACA,0B;AACA,oB;AACA,mB;AACA,S;;AAEA,yB;AACA,O;;AAEA,6C;AACA,iC;;AAEA,c;AACA,mB;AACA,mB;AACA,Q;AACA,K;;AAEA,wB;AACA,iB;AACA,e;AACA,+D;AACA,K;;AAEA,wC;AACA,gD;AACA,4D;AACA,O;AACA,K;;AAEA,6B;AACA,Y;AACA,qD;AACA,oC;AACA,mB;AACA,S;AACA,O;;AAEA,sC;AACA,iB;AACA,O;AACA,K;;AAEA,gC;AACA,uB;AACA,0C;AACA,wB;AACA,O;AACA,qB;AACA,K;AACA,G;AACA,C;AACA,wC;;AAEA,G;AACA,mB;AACA,mB;AACA,uC;AACA,c;AACA,e;AACA,6E;AACA,8E;AACA,6B;AACA,E;AACA,4B;AACA,E;AACA,6E;AACA,4E;AACA,4D;AACA,E;AACA,+E;AACA,uE;AACA,6E;AACA,4B;AACA,E;AACA,gF;AACA,uE;AACA,+E;AACA,qB;AACA,E;AACA,S;AACA,e;AACA,qB;AACA,iB;AACA,0B;AACA,gC;AACA,2B;AACA,kB;AACA,U;AACA,E;AACA,e;AACA,qB;AACA,iB;AACA,0B;AACA,gC;AACA,2B;AACA,kB;AACA,U;AACA,E;AACA,kC;AACA,qB;AACA,+C;AACA,kB;AACA,U;AACA,E;AACA,yB;AACA,qB;AACA,oE;AACA,kB;AACA,U;AACA,G;AACA,sC;AACA,U;AACA,kB;AACA,2B;AACA,gD;AACA,qB;AACA,c;AACA,sE;AACA,6C;AACA,2B;AACA,O;AACA,kB;AACA,I;;AAEA,sD;AACA,sB;AACA,qC;;AAEA,0D;AACA,uF;AACA,kE;;AAEA,uC;AACA,+B;AACA,sC;AACA,qB;AACA,kC;AACA,O;;AAEA,kD;AACA,+D;AACA,+C;AACA,kC;AACA,mB;AACA,W;AACA,qC;AACA,W;AACA,K;AACA,G;AACA,C;AACA,yC;;;AAGA,qC;AACA,U;AACA,wD;AACA,oB;AACA,I;AACA,C;;AAEA,K;AACA,Y;AACA,a;;AAEA,G;AACA,gB;AACA,iC;AACA,e;AACA,O;AACA,G;AACA,4C;AACA,mB;AACA,I;AACA,wC;;AAEA,G;AACA,mB;AACA,e;AACA,mC;AACA,E;AACA,c;AACA,E;AACA,e;AACA,mG;AACA,mH;AACA,wD;AACA,E;AACA,yF;AACA,gG;AACA,E;AACA,O;AACA,uC;AACA,6E;AACA,0B;AACA,Q;AACA,0H;AACA,+D;AACA,sG;AACA,8G;AACA,Q;AACA,Q;AACA,E;AACA,6C;AACA,E;AACA,O;AACA,0D;AACA,gF;AACA,Q;AACA,E;AACA,4G;AACA,yB;AACA,E;AACA,O;AACA,+C;AACA,iE;AACA,Q;AACA,E;AACA,4D;AACA,wH;AACA,6G;AACA,qF;AACA,E;AACA,+G;AACA,gH;AACA,mF;AACA,O;AACA,E;AACA,+B;AACA,2C;AACA,sH;AACA,U;AACA,E;AACA,kG;AACA,mF;AACA,qG;AACA,mF;AACA,2G;AACA,uH;AACA,mH;AACA,0G;AACA,2F;AACA,mG;AACA,8E;AACA,E;AACA,S;AACA,mB;AACA,qB;AACA,E;AACA,uG;AACA,uE;AACA,E;AACA,yD;AACA,uE;AACA,uE;AACA,E;AACA,U;AACA,E;AACA,0E;AACA,gB;AACA,E;AACA,mB;AACA,oD;AACA,kD;AACA,yC;AACA,uB;AACA,oE;AACA,gE;AACA,U;AACA,U;AACA,E;AACA,E;AACA,yC;AACA,qB;AACA,E;AACA,6D;AACA,2E;AACA,E;AACA,U;AACA,E;AACA,wC;AACA,qB;AACA,E;AACA,4D;AACA,+D;AACA,mF;AACA,E;AACA,U;AACA,E;AACA,E;AACA,G;AACA,uE;;AAEA,U;AACA,Y;AACA,gC;AACA,8B;AACA,4B;AACA,yB;AACA,M;AACA,kB;AACA,oB;AACA,0B;AACA,kB;AACA,I;;AAEA,uC;AACA,mF;AACA,mF;;AAEA,2D;AACA,mH;AACA,kF;;AAEA,iE;AACA,sH;;AAEA,iF;AACA,gC;;AAEA,uD;AACA,G;;;AAGA,K;AACA,uB;AACA,wD;AACA,K;AACA,2C;AACA,wB;;AAEA,qE;AACA,+B;;AAEA,gE;AACA,sF;;AAEA,gC;AACA,kD;AACA,yD;AACA,+C;AACA,c;AACA,6C;AACA,uD;AACA,O;AACA,K;;AAEA,mB;AACA,mE;AACA,iD;;AAEA,wB;AACA,sB;AACA,+C;AACA,gC;AACA,a;AACA,S;;AAEA,S;AACA,K;AACA,gC;AACA,oC;AACA,uD;AACA,oB;AACA,O;AACA,6E;AACA,oB;AACA,O;AACA,mB;AACA,K;AACA,G;AACA,C;AACA,+E;;AAEA,K;AACA,Y;AACA,a;;AAEA,S;AACA,wC;AACA,yC;;AAEA,K;AACA,oB;AACA,2B;AACA,sC;AACA,K;AACA,kB;AACA,uG;AACA,2G;AACA,8B;AACA,K;AACA,uF;AACA,yG;AACA,gF;AACA,uE;AACA,K;AACA,Y;AACA,sB;AACA,8C;AACA,K;AACA,4D;AACA,K;AACA,yB;AACA,+F;AACA,6F;AACA,8F;AACA,2F;AACA,W;AACA,a;AACA,K;AACA,mH;AACA,wC;AACA,K;AACA,sB;AACA,8C;AACA,K;AACA,2D;AACA,4D;AACA,K;AACA,U;AACA,6C;AACA,K;AACA,8E;AACA,0D;AACA,K;AACA,qE;AACA,K;AACA,+C;AACA,oD;AACA,a;AACA,K;AACA,W;AACA,K;AACA,a;AACA,K;AACA,sF;AACA,K;AACA,M;;AAEA,M;AACA,mB;AACA,gC;AACA,K;AACA,kB;AACA,2G;AACA,wF;AACA,K;AACA,+D;AACA,mH;AACA,sF;AACA,yG;AACA,gE;AACA,K;AACA,mG;AACA,K;AACA,Y;AACA,sB;AACA,8C;AACA,K;AACA,4D;AACA,K;AACA,yB;AACA,8F;AACA,2F;AACA,W;AACA,a;AACA,K;AACA,M;AACA,M;AACA,mB;AACA,mC;AACA,K;AACA,kB;AACA,sG;AACA,+F;AACA,4C;AACA,K;AACA,kE;AACA,mH;AACA,sF;AACA,yG;AACA,gE;AACA,K;AACA,mG;AACA,K;AACA,K;AACA,Y;AACA,sB;AACA,8C;AACA,K;AACA,4D;AACA,K;AACA,yB;AACA,qF;AACA,W;AACA,a;AACA,K;AACA,M;AACA,M;AACA,mB;AACA,0C;AACA,K;AACA,kB;AACA,+F;AACA,kF;AACA,iF;AACA,K;AACA,mH;AACA,sF;AACA,yG;AACA,gE;AACA,K;AACA,mG;AACA,K;AACA,Y;AACA,sB;AACA,8C;AACA,K;AACA,4D;AACA,K;AACA,yB;AACA,sF;AACA,W;AACA,a;AACA,K;AACA,M;AACA,M;AACA,mB;AACA,2C;AACA,K;AACA,kB;AACA,0F;AACA,6F;AACA,yC;AACA,K;AACA,wG;AACA,gE;AACA,K;AACA,mG;AACA,K;AACA,Y;AACA,sB;AACA,8C;AACA,K;AACA,4D;AACA,K;AACA,yB;AACA,uF;AACA,W;AACA,a;AACA,K;AACA,M;;AAEA,e;AACA,sB;AACA,G;;AAEA,8B;;AAEA,6B;AACA,4C;AACA,wD;;AAEA,wD;AACA,iB;AACA,K;;AAEA,kD;AACA,wD;AACA,iB;AACA,K;;AAEA,4D;AACA,8B;;AAEA,8B;AACA,+D;AACA,M;;AAEA,mE;;AAEA,iB;AACA,K;;AAEA,yD;AACA,uC;AACA,iB;AACA,K;;AAEA,4C;AACA,6B;AACA,wB;AACA,Q;AACA,8B;AACA,kC;AACA,mJ;AACA,S;AACA,Q;AACA,yB;AACA,6B;AACA,wN;AACA,S;AACA,Q;AACA,0B;AACA,8B;AACA,wS;AACA,S;AACA,Q;AACA,wB;AACA,4B;AACA,oe;AACA,S;AACA,Q;AACA,gC;AACA,oC;AACA,sL;AACA,Q;AACA,O;;AAEA,yC;AACA,+C;AACA,gD;AACA,Q;;AAEA,K;;AAEA,+F;AACA,uC;AACA,uE;AACA,K;AACA,G;;AAEA,M;AACA,uE;AACA,0D;AACA,M;AACA,8C;AACA,oB;AACA,wD;AACA,I;;AAEA,I;AACA,kB;AACA,iB;AACA,oC;AACA,G;AACA,gB;AACA,iE;AACA,G;AACA,oI;AACA,4H;AACA,kF;AACA,G;AACA,sH;AACA,gC;AACA,G;AACA,oH;AACA,G;AACA,U;AACA,oB;AACA,qC;AACA,G;AACA,wD;AACA,qE;AACA,gC;AACA,oE;AACA,G;AACA,+E;AACA,+E;AACA,G;AACA,oD;AACA,G;AACA,8D;AACA,+B;AACA,S;AACA,M;AACA,W;AACA,G;AACA,+G;AACA,qB;AACA,I;AACA,kE;AACA,sB;AACA,qG;;AAEA,mE;;AAEA,gC;AACA,mB;;AAEA,qE;AACA,gG;;AAEA,0E;AACA,6E;AACA,wD;;AAEA,wB;AACA,gC;AACA,mC;AACA,iC;AACA,gC;AACA,K;;AAEA,M;AACA,8D;AACA,M;AACA,6B;;AAEA,0C;AACA,wE;;AAEA,oC;AACA,O;AACA,I;;AAEA,M;AACA,6E;AACA,mE;AACA,K;AACA,M;AACA,0B;AACA,iC;;AAEA,yF;AACA,yC;AACA,Q;AACA,I;;AAEA,M;AACA,qE;AACA,4B;AACA,M;AACA,iC;AACA,sE;AACA,yC;;AAEA,+F;;AAEA,mC;AACA,wD;AACA,oD;AACA,oE;AACA,M;AACA,I;;AAEA,M;AACA,wD;AACA,mD;AACA,M;AACA,4B;AACA,iB;AACA,2C;AACA,iC;AACA,8E;AACA,U;AACA,I;;AAEA,M;AACA,oF;AACA,c;AACA,M;AACA,oC;AACA,a;;AAEA,gC;AACA,yC;AACA,sB;AACA,M;;AAEA,iC;AACA,I;;AAEA,M;AACA,qE;AACA,M;AACA,mC;AACA,yF;AACA,oB;;AAEA,2B;AACA,I;;AAEA,M;AACA,8D;AACA,M;AACA,4B;AACA,kF;AACA,I;;AAEA,M;AACA,4B;AACA,M;AACA,8B;AACA,+B;AACA,sF;AACA,M;;AAEA,gD;AACA,uC;AACA,8D;AACA,M;;AAEA,uB;AACA,0B;AACA,oB;AACA,I;;AAEA,M;AACA,yD;AACA,8B;AACA,M;AACA,+B;AACA,gF;AACA,0B;AACA,wB;AACA,4B;AACA,4B;AACA,kD;AACA,mG;AACA,iC;AACA,gD;AACA,kB;;AAEA,0B;AACA,qC;AACA,8B;AACA,kC;AACA,2C;AACA,kB;AACA,I;;AAEA,M;AACA,iC;AACA,M;AACA,uB;AACA,yC;AACA,I;;AAEA,E;;AAEA,K;AACA,Y;AACA,a;;AAEA,G;AACA,gB;AACA,kC;AACA,G;;AAEA,6C;AACA,iB;AACA,E;AACA,2D;AACA,qC;AACA,6C;AACA,gD;AACA,iD;AACA,kD;;AAEA,G;AACA,mB;AACA,yB;AACA,oC;AACA,E;AACA,c;AACA,E;AACA,e;AACA,yE;AACA,E;AACA,qF;AACA,sB;AACA,E;AACA,iM;AACA,oG;AACA,E;AACA,S;AACA,qB;AACA,E;AACA,uB;AACA,4B;AACA,6C;AACA,wB;AACA,E;AACA,uB;AACA,+B;AACA,sD;AACA,wB;AACA,E;AACA,U;AACA,G;AACA,wD;AACA,2D;AACA,U;AACA,kB;AACA,mB;AACA,6B;AACA,I;;AAEA,2C;AACA,wB;AACA,G;AACA,oD;AACA,oB;;AAEA,sE;;AAEA,qC;AACA,yB;AACA,M;AACA,4B;AACA,2C;AACA,4D;AACA,M;AACA,2C;AACA,6D;AACA,M;AACA,2C;AACA,4D;AACA,M;AACA,8B;AACA,sC;AACA,mC;AACA,wD;AACA,sD;AACA,O;AACA,O;AACA,G;AACA,C;AACA,6D;;AAEA,2B;AACA,U;AACA,kB;AACA,kC;AACA,yD;AACA,mD;;AAEA,oC;AACA,wC;AACA,mC;AACA,S;AACA,K;AACA,I;AACA,C;;AAEA,G;AACA,mB;AACA,gB;AACA,c;AACA,oC;AACA,E;AACA,e;AACA,kF;AACA,E;AACA,gL;AACA,0N;AACA,gJ;AACA,uK;AACA,E;AACA,S;AACA,qB;AACA,uB;AACA,yB;AACA,oE;AACA,wB;AACA,U;AACA,sF;AACA,qB;AACA,yB;AACA,yB;AACA,+B;AACA,2F;AACA,sF;AACA,2D;AACA,8D;AACA,4D;AACA,a;AACA,0B;AACA,yB;AACA,+B;AACA,wF;AACA,4E;AACA,2D;AACA,8D;AACA,a;AACA,0B;AACA,yB;AACA,kD;AACA,0B;AACA,yB;AACA,mD;AACA,0B;AACA,U;AACA,U;AACA,E;AACA,mG;AACA,E;AACA,G;;AAEA,4D;AACA,U;AACA,kB;AACA,gD;AACA,kB;AACA,I;;AAEA,kD;;AAEA,iC;AACA,wD;AACA,sD;;AAEA,iC;AACA,8B;AACA,uG;AACA,K;AACA,kC;;AAEA,8B;AACA,yE;AACA,K;;AAEA,iC;AACA,8B;AACA,uD;AACA,K;;AAEA,0D;AACA,sB;AACA,K;;AAEA,mE;AACA,0D;AACA,M;AACA,0D;;AAEA,yD;AACA,4D;;AAEA,yC;;AAEA,sB;AACA,a;AACA,mC;AACA,yC;AACA,U;AACA,kC;AACA,0C;AACA,4B;AACA,W;;AAEA,K;;AAEA,gC;AACA,4D;;AAEA,sC;AACA,sC;AACA,uC;AACA,iC;AACA,O;;AAEA,O;AACA,M;AACA,O;AACA,6C;AACA,4D;AACA,iB;AACA,K;AACA,gC;AACA,mD;AACA,6F;AACA,gG;AACA,K;;AAEA,8B;AACA,4B;AACA,+D;;AAEA,wC;AACA,2B;AACA,qB;AACA,O;;AAEA,wB;AACA,uD;AACA,gE;AACA,c;AACA,2B;AACA,O;AACA,oD;AACA,qC;AACA,8D;;AAEA,wC;AACA,iE;AACA,S;;AAEA,+B;AACA,mC;AACA,2B;AACA,iC;AACA,sD;AACA,O;;AAEA,6B;AACA,yD;AACA,yD;AACA,O;;AAEA,4B;AACA,2B;AACA,qC;AACA,yD;AACA,8C;AACA,0C;AACA,O;AACA,K;AACA,G;AACA,C;AACA,mE;;AAEA,yC;AACA,U;AACA,kB;AACA,8C;AACA,kB;AACA,I;;AAEA,kD;AACA,kB;AACA,+B;AACA,iC;AACA,uE;;AAEA,4D;AACA,kD;AACA,iC;AACA,8C;;AAEA,kD;AACA,2D;AACA,4C;AACA,6D;AACA,O;;AAEA,oD;AACA,wB;AACA,iD;AACA,2C;AACA,4D;AACA,qF;AACA,S;AACA,0B;AACA,c;AACA,oC;AACA,O;AACA,O;;AAEA,+E;AACA,0D;AACA,oB;AACA,O;AACA,oF;AACA,M;;AAEA,qC;AACA,oF;AACA,mB;AACA,K;AACA,G;AACA,C;AACA,4C;;AAEA,qC;AACA,wC;AACA,U;AACA,kB;AACA,mC;AACA,kB;AACA,kB;AACA,I;;AAEA,2D;AACA,gC;AACA,qE;AACA,8E;;AAEA,2C;AACA,sC;;AAEA,6D;AACA,4F;;AAEA,uD;AACA,kD;AACA,Y;AACA,sI;AACA,K;;AAEA,G;AACA,C;AACA,wC;;AAEA,K;AACA,Y;AACA,a;;AAEA,G;AACA,gB;AACA,iC;AACA,e;AACA,c;AACA,G;AACA,4C;AACA,iB;AACA,E;AACA,mD;AACA,uC;AACA,gD;;AAEA,G;AACA,mB;AACA,e;AACA,mC;AACA,E;AACA,c;AACA,E;AACA,e;AACA,gF;AACA,E;AACA,S;AACA,qB;AACA,Y;AACA,+D;AACA,uD;AACA,sC;AACA,gC;AACA,oC;AACA,a;AACA,oB;AACA,a;AACA,U;AACA,G;;AAEA,sC;AACA,U;AACA,kB;AACA,4B;AACA,0C;AACA,wB;AACA,K;AACA,I;AACA,C;AACA,yC;AACA,G;AACA,mB;AACA,mB;AACA,mC;AACA,E;AACA,c;AACA,E;AACA,e;AACA,mG;AACA,E;AACA,S;AACA,qB;AACA,a;AACA,oB;AACA,kC;AACA,qB;AACA,c;AACA,U;AACA,E;AACA,G;AACA,8D;AACA,kD;AACA,U;AACA,kB;AACA,mC;AACA,oC;AACA,+E;AACA,gE;AACA,4B;AACA,uB;;AAEA,8C;;AAEA,4B;AACA,4D;AACA,0D;AACA,qC;AACA,kB;AACA,W;AACA,S;AACA,gC;AACA,wB;AACA,wD;AACA,sC;AACA,S;AACA,c;AACA,yB;AACA,O;AACA,wB;;;AAGA,kC;AACA,uD;AACA,mB;;AAEA,uE;AACA,iD;AACA,qD;AACA,uC;AACA,6B;AACA,2E;AACA,a;AACA,W;AACA,S;AACA,O;;AAEA,6B;AACA,sB;AACA,4B;AACA,sF;AACA,2C;AACA,yC;AACA,gB;AACA,2H;AACA,sE;AACA,uD;AACA,4C;AACA,yE;AACA,2C;AACA,a;AACA,a;AACA,4D;AACA,S;;AAEA,8C;AACA,8B;;AAEA,sE;AACA,sD;AACA,2G;AACA,iF;AACA,oD;AACA,uD;AACA,yD;AACA,8C;AACA,2C;AACA,S;;AAEA,yD;AACA,+B;AACA,mD;AACA,+B;AACA,8C;AACA,Y;AACA,4C;AACA,oC;AACA,S;AACA,O;;AAEA,qC;AACA,qE;AACA,O;;AAEA,sB;;AAEA,wD;;AAEA,4B;AACA,uD;AACA,2E;;AAEA,yB;AACA,2B;;AAEA,oE;AACA,oD;AACA,2C;;AAEA,uC;AACA,8C;AACA,wC;AACA,kC;AACA,2C;AACA,sB;AACA,c;AACA,qC;AACA,oF;AACA,uD;AACA,mD;AACA,+C;AACA,iB;AACA,e;AACA,a;AACA,S;;AAEA,mC;AACA,6C;AACA,yE;AACA,0D;AACA,kF;AACA,oC;AACA,iB;AACA,e;AACA,W;AACA,S;AACA,qC;AACA,2C;AACA,8C;;AAEA,kG;AACA,W;AACA,S;;AAEA,2C;AACA,+D;AACA,kF;AACA,iD;AACA,0D;AACA,mC;AACA,mC;AACA,oC;AACA,e;AACA,a;AACA,a;AACA,S;;AAEA,8B;AACA,iC;;AAEA,2C;AACA,6D;AACA,gD;AACA,wD;AACA,sE;AACA,iE;AACA,iB;AACA,iB;AACA,a;AACA,a;AACA,S;AACA,O;AACA,K;AACA,I;AACA,C;AACA,qE;;AAEA,E;AACA,W;AACA,oB;AACA,yB;AACA,mC;AACA,E;AACA,G;AACA,+D;AACA,kB;AACA,mC;;AAEA,0C;AACA,qB;AACA,qD;AACA,G;AACA,C;AACA,sE;;AAEA,K;AACA,Y;AACA,a;;AAEA,G;AACA,gB;AACA,6C;AACA,yC;AACA,G;AACA,wD;AACA,iB;AACA,E;AACA,gE;;AAEA,G;AACA,mB;AACA,2B;AACA,+C;AACA,c;AACA,E;AACA,c;AACA,gG;AACA,kG;AACA,6B;AACA,E;AACA,0F;AACA,2F;AACA,E;AACA,gG;AACA,+F;AACA,2B;AACA,E;AACA,uF;AACA,2F;AACA,oC;AACA,gG;AACA,E;AACA,S;AACA,qB;AACA,kF;AACA,E;AACA,qF;AACA,E;AACA,oG;AACA,E;AACA,wE;AACA,U;AACA,G;AACA,+D;AACA,U;AACA,kB;AACA,a;AACA,6F;AACA,oG;AACA,4C;AACA,oC;AACA,0C;AACA,qC;AACA,oD;AACA,sB;AACA,sC;AACA,oD;AACA,sB;AACA,oB;AACA,iB;AACA,oB;AACA,I;;AAEA,8B;AACA,iG;AACA,4E;AACA,sC;AACA,wC;AACA,yC;;AAEA,oB;AACA,G;;AAEA,2C;AACA,wB;AACA,4B;;AAEA,+D;AACA,yC;AACA,8B;AACA,qE;;AAEA,4C;AACA,sC;AACA,kD;AACA,O;AACA,G;;AAEA,K;AACA,8C;AACA,8C;AACA,sB;AACA,K;AACA,yB;AACA,kD;AACA,G;AACA,C;AACA,oE;;AAEA,K;AACA,Y;AACA,a;;AAEA,G;AACA,gB;AACA,2C;AACA,uC;AACA,G;AACA,sD;AACA,iB;AACA,E;AACA,4D;;AAEA,G;AACA,mB;AACA,yB;AACA,6C;AACA,c;AACA,E;AACA,e;AACA,8X;AACA,E;AACA,mL;AACA,E;AACA,sN;AACA,E;AACA,sG;AACA,wI;AACA,uI;AACA,E;AACA,S;AACA,qB;AACA,8E;AACA,E;AACA,iF;AACA,E;AACA,oE;AACA,E;AACA,+F;AACA,E;AACA,4D;AACA,U;AACA,G;AACA,oE;;AAEA,U;AACA,kB;AACA,4C;AACA,uC;AACA,4C;AACA,4C;AACA,e;AACA,oB;AACA,I;AACA,E;AACA,kD;AACA,sC;AACA,wC;AACA,yC;;AAEA,oB;AACA,G;AACA,2C;AACA,wB;AACA,+D;AACA,6D;AACA,6E;;AAEA,4C;AACA,mC;AACA,e;AACA,O;;AAEA,iC;AACA,6C;AACA,iE;AACA,O;;AAEA,oD;AACA,sE;AACA,O;;AAEA,sB;AACA,qC;AACA,O;AACA,G;;AAEA,yB;AACA,sB;AACA,iB;AACA,K;;AAEA,oB;AACA,e;AACA,K;;AAEA,iC;AACA,G;AACA,C;AACA,2E;;;AAGA,6D;AACA,kB;AACA,6D;AACA,8B;AACA,8B;AACA,+B;AACA,iC;AACA,G;;AAEA,gB;;AAEA,gC;AACA,0B;AACA,mC;AACA,2F;AACA,G;AACA,K;;AAEA,K;AACA,Y;AACA,a;;AAEA,G;AACA,gB;AACA,wC;AACA,mC;AACA,G;AACA,mD;AACA,iB;AACA,E;AACA,mD;AACA,sD;;AAEA,G;AACA,mB;AACA,0C;AACA,qB;AACA,E;AACA,c;AACA,E;AACA,e;AACA,yD;AACA,uE;AACA,4B;AACA,E;AACA,mH;AACA,iG;AACA,0B;AACA,E;AACA,+E;AACA,+E;AACA,0E;AACA,iE;AACA,E;AACA,0E;AACA,6F;AACA,E;AACA,S;AACA,qB;AACA,uC;AACA,E;AACA,qB;AACA,uC;AACA,wD;AACA,E;AACA,yB;AACA,E;AACA,uB;AACA,E;AACA,oB;AACA,U;AACA,E;AACA,G;AACA,4E;AACA,qE;;AAEA,U;AACA,kB;AACA,mD;AACA,0C;AACA,iC;AACA,I;;AAEA,wD;AACA,wB;AACA,0B;AACA,wD;;AAEA,yB;AACA,8E;AACA,K;;AAEA,kC;AACA,2C;AACA,uB;AACA,6C;AACA,2C;AACA,8B;AACA,kC;AACA,qB;AACA,gB;;AAEA,8C;AACA,6C;AACA,8B;AACA,8B;AACA,qB;AACA,gB;;AAEA,wC;AACA,6E;AACA,gC;AACA,0C;AACA,W;AACA,gB;AACA,O;AACA,K;;AAEA,6B;;AAEA,8B;AACA,kB;AACA,mC;AACA,yD;AACA,c;AACA,2C;AACA,8C;AACA,uC;AACA,mC;AACA,0C;AACA,sB;AACA,c;AACA,qC;AACA,yF;AACA,c;AACA,mF;AACA,G;;AAEA,2C;AACA,oC;AACA,6B;AACA,G;;AAEA,8C;AACA,Y;AACA,mC;AACA,wC;AACA,oE;AACA,Q;AACA,+B;AACA,kD;AACA,Q;AACA,kC;AACA,iE;AACA,2B;AACA,sD;AACA,S;AACA,Q;AACA,0B;AACA,+D;AACA,qB;AACA,W;AACA,Q;AACA,gD;AACA,0D;AACA,iD;AACA,sB;AACA,Q;AACA,gC;AACA,4C;AACA,Q;AACA,8B;AACA,sD;AACA,Q;AACA,kC;AACA,uD;AACA,Q;AACA,+C;AACA,6D;AACA,O;AACA,M;AACA,G;AACA,K;AACA,mE;AACA,uD;AACA,K;AACA,oD;AACA,kF;AACA,wF;;AAEA,0B;AACA,wC;AACA,sC;AACA,yD;AACA,Q;AACA,2E;AACA,uG;AACA,+F;AACA,sD;;;AAGA,K;AACA,G;;AAEA,C;AACA,qF;;AAEA,G;AACA,mB;AACA,0C;AACA,sB;AACA,E;AACA,c;AACA,E;AACA,e;AACA,kH;AACA,E;AACA,8E;AACA,4E;AACA,0C;AACA,E;AACA,yE;AACA,6F;AACA,yC;AACA,iG;AACA,4B;AACA,uF;AACA,wF;AACA,4E;AACA,8F;AACA,E;AACA,S;AACA,qB;AACA,E;AACA,mD;AACA,Y;AACA,qB;AACA,E;AACA,gF;AACA,U;AACA,qB;AACA,E;AACA,U;AACA,E;AACA,G;AACA,+D;;AAEA,iC;;AAEA,U;AACA,kB;AACA,6B;AACA,qB;AACA,iF;AACA,8C;AACA,6C;AACA,wB;AACA,2D;AACA,c;AACA,I;;AAEA,+C;AACA,oB;;AAEA,wB;AACA,kC;;AAEA,uB;AACA,mC;;AAEA,W;AACA,4B;AACA,kC;AACA,8B;AACA,S;;AAEA,2B;AACA,sD;;AAEA,+B;AACA,uD;AACA,S;AACA,K;;AAEA,uB;AACA,0D;AACA,oC;AACA,e;AACA,O;AACA,4B;AACA,4C;AACA,oB;AACA,sC;AACA,uD;AACA,c;AACA,yC;AACA,O;AACA,K;AACA,O;AACA,wE;AACA,O;AACA,6C;AACA,mC;;AAEA,oB;AACA,6B;AACA,yB;AACA,gC;AACA,S;;AAEA,oD;;AAEA,S;AACA,8F;AACA,mD;AACA,4B;AACA,S;AACA,8B;AACA,gE;AACA,O;AACA,K;AACA,G;AACA,C;AACA,sE;;AAEA,K;AACA,Y;AACA,a;;AAEA,G;AACA,gB;AACA,mC;AACA,G;;AAEA,oD;;AAEA,Y;AACA,2B;;AAEA,2C;AACA,4E;AACA,yB;AACA,6B;;AAEA,uB;AACA,sE;;AAEA,oD;;AAEA,2B;AACA,qB;;AAEA,8C;AACA,kB;AACA,gC;AACA,E;AACA,uC;AACA,+C;AACA,uC;AACA,2C;AACA,uC;;;AAGA,G;AACA,mB;AACA,iB;AACA,c;AACA,qC;AACA,E;AACA,4D;AACA,E;AACA,0C;AACA,oD;AACA,sD;AACA,oG;AACA,6B;AACA,E;AACA,S;AACA,kE;AACA,qB;AACA,e;AACA,2B;AACA,oC;AACA,wF;AACA,iB;AACA,U;AACA,E;AACA,yB;AACA,qB;AACA,e;AACA,4B;AACA,wD;AACA,wF;AACA,iB;AACA,U;AACA,G;AACA,mG;AACA,U;AACA,kB;AACA,+C;AACA,qB;AACA,wF;AACA,I;;AAEA,mC;AACA,qF;AACA,2D;;AAEA,iD;AACA,0B;AACA,oF;AACA,Y;AACA,0C;AACA,oD;AACA,+C;AACA,oC;AACA,O;AACA,K;AACA,8E;AACA,wC;AACA,yC;AACA,8D;AACA,K;;AAEA,gF;AACA,6C;AACA,mF;AACA,K;;AAEA,kD;AACA,wB;AACA,yC;AACA,iD;AACA,gD;AACA,qD;AACA,6B;AACA,wB;AACA,Q;AACA,K;;AAEA,oB;AACA,iF;AACA,0B;AACA,gC;AACA,iC;AACA,8B;AACA,wB;AACA,S;AACA,2C;AACA,0C;AACA,6E;AACA,6F;AACA,yF;AACA,oC;AACA,S;;AAEA,6C;AACA,K;;AAEA,uF;AACA,mE;AACA,4B;AACA,oE;AACA,0B;AACA,kC;;AAEA,oC;;AAEA,yC;;AAEA,2D;AACA,iB;AACA,qB;;AAEA,kC;AACA,6B;AACA,8B;;AAEA,oD;AACA,oD;AACA,uD;AACA,qB;;AAEA,0B;;AAEA,kC;AACA,6F;AACA,wE;AACA,O;;AAEA,2C;AACA,oC;AACA,yB;AACA,wB;AACA,Q;;AAEA,kD;AACA,gF;AACA,6C;AACA,8C;AACA,sE;AACA,0B;AACA,Q;;AAEA,qD;AACA,yF;AACA,Q;;AAEA,qC;AACA,uB;AACA,wB;AACA,S;;AAEA,+B;AACA,oD;AACA,yB;AACA,6D;AACA,S;AACA,yD;AACA,O;;AAEA,gC;AACA,8B;AACA,+G;AACA,qE;AACA,S;AACA,O;;AAEA,4B;AACA,iD;AACA,mD;AACA,iC;AACA,4G;AACA,wG;AACA,yB;AACA,iD;AACA,kB;AACA,2C;AACA,W;AACA,gC;AACA,iD;AACA,6C;AACA,0C;AACA,+B;AACA,8B;AACA,c;AACA,8C;AACA,8B;AACA,W;AACA,W;AACA,S;;AAEA,oD;AACA,0C;AACA,0B;AACA,S;AACA,qD;AACA,kE;AACA,iB;AACA,S;AACA,8B;AACA,uB;AACA,kE;AACA,2C;AACA,iD;AACA,gB;AACA,8E;AACA,0C;AACA,gD;AACA,S;AACA,S;AACA,+C;AACA,4E;AACA,wC;AACA,8C;AACA,O;;AAEA,uB;AACA,yB;AACA,gC;AACA,Q;AACA,2C;AACA,qD;AACA,O;AACA,8B;;AAEA,wC;AACA,qB;AACA,8C;AACA,qC;AACA,a;AACA,gB;AACA,mC;AACA,S;AACA,S;;;AAGA,yD;AACA,+B;AACA,0D;AACA,8D;AACA,qD;AACA,2D;AACA,mC;AACA,iE;AACA,2F;AACA,O;;AAEA,kC;AACA,4C;AACA,qD;AACA,kD;AACA,6B;AACA,wB;AACA,gB;AACA,mD;AACA,+B;AACA,kE;AACA,8B;AACA,0E;AACA,6C;AACA,iF;AACA,a;AACA,wE;AACA,8C;AACA,8B;AACA,W;AACA,S;AACA,O;;AAEA,6B;AACA,qC;AACA,wB;AACA,0B;AACA,+B;AACA,gC;AACA,8B;AACA,qC;AACA,+B;AACA,8B;AACA,qF;AACA,0C;AACA,2B;AACA,a;AACA,W;AACA,O;AACA,M;AACA,G;AACA,C;AACA,kH;;AAEA,2D;;AAEA,kE;AACA,U;AACA,kB;AACA,0C;AACA,qC;AACA,0B;AACA,I;;AAEA,uF;AACA,oC;AACA,iD;AACA,8B;AACA,2B;;AAEA,wB;AACA,uC;AACA,wC;AACA,0C;AACA,oB;;AAEA,8B;AACA,oB;AACA,iD;AACA,0B;AACA,0E;AACA,S;AACA,K;;AAEA,6B;AACA,+C;AACA,yB;AACA,O;AACA,K;;AAEA,gC;AACA,8D;AACA,qF;AACA,yC;;AAEA,kE;AACA,6E;;AAEA,+B;AACA,oC;AACA,2B;AACA,+C;AACA,kB;AACA,+D;AACA,W;AACA,gB;AACA,4B;AACA,uE;AACA,iE;AACA,W;AACA,S;AACA,sC;AACA,S;AACA,K;AACA,G;;;;AAIA,2D;AACA,oB;AACA,yD;AACA,0F;AACA,uB;AACA,yE;AACA,qD;AACA,sB;;AAEA,mE;AACA,6B;AACA,a;;AAEA,kC;AACA,6C;AACA,iC;AACA,mC;AACA,iE;;AAEA,4B;AACA,2D;AACA,yC;;AAEA,2F;AACA,uF;AACA,iE;AACA,0D;AACA,W;AACA,c;AACA,kD;AACA,yC;AACA,O;;AAEA,qD;AACA,4D;AACA,wE;AACA,8D;AACA,O;AACA,M;;AAEA,uB;AACA,8C;AACA,iC;AACA,iD;AACA,6D;AACA,kD;AACA,uC;AACA,uB;AACA,4B;AACA,6B;AACA,6B;AACA,kD;AACA,oD;AACA,sB;AACA,8C;AACA,6C;AACA,mD;AACA,6C;AACA,W;AACA,O;AACA,gD;AACA,sC;AACA,6B;AACA,S;AACA,O;AACA,M;;;AAGA,mC;AACA,6B;;AAEA,0F;AACA,uF;AACA,yD;AACA,+B;AACA,6D;AACA,uD;AACA,uC;AACA,oE;AACA,U;AACA,yF;AACA,wB;AACA,c;AACA,wD;AACA,wC;AACA,6F;AACA,W;AACA,uB;AACA,U;AACA,O;AACA,wC;AACA,M;;AAEA,sC;AACA,gG;AACA,qC;AACA,yF;AACA,c;AACA,kB;AACA,O;AACA,M;;AAEA,kD;AACA,yC;AACA,yC;AACA,2C;AACA,M;AACA,uC;AACA,yC;AACA,0C;AACA,oC;AACA,M;;AAEA,oD;AACA,qD;AACA,oF;AACA,6E;AACA,O;AACA,yC;;AAEA,mF;AACA,sD;AACA,+C;AACA,gC;AACA,O;AACA,M;AACA,2C;AACA,mC;AACA,0F;AACA,uE;AACA,M;;AAEA,wC;AACA,sB;AACA,iB;AACA,0C;AACA,4F;AACA,gD;AACA,qC;AACA,iB;AACA,kF;AACA,kF;AACA,wC;AACA,yF;AACA,mC;AACA,+C;AACA,U;AACA,O;AACA,uE;AACA,M;;AAEA,+B;AACA,kF;AACA,sD;;AAEA,mD;;AAEA,qE;AACA,0D;AACA,sD;AACA,S;;AAEA,wC;AACA,sD;AACA,mD;AACA,S;AACA,K;AACA,+B;AACA,sE;AACA,wD;AACA,mD;AACA,K;AACA,G;;AAEA,C;AACA,kE;;AAEA,uD;;AAEA,0C;AACA,U;AACA,kB;AACA,4C;AACA,iC;AACA,oB;AACA,I;;AAEA,mC;AACA,uF;AACA,0F;;AAEA,mD;AACA,oB;AACA,G;;AAEA,kD;AACA,8B;AACA,8B;;AAEA,0C;AACA,iD;AACA,+C;AACA,iC;AACA,Y;AACA,0E;AACA,K;;AAEA,mC;AACA,oD;AACA,iD;AACA,uB;AACA,uC;AACA,uE;AACA,W;AACA,kE;AACA,gB;AACA,kD;AACA,S;AACA,sC;AACA,qC;AACA,S;AACA,O;;AAEA,8C;AACA,oB;;AAEA,iD;AACA,8D;AACA,8D;;AAEA,sC;AACA,kC;;AAEA,sD;AACA,mD;AACA,K;;AAEA,sC;AACA,8D;AACA,O;;AAEA,8B;AACA,uB;AACA,yB;AACA,gC;AACA,Q;;AAEA,2C;AACA,4D;AACA,O;AACA,8B;AACA,K;AACA,G;;AAEA,uC;AACA,0B;AACA,6C;AACA,yC;AACA,uB;AACA,iC;AACA,iC;AACA,W;AACA,gD;AACA,wC;AACA,gD;AACA,O;AACA,iC;AACA,M;AACA,G;;AAEA,C;AACA,4D;;AAEA,8B;AACA,U;AACA,kB;AACA,oB;AACA,I;AACA,+B;AACA,wC;AACA,+B;AACA,gD;AACA,+B;AACA,K;AACA,oD;AACA,G;AACA,C;;AAEA,mD;AACA,uH;AACA,8C;AACA,kB;AACA,0B;AACA,mC;AACA,O;;AAEA,iB;AACA,yG;AACA,Y;AACA,qB;AACA,qB;AACA,yB;AACA,wB;AACA,gC;AACA,oB;AACA,M;;AAEA,2C;AACA,yB;AACA,iG;AACA,kD;AACA,O;;AAEA,4B;AACA,yB;AACA,mF;AACA,6C;AACA,iD;AACA,8C;AACA,kH;AACA,S;;AAEA,kC;AACA,0B;AACA,4B;AACA,gD;AACA,a;AACA,W;AACA,Q;;AAEA,2D;AACA,sE;;;AAGA,sB;;AAEA,sC;;AAEA,2E;;AAEA,wD;AACA,2C;AACA,0C;AACA,4E;AACA,4B;AACA,8B;AACA,gF;AACA,yC;AACA,kD;AACA,e;AACA,a;AACA,W;AACA,qC;AACA,wC;AACA,O;;AAEA,sF;AACA,sE;AACA,c;AACA,yC;AACA,O;AACA,+F;AACA,qC;AACA,+C;;AAEA,0B;AACA,uD;AACA,0C;AACA,O;AACA,kC;;AAEA,4D;AACA,iD;AACA,wB;AACA,0B;AACA,qC;AACA,8C;AACA,W;AACA,S;;AAEA,yE;;AAEA,gC;AACA,kD;AACA,O;;AAEA,sC;AACA,mC;AACA,wE;AACA,yC;;AAEA,gE;AACA,6B;AACA,8B;AACA,oC;AACA,yC;AACA,W;;AAEA,0B;AACA,kD;AACA,+B;AACA,4C;AACA,4C;AACA,sE;AACA,2B;AACA,8C;AACA,gC;AACA,gC;AACA,mB;AACA,oC;AACA,e;AACA,oB;AACA,0C;AACA,6C;AACA,kC;AACA,uC;AACA,6C;AACA,W;AACA,W;;AAEA,mD;AACA,kD;AACA,+B;AACA,yE;AACA,2E;AACA,oB;AACA,yD;AACA,oG;AACA,2C;AACA,e;AACA,W;AACA,W;;;AAGA,yC;AACA,uD;AACA,6D;AACA,6B;AACA,4E;AACA,sB;AACA,+E;AACA,oB;AACA,yD;AACA,oB;AACA,W;AACA,iE;AACA,yC;AACA,S;AACA,oC;AACA,8B;AACA,S;AACA,oC;AACA,8B;AACA,S;;AAEA,kD;AACA,iD;AACA,mD;AACA,6B;AACA,W;AACA,W;;AAEA,mC;AACA,uC;AACA,qC;AACA,yC;AACA,4D;AACA,e;AACA,W;AACA,S;AACA,O;;AAEA,K;;AAEA,6C;AACA,4B;AACA,kC;AACA,qC;AACA,iD;;;AAGA,4D;AACA,uE;AACA,gC;;AAEA,0D;AACA,qB;AACA,yF;AACA,O;;AAEA,sF;AACA,yC;AACA,gD;AACA,uD;AACA,wF;AACA,S;AACA,uC;AACA,+B;AACA,S;AACA,mD;AACA,S;AACA,K;;AAEA,kD;AACA,qC;AACA,6H;AACA,sC;AACA,wC;AACA,0C;AACA,0D;AACA,0D;AACA,yC;AACA,oB;AACA,uD;AACA,oC;AACA,2D;AACA,kG;AACA,Y;AACA,4B;AACA,6C;AACA,gD;AACA,uE;AACA,wE;AACA,Y;AACA,+D;AACA,6E;AACA,yE;AACA,qE;AACA,yE;;;AAGA,uB;AACA,+C;AACA,yB;AACA,oC;AACA,yE;AACA,wC;AACA,wC;AACA,sD;AACA,qC;AACA,sC;AACA,+F;AACA,c;AACA,oE;AACA,O;;AAEA,+C;AACA,yD;AACA,O;AACA,mC;AACA,iE;AACA,O;;AAEA,kE;AACA,yB;AACA,gD;AACA,O;;AAEA,uE;AACA,8D;AACA,qD;;AAEA,yB;AACA,mE;AACA,gF;AACA,kF;AACA,O;;AAEA,qC;AACA,wE;AACA,qF;AACA,O;;AAEA,yB;AACA,wD;AACA,0F;;AAEA,gD;AACA,2C;AACA,6B;AACA,qE;AACA,Y;AACA,0D;AACA,2C;AACA,2E;AACA,wE;AACA,Y;AACA,S;AACA,O;;AAEA,qC;AACA,mC;AACA,+B;AACA,iD;AACA,kC;AACA,0D;AACA,uD;AACA,uC;AACA,S;AACA,c;AACA,8E;AACA,2F;AACA,oD;;;AAGA,8E;AACA,wF;;AAEA,oF;AACA,2C;AACA,O;;AAEA,4C;AACA,gE;AACA,qG;AACA,oG;AACA,2E;;AAEA,8D;AACA,sE;AACA,kE;AACA,U;;;AAGA,wB;AACA,sC;AACA,yD;AACA,0B;AACA,yC;AACA,8B;AACA,S;AACA,S;AACA,K;;AAEA,G;;AAEA,+B;AACA,2C;AACA,G;;AAEA,gC;AACA,mB;AACA,4B;AACA,0B;AACA,8B;AACA,+B;AACA,iD;AACA,G;AACA,C;AACA,sD;;AAEA,0D;AACA,8B;AACA,mB;AACA,0C;AACA,gC;AACA,G;AACA,iB;AACA,C;;AAEA,K;AACA,Y;AACA,a;;AAEA,G;AACA,gB;AACA,oC;AACA,E;AACA,e;AACA,0B;AACA,G;AACA,+C;AACA,oB;AACA,kC;AACA,I;AACA,yC;AACA,2C;AACA,qD;AACA,yD;;;AAGA,G;AACA,W;AACA,iB;AACA,mB;AACA,sC;AACA,E;AACA,e;AACA,gE;AACA,a;AACA,E;AACA,S;AACA,mB;AACA,oF;AACA,oD;AACA,gD;AACA,M;AACA,qC;AACA,iE;AACA,0B;AACA,e;AACA,uB;AACA,8B;AACA,S;AACA,kC;AACA,0B;AACA,a;AACA,uB;AACA,6B;AACA,S;AACA,mC;AACA,0B;AACA,c;AACA,uB;AACA,6B;AACA,S;AACA,kE;AACA,oC;AACA,wD;AACA,qE;AACA,0C;AACA,U;AACA,G;AACA,mD;AACA,2B;;AAEA,uE;AACA,a;AACA,gE;AACA,oD;;AAEA,mB;AACA,iD;AACA,K;;AAEA,mB;AACA,0B;AACA,qB;AACA,0B;AACA,0B;AACA,6C;AACA,Q;AACA,gC;AACA,mD;AACA,Q;AACA,0B;AACA,sB;AACA,0B;AACA,0B;AACA,kE;AACA,Q;AACA,wB;AACA,gE;AACA,Q;AACA,yB;AACA,iE;AACA,Q;AACA,qC;AACA,uE;AACA,0D;AACA,O;AACA,M;;AAEA,O;AACA,sE;AACA,O;AACA,gC;AACA,iC;AACA,6B;AACA,qC;AACA,gC;AACA,4B;AACA,mB;AACA,K;AACA,I;AACA,C;AACA,wD;AACA,G;AACA,mB;AACA,uB;AACA,sC;AACA,E;AACA,c;AACA,E;AACA,e;AACA,wF;AACA,4E;AACA,E;AACA,S;AACA,qB;AACA,e;AACA,W;AACA,2B;AACA,6C;AACA,4D;AACA,4B;AACA,Y;AACA,gB;AACA,U;AACA,I;AACA,kC;AACA,U;AACA,kB;AACA,0B;AACA,uD;AACA,wC;AACA,K;AACA,I;AACA,C;AACA,G;AACA,mB;AACA,kB;AACA,sC;AACA,c;AACA,E;AACA,e;AACA,E;AACA,qE;AACA,E;AACA,8E;AACA,E;AACA,iG;AACA,oG;AACA,E;AACA,S;AACA,qB;AACA,kD;AACA,gE;AACA,gB;AACA,kB;AACA,E;AACA,iB;AACA,qB;AACA,4C;AACA,uB;AACA,mB;AACA,kB;AACA,E;AACA,wC;AACA,uD;AACA,gC;AACA,a;AACA,6B;AACA,oD;AACA,4C;AACA,mD;AACA,8B;AACA,c;AACA,kB;AACA,S;AACA,U;AACA,E;AACA,mB;AACA,qD;AACA,gE;AACA,uC;AACA,mC;AACA,O;AACA,M;AACA,U;AACA,E;AACA,kF;AACA,+E;AACA,gF;AACA,qE;AACA,gE;AACA,E;AACA,2E;AACA,kG;AACA,Y;AACA,E;AACA,qE;AACA,oF;AACA,mG;AACA,G;AACA,yH;AACA,U;AACA,kB;AACA,Y;AACA,0B;AACA,M;AACA,uC;AACA,gC;AACA,oC;AACA,qC;AACA,sB;AACA,K;AACA,I;;AAEA,K;AACA,oC;AACA,K;AACA,wD;AACA,2B;AACA,iC;AACA,gC;;AAEA,yD;AACA,+B;AACA,gD;AACA,+B;AACA,sF;AACA,+B;AACA,U;AACA,0B;AACA,S;AACA,M;AACA,4B;AACA,oE;AACA,a;;AAEA,gD;AACA,0C;;AAEA,2C;AACA,yC;;;AAGA,2D;AACA,yC;AACA,sE;;AAEA,O;AACA,kD;AACA,sB;AACA,O;AACA,iD;AACA,oC;AACA,kC;AACA,0D;AACA,c;AACA,mF;AACA,O;AACA,yD;AACA,K;;AAEA,O;AACA,0D;AACA,oB;AACA,O;AACA,mC;AACA,oC;;AAEA,0D;AACA,sD;;AAEA,qB;AACA,iC;AACA,uD;AACA,O;AACA,+C;;AAEA,kC;;AAEA,+B;AACA,qF;AACA,mF;AACA,gB;AACA,gC;AACA,gE;AACA,mC;AACA,6C;AACA,iB;AACA,iB;AACA,K;;AAEA,O;AACA,0D;AACA,O;AACA,4C;AACA,oC;AACA,uB;AACA,oD;AACA,yC;AACA,yD;AACA,mD;AACA,uC;AACA,O;AACA,K;;AAEA,O;AACA,wE;AACA,mC;AACA,M;AACA,oB;AACA,mB;AACA,O;AACA,mC;AACA,oC;;AAEA,6B;;AAEA,c;AACA,kC;;AAEA,iE;AACA,8B;;AAEA,6B;;AAEA,iE;AACA,yC;;AAEA,kC;AACA,6E;AACA,6D;AACA,uC;AACA,a;;AAEA,qC;AACA,a;;AAEA,mB;;AAEA,gC;AACA,O;AACA,K;;AAEA,O;AACA,2D;AACA,iB;AACA,O;AACA,4B;AACA,kE;AACA,kD;AACA,K;;AAEA,O;AACA,gE;AACA,mE;AACA,8C;AACA,O;AACA,wB;AACA,0B;AACA,2B;;AAEA,iC;AACA,K;;AAEA,G;AACA,C;AACA,8I;;AAEA,E;AACA,W;AACA,oB;AACA,0B;AACA,sC;AACA,E;AACA,G;AACA,gF;;AAEA,kB;AACA,mB;;AAEA,uE;;AAEA,wB;AACA,uD;AACA,mE;;AAEA,kB;AACA,iE;AACA,iE;AACA,2E;AACA,oC;AACA,kC;AACA,wB;AACA,K;AACA,wB;AACA,I;;AAEA,mE;;AAEA,2E;AACA,C;AACA,2F;;AAEA,K;AACA,Y;AACA,a;;AAEA,K;AACA,kB;AACA,qC;AACA,K;AACA,gD;AACA,mB;AACA,I;AACA,0C;;AAEA,G;AACA,mB;AACA,iB;AACA,qC;AACA,c;AACA,e;AACA,wE;AACA,U;AACA,E;AACA,mH;AACA,2F;AACA,0B;AACA,E;AACA,8E;AACA,2E;AACA,iB;AACA,E;AACA,wE;AACA,8D;AACA,sC;AACA,E;AACA,S;AACA,uB;AACA,qB;AACA,mD;AACA,e;AACA,U;AACA,yB;AACA,qB;AACA,kF;AACA,e;AACA,U;AACA,E;AACA,iE;AACA,4F;AACA,iF;AACA,mF;AACA,G;AACA,yG;AACA,U;AACA,c;AACA,wB;AACA,a;AACA,uC;AACA,yC;AACA,uC;AACA,qD;AACA,6C;AACA,e;AACA,yC;AACA,uC;AACA,6C;AACA,4C;AACA,gC;AACA,gD;AACA,iB;AACA,gD;AACA,e;AACA,c;AACA,oB;AACA,I;;AAEA,+D;AACA,oB;AACA,+D;;AAEA,uC;AACA,mB;AACA,kB;AACA,oB;AACA,O;;AAEA,2C;;AAEA,oB;AACA,G;;AAEA,wD;AACA,wB;AACA,kC;AACA,8D;AACA,yC;AACA,oC;AACA,8B;AACA,kE;AACA,Q;AACA,mB;AACA,sB;AACA,8B;AACA,M;;AAEA,sE;AACA,6C;AACA,8D;AACA,mB;AACA,uE;AACA,gF;AACA,wC;AACA,0F;AACA,kF;AACA,qF;AACA,qF;;AAEA,2C;AACA,8D;AACA,gE;AACA,kE;;AAEA,0E;AACA,qE;AACA,kC;AACA,yC;AACA,0B;AACA,oF;AACA,K;;AAEA,yC;;AAEA,W;AACA,qC;AACA,uC;AACA,mC;AACA,uC;AACA,6B;AACA,oC;;AAEA,mE;AACA,0B;AACA,gC;AACA,sB;AACA,oB;AACA,K;AACA,0B;;AAEA,uD;AACA,8D;;AAEA,sC;AACA,iE;AACA,0B;AACA,O;;AAEA,wC;AACA,yD;AACA,kD;AACA,gD;;AAEA,O;AACA,iB;AACA,O;AACA,Y;AACA,Y;AACA,a;AACA,+B;AACA,8B;AACA,2C;AACA,kB;AACA,K;AACA,+B;AACA,8B;AACA,2C;AACA,kB;AACA,K;AACA,gC;AACA,+B;AACA,oB;AACA,K;AACA,6C;AACA,kD;AACA,K;;AAEA,kC;AACA,yF;AACA,2D;AACA,4B;AACA,4B;AACA,sD;;AAEA,sD;AACA,wB;AACA,yE;AACA,4E;AACA,iD;AACA,uE;AACA,yC;AACA,O;AACA,6C;AACA,6C;AACA,+C;;AAEA,mB;AACA,2C;AACA,iE;AACA,gE;AACA,O;AACA,K;;;AAGA,O;AACA,4B;AACA,O;AACA,8B;AACA,8B;AACA,wC;AACA,mE;AACA,K;AACA,oC;AACA,mC;AACA,8B;AACA,K;;AAEA,O;AACA,gC;AACA,O;AACA,kC;AACA,+C;AACA,e;AACA,O;;AAEA,uB;AACA,2D;AACA,6B;AACA,mE;AACA,4B;AACA,O;AACA,yB;AACA,oD;AACA,4B;AACA,S;AACA,4B;AACA,6B;AACA,qC;AACA,+D;AACA,W;AACA,O;AACA,K;;AAEA,O;AACA,qC;AACA,O;AACA,mC;AACA,yE;AACA,K;AACA,8B;AACA,0C;AACA,yD;AACA,O;;AAEA,iE;AACA,gD;AACA,4D;AACA,gC;AACA,+C;AACA,K;;AAEA,qC;AACA,oC;AACA,mD;AACA,O;AACA,K;AACA,mC;AACA,oC;AACA,+C;AACA,O;AACA,K;;AAEA,O;AACA,yB;AACA,O;AACA,wC;AACA,sD;AACA,yB;AACA,e;AACA,6B;AACA,Q;AACA,mD;AACA,K;;;AAGA,O;AACA,sB;AACA,O;AACA,2B;AACA,wD;;AAEA,8B;AACA,qC;;AAEA,iC;AACA,yB;AACA,gC;;AAEA,wE;AACA,kE;AACA,+B;AACA,oC;AACA,sD;AACA,S;AACA,K;AACA,4B;AACA,qC;;AAEA,6C;;AAEA,wE;AACA,kE;AACA,+B;AACA,kC;AACA,wB;AACA,S;AACA,K;AACA,8B;AACA,qC;AACA,wB;AACA,2B;;AAEA,mC;AACA,6B;AACA,K;AACA,yB;AACA,8B;AACA,2B;AACA,6B;AACA,K;AACA,4B;AACA,8B;AACA,2B;AACA,yB;AACA,K;;AAEA,qC;AACA,gD;AACA,oD;AACA,4D;AACA,gD;AACA,K;;AAEA,O;AACA,+C;AACA,e;AACA,O;AACA,2B;AACA,oC;AACA,+D;AACA,S;AACA,K;;AAEA,O;AACA,uE;AACA,e;AACA,O;AACA,uC;AACA,6D;AACA,kE;AACA,+C;AACA,mC;AACA,K;;AAEA,O;AACA,4F;AACA,e;AACA,wB;AACA,O;AACA,qC;AACA,8F;AACA,K;;AAEA,O;AACA,mE;AACA,qB;AACA,mB;AACA,O;AACA,wC;AACA,2C;AACA,K;;AAEA,oC;AACA,qC;AACA,K;AACA,G;AACA,C;AACA,0H;;AAEA,K;AACA,Y;AACA,a;;AAEA,E;AACA,gB;AACA,mC;AACA,e;AACA,E;AACA,wB;AACA,G;;AAEA,8C;AACA,kB;AACA,+B;AACA,E;AACA,kC;;AAEA,E;AACA,iB;AACA,kB;AACA,qC;AACA,E;AACA,e;AACA,mE;AACA,E;AACA,8D;AACA,c;AACA,mD;AACA,iE;AACA,gE;AACA,oE;AACA,G;;AAEA,qE;;AAEA,kD;;AAEA,K;AACA,yF;AACA,K;AACA,sE;AACA,sD;AACA,6B;;AAEA,+B;AACA,mB;AACA,uC;AACA,e;AACA,oB;AACA,S;AACA,Y;AACA,2D;AACA,sB;AACA,4C;AACA,wD;AACA,O;;AAEA,6E;AACA,wC;AACA,K;AACA,I;;AAEA,qC;AACA,yC;;AAEA,kE;AACA,6B;AACA,mE;;AAEA,wE;AACA,8C;AACA,0C;AACA,2D;AACA,sC;;AAEA,a;AACA,uD;AACA,mB;AACA,iB;AACA,kD;AACA,iB;AACA,gB;AACA,e;AACA,sC;AACA,M;;AAEA,oB;AACA,a;AACA,qB;AACA,8E;AACA,wC;AACA,8C;AACA,sD;;AAEA,kB;AACA,yB;AACA,0B;AACA,Q;AACA,4B;;AAEA,6C;;AAEA,iC;;AAEA,gC;AACA,kD;AACA,+C;AACA,wC;AACA,gC;AACA,W;AACA,W;AACA,mC;AACA,Q;AACA,K;;AAEA,gC;AACA,8E;AACA,8E;AACA,+C;AACA,0C;AACA,mD;AACA,sC;AACA,S;;AAEA,uD;AACA,yD;AACA,e;AACA,yD;AACA,wD;AACA,mD;AACA,+B;AACA,gB;AACA,S;AACA,O;AACA,2B;AACA,K;;;AAGA,oB;AACA,c;AACA,qB;;AAEA,iE;AACA,2B;AACA,oC;AACA,kF;AACA,yB;AACA,oC;AACA,mB;AACA,oB;AACA,mD;AACA,sC;AACA,wC;AACA,uC;AACA,O;AACA,sD;AACA,sD;AACA,K;;;AAGA,mE;AACA,yB;AACA,kD;AACA,sE;AACA,yC;;AAEA,oB;AACA,4B;AACA,6B;;AAEA,4B;AACA,gD;AACA,6C;AACA,sE;AACA,oC;AACA,kC;AACA,yE;AACA,8D;AACA,kF;AACA,kB;AACA,0C;AACA,W;AACA,S;AACA,Q;AACA,iD;AACA,oD;AACA,2C;AACA,+D;AACA,kE;AACA,oC;AACA,S;AACA,oF;AACA,0E;AACA,oE;AACA,wC;AACA,iE;AACA,qF;AACA,kB;AACA,0C;AACA,W;AACA,S;AACA,O;AACA,K;AACA,K;AACA,kC;AACA,uC;AACA,wC;AACA,wB;AACA,qC;AACA,0C;AACA,M;;AAEA,kC;AACA,gB;AACA,sC;AACA,M;;AAEA,yB;AACA,0C;AACA,qD;AACA,uC;AACA,uC;AACA,uC;AACA,uC;AACA,I;;AAEA,yC;AACA,+C;AACA,sB;AACA,wD;AACA,0D;AACA,M;AACA,4C;AACA,8C;AACA,wB;AACA,I;;AAEA,qC;AACA,uB;AACA,mD;AACA,6B;AACA,gC;AACA,uD;AACA,Q;AACA,a;AACA,gC;AACA,sB;AACA,oC;AACA,8D;AACA,S;AACA,M;AACA,I;AACA,G;;AAEA,iD;AACA,oC;AACA,mB;AACA,0C;AACA,6C;;AAEA,mD;AACA,kD;AACA,mE;AACA,qD;AACA,oC;AACA,c;AACA,O;AACA,K;AACA,oB;AACA,sB;AACA,G;;AAEA,qD;AACA,+D;AACA,mF;AACA,wD;AACA,6D;AACA,gD;AACA,+B;AACA,oB;AACA,uB;AACA,+C;AACA,yB;AACA,2B;AACA,+B;AACA,+C;AACA,O;AACA,wC;AACA,sC;AACA,O;;AAEA,gC;AACA,+D;AACA,4B;AACA,6C;AACA,c;AACA,0C;AACA,+B;AACA,O;AACA,K;AACA,G;;AAEA,C;AACA,gF;;AAEA,K;AACA,Y;AACA,a;;AAEA,G;AACA,gB;AACA,sC;AACA,e;AACA,mB;AACA,E;AACA,2E;AACA,2E;AACA,+E;AACA,uE;AACA,E;AACA,gF;AACA,8E;AACA,yF;AACA,E;AACA,0F;AACA,E;AACA,G;AACA,iD;AACA,kB;AACA,8B;AACA,E;AACA,kD;;AAEA,G;AACA,mB;AACA,oB;AACA,wC;AACA,E;AACA,c;AACA,E;AACA,e;AACA,wF;AACA,oF;AACA,E;AACA,E;AACA,S;AACA,qB;AACA,8C;AACA,U;AACA,G;;AAEA,gE;AACA,U;AACA,kB;AACA,kB;AACA,qB;AACA,c;AACA,mC;AACA,4C;AACA,wD;AACA,kB;AACA,c;AACA,kD;AACA,sD;AACA,4B;AACA,6C;;AAEA,iC;AACA,+E;AACA,S;;AAEA,8D;AACA,gC;AACA,2C;AACA,4C;AACA,W;;AAEA,uE;AACA,uE;AACA,gD;AACA,6C;AACA,0E;AACA,kD;AACA,mD;AACA,a;AACA,S;AACA,Q;AACA,K;AACA,I;AACA,C;AACA,uE;;AAEA,K;AACA,Y;AACA,a;;AAEA,G;AACA,gB;AACA,kC;AACA,6B;AACA,G;AACA,G;AACA,mB;AACA,oC;AACA,oB;AACA,E;AACA,c;AACA,E;AACA,e;AACA,+F;AACA,Q;AACA,E;AACA,S;AACA,qB;AACA,0D;AACA,U;AACA,G;AACA,G;AACA,mB;AACA,oC;AACA,qB;AACA,E;AACA,c;AACA,E;AACA,e;AACA,gG;AACA,S;AACA,E;AACA,S;AACA,qB;AACA,6D;AACA,U;AACA,G;;AAEA,8D;AACA,wD;AACA,2D;;AAEA,6B;AACA,kC;AACA,8C;;AAEA,0C;AACA,0B;;AAEA,iB;AACA,qC;AACA,+C;AACA,+C;AACA,6C;AACA,4C;AACA,kE;AACA,W;AACA,O;AACA,K;AACA,C;;;;AAIA,K;AACA,Y;AACA,a;;AAEA,G;AACA,W;AACA,gB;AACA,mC;AACA,G;;AAEA,8C;AACA,kB;AACA,gC;AACA,E;AACA,mC;;AAEA,G;AACA,W;AACA,mB;AACA,qC;AACA,iB;AACA,c;AACA,E;AACA,0I;AACA,E;AACA,mH;AACA,2F;AACA,0B;AACA,E;AACA,0E;AACA,wF;AACA,oG;AACA,yG;AACA,kI;AACA,oF;AACA,gI;AACA,E;AACA,S;AACA,qB;AACA,yD;AACA,e;AACA,e;AACA,E;AACA,sE;AACA,mB;AACA,e;AACA,E;AACA,6E;AACA,a;AACA,e;AACA,E;AACA,U;AACA,G;AACA,gH;AACA,iD;;AAEA,U;AACA,kB;AACA,sC;AACA,qB;AACA,a;AACA,oC;AACA,sC;AACA,4C;AACA,+E;AACA,iB;AACA,gB;AACA,8C;AACA,e;AACA,wB;AACA,oB;AACA,I;;AAEA,mC;AACA,gE;AACA,oC;AACA,oC;;AAEA,qD;AACA,iD;AACA,mD;AACA,4F;AACA,uF;;AAEA,sC;AACA,wB;AACA,2C;AACA,S;;AAEA,kD;;AAEA,+C;AACA,2D;AACA,wD;AACA,W;AACA,O;;AAEA,iD;AACA,mD;AACA,qB;AACA,yC;AACA,+B;AACA,sC;;AAEA,e;AACA,gC;AACA,yC;AACA,0C;AACA,6B;;AAEA,wC;AACA,gB;AACA,mD;AACA,U;AACA,0C;AACA,O;;AAEA,2B;AACA,0B;AACA,6B;AACA,oD;;AAEA,wD;;AAEA,6D;AACA,oE;AACA,6D;AACA,wD;;AAEA,mG;AACA,mC;AACA,O;;AAEA,8B;AACA,0B;AACA,6B;;AAEA,2C;AACA,0D;;AAEA,wE;AACA,wD;AACA,yF;AACA,wB;AACA,+C;AACA,S;AACA,oB;AACA,O;;AAEA,0C;AACA,iC;AACA,0C;AACA,4B;AACA,W;AACA,O;;AAEA,M;AACA,G;;;AAGA,C;AACA,iI;;AAEA,K;AACA,Y;AACA,a;;AAEA,G;AACA,gB;AACA,kC;AACA,e;AACA,Q;AACA,G;AACA,6C;AACA,kB;AACA,8B;AACA,E;AACA,yC;AACA,yC;;AAEA,6B;AACA,U;AACA,iB;AACA,I;AACA,C;;AAEA,G;AACA,iB;AACA,iB;AACA,oC;AACA,E;AACA,e;AACA,wE;AACA,8E;AACA,E;AACA,E;AACA,mC;AACA,kE;AACA,4D;AACA,mD;AACA,E;AACA,S;AACA,qB;AACA,qC;AACA,uC;AACA,oB;AACA,iB;AACA,S;AACA,U;AACA,E;AACA,mB;AACA,mD;AACA,8D;AACA,0C;AACA,0D;AACA,qD;AACA,O;AACA,M;AACA,U;AACA,G;;AAEA,G;AACA,gB;AACA,4B;AACA,G;AACA,e;AACA,4D;AACA,E;AACA,8E;AACA,qC;AACA,E;AACA,G;;AAEA,I;AACA,gB;AACA,wB;AACA,E;AACA,e;AACA,gC;AACA,E;AACA,8E;AACA,E;AACA,kE;AACA,yH;AACA,mF;AACA,4F;AACA,2H;AACA,G;;AAEA,G;AACA,gB;AACA,+B;AACA,G;AACA,e;AACA,yF;AACA,E;AACA,G;;AAEA,I;AACA,gB;AACA,uB;AACA,E;AACA,e;AACA,4D;AACA,E;AACA,6G;AACA,G;;AAEA,I;AACA,gB;AACA,sB;AACA,E;AACA,gC;AACA,E;AACA,8F;AACA,qE;AACA,E;AACA,8E;AACA,2E;AACA,wC;AACA,8E;AACA,uB;AACA,qI;AACA,oG;AACA,kH;AACA,6E;AACA,gG;AACA,sC;AACA,qF;AACA,0E;AACA,+E;AACA,kF;AACA,8B;AACA,kF;AACA,6E;AACA,mF;AACA,Y;AACA,iK;AACA,qF;AACA,8D;AACA,uF;AACA,yF;AACA,8C;AACA,E;AACA,8E;AACA,qC;AACA,G;;AAEA,G;AACA,gB;AACA,sB;AACA,E;AACA,e;AACA,kF;AACA,E;AACA,6D;AACA,E;AACA,gG;AACA,E;AACA,G;;AAEA,G;AACA,gB;AACA,wB;AACA,E;AACA,e;AACA,+D;AACA,qB;AACA,E;AACA,6D;AACA,E;AACA,gG;AACA,E;AACA,G;;AAEA,oD;AACA,yB;AACA,qD;AACA,kB;AACA,qD;AACA,kC;AACA,M;AACA,0B;AACA,2B;AACA,2E;AACA,0F;AACA,oB;AACA,qB;AACA,iG;AACA,sD;AACA,mJ;AACA,qC;AACA,6B;AACA,yB;AACA,qB;AACA,+E;AACA,4B;AACA,iF;AACA,gD;AACA,e;AACA,uC;AACA,8B;AACA,c;AACA,a;AACA,2C;AACA,gC;AACA,gC;AACA,U;AACA,oB;AACA,Q;AACA,M;AACA,sD;AACA,sC;AACA,O;;AAEA,gF;AACA,oB;;AAEA,iB;AACA,uE;AACA,Y;AACA,qB;AACA,yB;AACA,8B;AACA,qB;AACA,qB;AACA,M;;AAEA,8C;AACA,kE;;AAEA,uC;AACA,2C;AACA,sE;AACA,2B;AACA,oB;AACA,gE;;AAEA,+C;AACA,+E;AACA,6D;AACA,kC;AACA,Q;AACA,kE;AACA,qD;AACA,K;;AAEA,gD;AACA,mE;AACA,mE;AACA,qC;AACA,K;;AAEA,uC;AACA,+B;AACA,0D;AACA,K;AACA,G;;AAEA,C;AACA,uD;;AAEA,K;AACA,Y;AACA,a;;AAEA,G;AACA,gB;AACA,iC;AACA,e;AACA,E;AACA,mG;AACA,6F;AACA,E;AACA,iC;AACA,E;AACA,6B;AACA,yB;AACA,mC;AACA,qB;AACA,uC;AACA,iD;AACA,4D;AACA,yD;AACA,E;AACA,G;AACA,E;AACA,yC;AACA,G;AACA,4C;AACA,kB;AACA,4B;AACA,G;;AAEA,K;AACA,Y;AACA,a;;AAEA,G;AACA,gB;AACA,oC;AACA,G;AACA,+C;AACA,kB;AACA,+B;AACA,E;AACA,8C;;AAEA,G;AACA,mB;AACA,kB;AACA,sC;AACA,c;AACA,e;AACA,uD;AACA,E;AACA,6E;AACA,gE;AACA,E;AACA,gE;AACA,sD;AACA,E;AACA,S;AACA,qB;AACA,oC;AACA,iB;AACA,E;AACA,qC;AACA,oC;AACA,E;AACA,+D;AACA,2B;AACA,E;AACA,oB;AACA,2B;AACA,qB;AACA,a;AACA,E;AACA,kB;AACA,iB;AACA,a;AACA,kB;AACA,S;AACA,U;AACA,E;AACA,8E;AACA,mE;AACA,qE;AACA,sE;AACA,E;AACA,E;AACA,wF;AACA,2E;AACA,sE;AACA,G;AACA,0F;;AAEA,U;AACA,kB;AACA,6B;AACA,0C;AACA,0B;;AAEA,mD;AACA,4B;AACA,O;;AAEA,oC;AACA,yC;AACA,kB;AACA,6C;AACA,8B;;AAEA,gE;;AAEA,0B;AACA,2B;;AAEA,qE;AACA,oF;;AAEA,oE;AACA,2E;AACA,4B;AACA,uD;;AAEA,wD;AACA,iD;AACA,iE;AACA,0D;AACA,iC;AACA,mE;AACA,a;;AAEA,8D;AACA,uD;;AAEA,0C;AACA,uC;AACA,W;AACA,S;;AAEA,wC;AACA,uD;AACA,iF;AACA,8E;AACA,wC;AACA,Y;AACA,gF;AACA,iE;AACA,oE;AACA,mD;AACA,sD;;AAEA,4B;AACA,S;;AAEA,qC;AACA,iE;;AAEA,kC;;AAEA,uB;AACA,8C;AACA,sD;AACA,Y;;AAEA,sB;AACA,sC;AACA,iE;AACA,Y;AACA,6B;AACA,sC;AACA,kF;AACA,Y;;AAEA,oC;;AAEA,uD;AACA,uB;AACA,6F;AACA,e;AACA,oB;AACA,sB;AACA,0F;AACA,e;AACA,a;AACA,S;;AAEA,O;;AAEA,K;AACA,I;;AAEA,C;AACA,uG;;AAEA,K;AACA,Y;AACA,a;;AAEA,G;AACA,gB;AACA,oC;AACA,G;AACA,O;AACA,+D;AACA,gD;;AAEA,G;AACA,mB;AACA,kB;AACA,sC;AACA,e;AACA,qG;AACA,E;AACA,iE;AACA,E;AACA,qF;AACA,E;AACA,S;AACA,qB;AACA,yD;AACA,iB;AACA,iB;AACA,kB;AACA,gE;AACA,e;AACA,U;AACA,E;AACA,0E;AACA,qB;AACA,wJ;AACA,+I;AACA,uI;AACA,G;AACA,mH;;AAEA,+B;AACA,oC;;AAEA,U;AACA,kB;AACA,qB;AACA,kC;AACA,gB;AACA,0C;AACA,sD;AACA,Y;AACA,6B;AACA,yB;AACA,8B;AACA,M;AACA,kB;AACA,I;;AAEA,2C;;AAEA,wB;;AAEA,qD;AACA,+F;AACA,4F;AACA,yC;AACA,mD;AACA,kE;AACA,kG;;AAEA,kB;;AAEA,sB;AACA,oB;AACA,0B;AACA,mB;AACA,0B;AACA,qB;AACA,K;;AAEA,6B;AACA,6E;AACA,K;;AAEA,mC;AACA,wC;AACA,8B;AACA,yB;AACA,kE;AACA,S;AACA,oD;AACA,qC;AACA,2B;AACA,S;AACA,K;;AAEA,8B;AACA,gE;AACA,yD;AACA,O;AACA,K;;AAEA,mC;AACA,uB;AACA,sC;AACA,K;;AAEA,4C;AACA,oC;AACA,yF;AACA,iC;AACA,O;AACA,oB;AACA,K;;AAEA,0C;AACA,wC;AACA,6E;AACA,mF;AACA,oF;AACA,qC;AACA,O;AACA,qB;AACA,K;;AAEA,gD;AACA,+C;AACA,kE;AACA,wF;AACA,K;;AAEA,4B;AACA,8B;AACA,qC;AACA,8D;AACA,2B;AACA,S;AACA,Q;AACA,sC;AACA,6G;AACA,qF;AACA,4B;AACA,S;AACA,4B;AACA,Q;;AAEA,8E;AACA,iE;AACA,8D;AACA,uE;;;AAGA,+D;AACA,K;;AAEA,iC;AACA,iC;AACA,+B;AACA,oB;AACA,mC;AACA,+B;AACA,6C;AACA,sC;AACA,0B;AACA,gB;AACA,0D;AACA,S;AACA,O;AACA,K;;AAEA,4B;AACA,6E;AACA,0C;AACA,oC;;AAEA,8C;AACA,uE;AACA,sD;AACA,8B;AACA,yB;AACA,e;AACA,O;;AAEA,wB;AACA,0E;AACA,8C;AACA,S;AACA,K;;AAEA,4B;AACA,c;AACA,iD;AACA,oD;AACA,gD;AACA,2B;AACA,6C;AACA,S;AACA,K;;AAEA,gC;AACA,+D;AACA,iE;AACA,+C;;AAEA,iF;AACA,wE;AACA,sB;AACA,+C;AACA,4H;AACA,sD;AACA,O;;AAEA,gF;;AAEA,2B;;AAEA,sC;AACA,gE;AACA,2F;AACA,4F;AACA,oE;AACA,4D;AACA,4D;AACA,qC;AACA,wB;AACA,6B;AACA,8B;AACA,oC;AACA,iC;AACA,W;AACA,O;;AAEA,kC;AACA,2D;AACA,uI;AACA,mF;AACA,yI;AACA,mF;AACA,2B;AACA,O;;AAEA,kC;AACA,6B;AACA,gF;AACA,gF;AACA,2B;AACA,mF;AACA,gF;AACA,yB;AACA,+E;AACA,gF;AACA,+E;AACA,oF;AACA,O;AACA,K;;AAEA,G;;AAEA,C;AACA,sI;;AAEA,K;AACA,Y;AACA,a;;AAEA,G;AACA,gB;AACA,uC;AACA,G;AACA,qD;;AAEA,K;AACA,Y;AACA,a;;AAEA,O;AACA,+C;AACA,0D;;AAEA,qB;AACA,mC;AACA,qB;;AAEA,6H;;AAEA,wB;;AAEA,uB;AACA,kD;AACA,+B;AACA,uB;AACA,uB;AACA,qB;AACA,wB;AACA,gC;AACA,wB;;AAEA,uB;;AAEA,yB;AACA,iC;AACA,+B;AACA,qB;AACA,wB;AACA,uB;AACA,uB;AACA,qB;AACA,oC;;AAEA,qB;;AAEA,0B;AACA,uB;AACA,wB;AACA,6B;AACA,yB;AACA,+D;AACA,oE;AACA,sE;;AAEA,kD;AACA,gC;AACA,mB;AACA,sC;AACA,I;AACA,2D;;AAEA,gB;;AAEA,6B;;AAEA,oB;AACA,wB;AACA,0B;AACA,uB;AACA,qB;AACA,qB;AACA,O;AACA,G;;AAEA,gC;AACA,+D;AACA,uD;AACA,uD;AACA,uD;AACA,yC;AACA,yC;AACA,wC;AACA,6B;AACA,kB;AACA,gC;AACA,iC;AACA,oG;AACA,U;AACA,8E;AACA,0B;AACA,iC;AACA,0F;AACA,Y;AACA,8B;AACA,6B;AACA,gG;AACA,K;AACA,8B;AACA,mD;;AAEA,4C;AACA,yD;AACA,wB;AACA,uD;AACA,4D;AACA,O;AACA,gC;AACA,K;AACA,G;;AAEA,4B;AACA,wC;AACA,8B;AACA,2B;AACA,0C;AACA,gE;AACA,G;;AAEA,4B;AACA,iD;AACA,G;;AAEA,iC;AACA,+C;AACA,oC;AACA,kD;AACA,4B;AACA,oD;AACA,4D;AACA,8E;AACA,mD;AACA,O;AACA,4D;AACA,G;;AAEA,8B;AACA,gB;AACA,yB;AACA,oC;AACA,uC;AACA,sD;AACA,0B;AACA,M;AACA,yD;AACA,oC;AACA,8C;AACA,G;;AAEA,6B;AACA,8E;AACA,qF;AACA,K;AACA,yB;AACA,G;;AAEA,0C;AACA,iB;AACA,+B;AACA,gD;AACA,K;AACA,e;AACA,G;;AAEA,4B;;AAEA,oE;AACA,uB;AACA,wD;AACA,K;AACA,mE;AACA,oD;AACA,G;;AAEA,yE;AACA,2D;AACA,kE;AACA,K;AACA,G;;AAEA,K;AACA,qE;AACA,c;AACA,K;AACA,4C;AACA,iD;AACA,oC;AACA,K;AACA,G;;AAEA,K;AACA,2E;AACA,c;AACA,K;AACA,8C;AACA,6C;AACA,kB;AACA,wC;AACA,K;AACA,G;;AAEA,8D;AACA,mC;AACA,2B;AACA,kD;AACA,gE;AACA,wF;AACA,gB;AACA,0C;AACA,+D;AACA,2D;AACA,yD;AACA,4B;AACA,2B;AACA,wB;AACA,iC;AACA,uB;AACA,Y;AACA,oB;AACA,K;AACA,G;;AAEA,oB;AACA,qB;AACA,oC;AACA,G;;AAEA,qB;AACA,oB;AACA,6D;AACA,qE;AACA,qC;AACA,+B;AACA,oC;AACA,G;;AAEA,4B;AACA,4B;AACA,2C;AACA,iC;AACA,+B;AACA,uE;AACA,uB;AACA,yB;AACA,c;AACA,yC;AACA,iC;AACA,+B;AACA,4F;AACA,uB;AACA,yB;AACA,c;AACA,oC;AACA,sC;AACA,6F;AACA,+B;AACA,2B;AACA,c;AACA,uC;AACA,0B;AACA,2B;AACA,uC;AACA,c;AACA,c;AACA,K;AACA,G;;AAEA,c;;AAEA,4B;AACA,qE;AACA,G;;AAEA,mC;AACA,kF;AACA,G;;AAEA,gC;AACA,sB;AACA,oB;AACA,oD;AACA,kB;AACA,G;;AAEA,+B;AACA,sC;AACA,G;;AAEA,0B;AACA,uC;AACA,G;;AAEA,sC;AACA,qD;AACA,G;;AAEA,8B;AACA,sD;AACA,G;;AAEA,c;;AAEA,2B;AACA,8C;AACA,kF;AACA,uB;AACA,mB;AACA,sB;AACA,G;;AAEA,0B;AACA,2B;AACA,e;;AAEA,2D;AACA,uD;AACA,8E;AACA,2C;;AAEA,2B;AACA,G;;AAEA,sC;AACA,+C;AACA,wC;AACA,iC;AACA,2B;AACA,Y;AACA,0B;AACA,sD;AACA,mD;AACA,4E;AACA,K;AACA,sC;AACA,4B;AACA,2B;AACA,8F;AACA,qB;AACA,6B;AACA,iC;AACA,uB;AACA,yB;AACA,K;AACA,G;;AAEA,8B;AACA,uC;AACA,yD;AACA,a;AACA,G;;AAEA,+B;AACA,kC;AACA,oD;AACA,iF;AACA,K;AACA,G;;AAEA,4B;AACA,yC;AACA,sC;AACA,2B;AACA,oC;AACA,uC;AACA,sC;AACA,kC;AACA,mD;AACA,wC;AACA,K;AACA,G;;AAEA,2B;AACA,uC;AACA,wC;AACA,mD;AACA,oC;AACA,uB;AACA,qB;AACA,K;AACA,sD;AACA,yC;AACA,iC;AACA,uB;AACA,Y;AACA,+B;AACA,K;AACA,6C;AACA,G;;AAEA,C;AACA,+I;;AAEA,K;AACA,Y;AACA,a;;AAEA,O;AACA,+C;AACA,iD;;AAEA,G;AACA,mB;AACA,uB;AACA,2C;AACA,E;AACA,e;AACA,+G;AACA,kG;AACA,E;AACA,sG;AACA,sE;AACA,E;AACA,iG;AACA,qG;AACA,gE;AACA,iB;AACA,E;AACA,iG;AACA,oG;AACA,a;AACA,E;AACA,kE;AACA,4D;AACA,yE;AACA,4E;AACA,E;AACA,qD;AACA,E;AACA,E;AACA,uH;AACA,uG;AACA,sG;AACA,2E;AACA,yE;AACA,gG;AACA,qF;AACA,2F;AACA,qF;AACA,gH;AACA,8G;AACA,mF;AACA,sF;AACA,uF;AACA,E;AACA,S;AACA,mB;AACA,qB;AACA,qB;AACA,wC;AACA,oC;AACA,kD;AACA,qC;AACA,mE;AACA,uB;AACA,U;AACA,E;AACA,sC;AACA,qB;AACA,mB;AACA,sC;AACA,kC;AACA,gD;AACA,mC;AACA,uB;AACA,mE;AACA,wB;AACA,mB;AACA,wB;AACA,oB;AACA,qB;AACA,U;AACA,E;AACA,oG;AACA,oC;AACA,E;AACA,8B;AACA,qB;AACA,iC;AACA,qB;AACA,iB;AACA,kC;AACA,wC;AACA,oC;AACA,kD;AACA,qC;AACA,yB;AACA,qE;AACA,0B;AACA,+D;AACA,gE;AACA,a;AACA,uB;AACA,U;AACA,U;AACA,E;AACA,oG;AACA,oC;AACA,G;;AAEA,+C;AACA,U;AACA,uC;AACA,wC;AACA,uB;AACA,mB;AACA,qC;AACA,0C;AACA,0C;AACA,uC;AACA,yC;AACA,iC;AACA,oC;AACA,qC;AACA,oC;AACA,+C;AACA,6C;AACA,sC;AACA,kC;AACA,sC;AACA,0C;AACA,uC;AACA,qC;AACA,M;AACA,wC;AACA,iD;AACA,2C;AACA,oC;AACA,e;AACA,8B;AACA,yB;AACA,gE;AACA,4B;AACA,oC;AACA,kB;AACA,4B;AACA,4B;AACA,0E;AACA,sD;AACA,wD;AACA,0D;AACA,oB;AACA,8B;AACA,kD;AACA,4D;AACA,kC;AACA,yF;AACA,iD;AACA,8D;AACA,8D;AACA,0D;AACA,yE;AACA,6E;AACA,qD;AACA,6D;AACA,0E;AACA,qC;AACA,kB;AACA,oC;AACA,gB;AACA,gC;AACA,qB;AACA,uC;AACA,0B;AACA,mC;AACA,iG;AACA,wB;;AAEA,kC;AACA,oE;AACA,4E;AACA,iD;AACA,oB;AACA,O;;AAEA,qC;AACA,gE;AACA,oE;AACA,uB;AACA,8F;AACA,yD;AACA,8D;AACA,4E;AACA,iB;;AAEA,O;;AAEA,kC;AACA,mC;AACA,mB;AACA,4D;AACA,+C;AACA,mC;AACA,2D;AACA,uC;AACA,qC;AACA,2C;AACA,gD;AACA,gD;AACA,2C;AACA,kE;AACA,mE;AACA,uD;AACA,yD;AACA,4D;AACA,iD;AACA,2C;AACA,uC;AACA,2C;AACA,oE;AACA,+F;AACA,mC;AACA,gB;AACA,mB;AACA,sC;AACA,sD;AACA,qC;AACA,uC;AACA,mC;AACA,yC;AACA,yC;AACA,gE;AACA,iE;AACA,qD;AACA,uD;AACA,8C;AACA,0D;AACA,6C;AACA,yC;AACA,qC;AACA,yC;AACA,mE;AACA,S;AACA,O;AACA,K;AACA,I;;AAEA,wC;AACA,8E;AACA,uF;;AAEA,uF;;AAEA,wB;AACA,G;AACA,C;AACA,mD;;AAEA,K;AACA,Y;AACA,a;;AAEA,O;AACA,+C;AACA,oD;;AAEA,2D;AACA,mB;;AAEA,gB;;AAEA,wB;AACA,2D;AACA,gE;AACA,0D;AACA,uD;AACA,6C;AACA,8E;AACA,8B;AACA,W;AACA,wD;AACA,G;;AAEA,4B;AACA,2B;AACA,mE;AACA,G;;AAEA,oC;AACA,iB;AACA,4C;AACA,gB;AACA,4C;AACA,mE;AACA,G;AACA,C;AACA,iE;;AAEA,K;AACA,Y;AACA,a;;AAEA,O;AACA,+C;AACA,+C;;AAEA,G;AACA,mB;AACA,wB;AACA,2C;AACA,E;AACA,e;AACA,iG;AACA,+F;AACA,+F;AACA,E;AACA,+D;AACA,kG;AACA,+B;AACA,sD;AACA,mD;AACA,6D;AACA,+D;AACA,E;AACA,S;AACA,qB;AACA,mF;AACA,O;AACA,sE;AACA,sB;AACA,U;AACA,Q;AACA,U;AACA,G;;AAEA,yB;AACA,U;AACA,mB;AACA,iB;AACA,kC;AACA,iD;AACA,sC;AACA,K;AACA,I;AACA,C;;AAEA,K;AACA,Y;AACA,a;;AAEA,O;AACA,+C;AACA,iE;;AAEA,qD;AACA,U;AACA,mB;AACA,mB;AACA,gB;AACA,I;AACA,4C;AACA,qD;AACA,wD;AACA,iE;AACA,oC;AACA,2C;AACA,kB;AACA,qB;AACA,qC;AACA,O;AACA,G;AACA,C;AACA,yD;;AAEA,K;AACA,Y;AACA,a;;AAEA,O;AACA,+C;AACA,uE;;AAEA,wD;AACA,U;AACA,kB;AACA,mB;AACA,mB;AACA,gB;AACA,I;AACA,4C;AACA,qD;AACA,8C;AACA,uD;AACA,wC;AACA,uB;AACA,K;AACA,G;AACA,C;AACA,4D;;AAEA,K;AACA,Y;AACA,a;;AAEA,O;AACA,wC;AACA,iC;;AAEA,G;AACA,mB;AACA,e;AACA,oC;AACA,E;AACA,e;AACA,kG;AACA,S;AACA,E;AACA,E;AACA,S;AACA,qB;AACA,iC;AACA,U;AACA,E;AACA,G;;AAEA,uE;AACA,qD;AACA,6B;AACA,qE;AACA,kC;AACA,a;;AAEA,G;AACA,8B;AACA,E;AACA,oB;AACA,sB;AACA,Y;AACA,G;AACA,6B;AACA,U;AACA,kB;AACA,yB;AACA,qB;AACA,I;;AAEA,mC;AACA,yC;AACA,0D;AACA,kC;AACA,0B;;AAEA,6E;AACA,mC;AACA,mC;AACA,a;AACA,M;AACA,G;AACA,C;AACA,gC;;AAEA,K;AACA,Y;AACA,a;;AAEA,O;AACA,wC;AACA,6C;;AAEA,G;AACA,mB;AACA,qB;AACA,oC;AACA,E;AACA,e;AACA,qB;AACA,yE;AACA,0D;AACA,E;AACA,S;AACA,qB;AACA,6D;AACA,U;AACA,G;;;AAGA,G;AACA,qC;AACA,G;AACA,kB;AACA,kB;AACA,mF;AACA,e;AACA,G;AACA,kC;AACA,U;AACA,kB;AACA,wB;AACA,iB;AACA,kB;AACA,I;;AAEA,iD;AACA,yC;AACA,+B;AACA,sD;AACA,S;AACA,O;;AAEA,2F;AACA,wC;AACA,yB;AACA,uD;AACA,oD;AACA,O;AACA,G;AACA,C;AACA,oC;;AAEA,K;AACA,Y;AACA,a;;AAEA,O;AACA,wC;AACA,qD;;AAEA,+C;AACA,U;AACA,mB;AACA,mB;AACA,e;AACA,gB;AACA,I;AACA,wC;AACA,0C;AACA,wD;AACA,qC;AACA,iC;AACA,iC;AACA,2D;AACA,2C;AACA,G;AACA,C;AACA,mD;;AAEA,K;AACA,Y;AACA,a;;AAEA,O;AACA,wC;AACA,4C;;AAEA,G;AACA,sE;AACA,6E;AACA,0C;AACA,E;AACA,gB;AACA,qB;AACA,c;AACA,kB;AACA,e;AACA,G;AACA,sE;AACA,0B;AACA,2B;;AAEA,uB;AACA,iC;;AAEA,+B;AACA,uB;;AAEA,+B;AACA,+B;;AAEA,qB;AACA,mB;;AAEA,yB;AACA,2B;;AAEA,0C;AACA,0B;;AAEA,0C;AACA,mC;;AAEA,wB;AACA,+B;;AAEA,+B;AACA,kB;;AAEA,uB;AACA,yB;;;AAGA,K;AACA,uF;AACA,mB;AACA,K;AACA,wD;;AAEA,K;AACA,gF;AACA,mB;AACA,K;AACA,oC;;AAEA,K;AACA,qC;AACA,mB;AACA,K;AACA,uB;;AAEA,K;AACA,0E;AACA,qC;AACA,oB;AACA,K;AACA,6B;AACA,C;AACA,gF;;AAEA,G;AACA,sE;AACA,6E;AACA,kC;AACA,e;AACA,G;AACA,sD;AACA,wC;AACA,0B;AACA,yC;AACA,yD;AACA,6B;AACA,kC;AACA,6B;AACA,Y;AACA,6C;AACA,4B;AACA,8B;AACA,gF;AACA,Y;AACA,G;AACA,E;;AAEA,G;AACA,6F;AACA,oC;AACA,e;AACA,G;AACA,sD;AACA,mC;AACA,0B;AACA,6C;AACA,0C;AACA,wC;AACA,6B;AACA,0D;AACA,Y;AACA,8C;AACA,6B;AACA,uE;AACA,gF;AACA,Y;AACA,+C;AACA,6B;AACA,yD;AACA,Y;AACA,0C;AACA,uC;AACA,wC;AACA,6B;AACA,qB;AACA,Y;AACA,G;AACA,E;;AAEA,G;AACA,kG;AACA,gG;AACA,U;AACA,G;AACA,mD;AACA,+C;AACA,0C;AACA,sE;AACA,qE;AACA,E;;AAEA,G;AACA,+D;AACA,e;AACA,G;AACA,qE;AACA,kD;AACA,yB;AACA,gD;AACA,4C;AACA,M;AACA,E;;AAEA,G;AACA,sC;AACA,G;AACA,sD;AACA,yB;AACA,E;;AAEA,G;AACA,4E;AACA,yE;AACA,6E;AACA,oE;AACA,uE;AACA,W;AACA,2E;AACA,G;AACA,8D;AACA,kC;AACA,0B;AACA,wC;AACA,E;;AAEA,G;AACA,6E;AACA,mD;AACA,iB;AACA,G;AACA,sD;AACA,8C;AACA,8C;AACA,kD;AACA,G;AACA,2B;AACA,E;;AAEA,G;AACA,sE;AACA,+D;AACA,yE;AACA,6E;AACA,qB;AACA,G;AACA,4D;AACA,4B;AACA,E;;AAEA,G;AACA,wE;AACA,uE;AACA,yE;AACA,0D;AACA,sC;AACA,0B;AACA,G;AACA,kD;AACA,mD;AACA,wE;AACA,yC;AACA,E;;AAEA,G;AACA,wF;AACA,G;AACA,oD;AACA,8B;AACA,oC;AACA,kD;AACA,0C;AACA,Y;AACA,0C;AACA,K;AACA,U;AACA,yB;AACA,G;AACA,E;;AAEA,G;AACA,uC;AACA,e;AACA,G;AACA,oD;AACA,8B;AACA,E;;AAEA,kE;AACA,yB;AACA,iB;AACA,E;AACA,G;AACA,+B;AACA,e;AACA,G;AACA,gE;AACA,2B;AACA,wB;AACA,mB;AACA,W;AACA,G;AACA,yD;AACA,6B;AACA,iD;AACA,yB;AACA,wB;AACA,E;;AAEA,G;AACA,iD;AACA,e;AACA,G;AACA,oD;AACA,kD;AACA,8B;AACA,U;AACA,mE;AACA,G;AACA,E;;AAEA,G;AACA,kD;AACA,e;AACA,G;AACA,4D;AACA,yB;AACA,oB;AACA,0B;AACA,G;AACA,E;;AAEA,G;AACA,wC;AACA,G;AACA,mD;AACA,4F;AACA,E;;AAEA,G;AACA,oE;AACA,6E;AACA,qB;AACA,G;AACA,gE;AACA,iC;;AAEA,kB;AACA,oC;AACA,sC;AACA,6C;AACA,I;AACA,E;;AAEA,6C;AACA,sD;AACA,yB;AACA,2B;AACA,E;;AAEA,kD;AACA,4B;AACA,2B;AACA,E;;AAEA,iD;AACA,6B;AACA,E;;AAEA,G;AACA,6D;AACA,sB;AACA,G;AACA,mE;AACA,uC;;AAEA,+C;AACA,uD;AACA,mD;AACA,wC;AACA,4C;AACA,G;;AAEA,8C;AACA,0B;AACA,kB;AACA,c;AACA,4B;AACA,qH;AACA,yD;AACA,wD;AACA,E;;AAEA,8D;;AAEA,uE;AACA,e;AACA,4B;AACA,6B;AACA,K;AACA,M;;AAEA,6B;AACA,yD;AACA,yD;AACA,E;;AAEA,8C;AACA,sD;AACA,E;;AAEA,K;AACA,Y;AACA,a;;AAEA,S;AACA,0C;AACA,qC;;AAEA,K;AACA,qB;AACA,kB;AACA,sC;AACA,I;AACA,iB;AACA,oG;AACA,oF;AACA,iC;AACA,I;AACA,0D;AACA,8F;AACA,mG;AACA,kG;AACA,oG;AACA,sE;AACA,kG;AACA,mG;AACA,iG;AACA,uC;AACA,I;AACA,gC;AACA,oC;AACA,I;AACA,gB;AACA,4D;AACA,Y;AACA,I;AACA,4B;AACA,qE;AACA,Y;AACA,I;AACA,qB;AACA,mG;AACA,6C;AACA,oD;AACA,Y;AACA,I;AACA,wB;AACA,sB;AACA,+F;AACA,iB;AACA,c;AACA,Y;AACA,I;AACA,4C;AACA,6F;AACA,gC;AACA,Y;AACA,I;AACA,wB;AACA,uE;AACA,c;AACA,Y;AACA,U;AACA,I;AACA,qD;AACA,yE;AACA,oD;AACA,a;AACA,I;AACA,2E;AACA,uF;AACA,iG;AACA,4D;AACA,kG;AACA,oC;AACA,gG;AACA,kC;AACA,iG;AACA,4C;AACA,gG;AACA,uB;AACA,I;AACA,W;AACA,uB;AACA,gB;AACA,6B;AACA,oC;AACA,iC;AACA,kB;AACA,Y;AACA,I;AACA,K;;;AAGA,4B;AACA,qB;AACA,0E;AACA,wD;AACA,iE;AACA,4B;AACA,yD;AACA,+B;AACA,8E;AACA,uC;AACA,4B;AACA,iC;AACA,mF;AACA,4E;AACA,gD;AACA,0E;AACA,mB;AACA,wE;AACA,4C;AACA,uE;AACA,e;AACA,wB;;AAEA,8B;AACA,e;AACA,yB;AACA,4D;AACA,2D;AACA,+C;AACA,mD;AACA,iD;AACA,6D;;AAEA,gC;AACA,8B;;AAEA,+B;AACA,c;AACA,iC;AACA,yC;AACA,kF;AACA,wB;AACA,6B;AACA,yB;AACA,mD;AACA,0C;AACA,6C;AACA,gB;AACA,iB;;AAEA,K;AACA,iC;AACA,K;AACA,oE;AACA,Y;AACA,0C;AACA,2E;AACA,yE;AACA,0E;AACA,4D;AACA,iE;AACA,iC;AACA,Q;AACA,2B;AACA,oB;AACA,gC;AACA,mC;AACA,6B;AACA,uB;AACA,c;AACA,8B;AACA,yB;AACA,kC;AACA,wB;AACA,wB;AACA,+B;AACA,wC;AACA,O;AACA,M;;AAEA,O;AACA,kF;AACA,M;AACA,uD;AACA,mB;AACA,oB;AACA,oB;AACA,M;AACA,gF;AACA,M;AACA,gG;AACA,wD;AACA,M;AACA,kG;AACA,M;AACA,gG;AACA,kG;AACA,iG;AACA,gB;AACA,M;AACA,mG;AACA,+C;AACA,M;AACA,M;AACA,qB;AACA,kB;AACA,0B;AACA,O;AACA,qC;AACA,0E;AACA,iD;AACA,qC;;AAEA,gG;AACA,kD;AACA,0G;AACA,0G;AACA,+E;AACA,qD;AACA,qC;AACA,qD;;AAEA,8C;AACA,gF;AACA,kF;AACA,O;;AAEA,2C;AACA,kC;AACA,2D;AACA,4C;AACA,O;;AAEA,S;AACA,+C;AACA,S;AACA,oE;;AAEA,oD;;AAEA,4B;AACA,yC;AACA,gE;AACA,8D;AACA,6D;;AAEA,e;AACA,qD;AACA,iE;;AAEA,2B;AACA,sE;;AAEA,8F;AACA,kC;AACA,sE;;AAEA,gG;AACA,6F;AACA,sC;AACA,yD;AACA,iC;AACA,sE;AACA,2B;AACA,0E;AACA,uD;AACA,oE;AACA,e;AACA,W;AACA,S;;AAEA,uF;AACA,qC;AACA,yE;AACA,+F;AACA,S;AACA,Q;AACA,K;AACA,G;AACA,8E;;AAEA,K;AACA,Y;AACA,a;;AAEA,O;AACA,wC;AACA,0D;;;;AAIA,G;AACA,8C;AACA,e;AACA,G;AACA,gC;AACA,uB;AACA,2B;;AAEA,uB;AACA,uB;AACA,C;;;AAGA,kE;AACA,0D;AACA,8B;AACA,gF;AACA,E;;;AAGA,yE;AACA,8C;AACA,E;;AAEA,K;AACA,Y;AACA,a;;AAEA,S;AACA,0C;AACA,mD;;AAEA,K;AACA,qB;AACA,yB;AACA,sC;AACA,I;AACA,iB;AACA,uF;AACA,+F;AACA,kG;AACA,0B;AACA,I;AACA,2E;AACA,uF;AACA,iG;AACA,4D;AACA,kG;AACA,uB;AACA,0F;AACA,uB;AACA,2F;AACA,gC;AACA,2F;AACA,wB;AACA,I;AACA,I;AACA,mE;AACA,8F;AACA,8C;AACA,I;AACA,I;AACA,I;AACA,W;AACA,uB;AACA,wB;AACA,mC;AACA,iD;AACA,iC;AACA,mC;AACA,mC;AACA,4B;AACA,0B;AACA,Y;AACA,I;AACA,K;;;AAGA,oC;AACA,yC;AACA,kD;AACA,8D;AACA,gC;AACA,2B;AACA,2D;AACA,kE;AACA,8D;AACA,kG;AACA,+D;AACA,iC;AACA,4B;AACA,wE;AACA,iG;AACA,gD;AACA,oB;AACA,sE;AACA,qE;AACA,gG;AACA,0D;AACA,sB;AACA,gG;AACA,mB;AACA,6B;AACA,6B;AACA,4C;AACA,oB;AACA,uE;AACA,sE;AACA,mB;AACA,0C;AACA,yD;AACA,mB;AACA,8B;AACA,mB;;;AAGA,K;AACA,wC;AACA,I;AACA,sB;AACA,iB;AACA,c;AACA,K;AACA,iD;AACA,Y;AACA,0C;AACA,yC;AACA,Q;AACA,oB;AACA,uC;AACA,0C;AACA,6B;AACA,uB;AACA,c;AACA,oC;AACA,yB;AACA,kC;AACA,sC;AACA,wC;AACA,wC;AACA,6B;AACA,wC;AACA,O;AACA,M;;AAEA,qC;AACA,oE;;AAEA,oD;AACA,4B;;AAEA,uC;AACA,Q;AACA,K;AACA,G;AACA,qD;;AAEA,K;AACA,Y;AACA,a;;AAEA,G;AACA,mB;AACA,c;AACA,mC;AACA,E;AACA,c;AACA,E;AACA,e;AACA,+H;AACA,E;AACA,+G;AACA,8G;AACA,6D;AACA,E;AACA,mH;AACA,6E;AACA,E;AACA,mF;AACA,oH;AACA,E;AACA,mH;AACA,iH;AACA,oF;AACA,E;AACA,wF;AACA,iE;AACA,qG;AACA,gG;AACA,E;AACA,E;AACA,S;AACA,E;AACA,qB;AACA,mE;AACA,4B;AACA,Y;AACA,E;AACA,Y;AACA,mB;AACA,8B;AACA,oB;AACA,kB;AACA,U;AACA,0G;AACA,wG;AACA,0G;AACA,uF;AACA,W;AACA,mB;AACA,Y;AACA,U;AACA,E;AACA,G;AACA,O;AACA,uC;AACA,+B;;AAEA,mB;AACA,U;AACA,wB;AACA,mB;AACA,wC;AACA,6B;AACA,gC;AACA,iB;AACA,wD;AACA,oD;AACA,4B;AACA,gF;AACA,4D;AACA,qC;AACA,mD;AACA,yD;AACA,S;AACA,wC;AACA,oC;AACA,0B;AACA,sB;AACA,S;AACA,O;AACA,+B;AACA,kD;AACA,0F;AACA,6C;AACA,6C;AACA,wB;AACA,O;AACA,M;AACA,Y;AACA,6B;AACA,+B;AACA,+B;AACA,gC;AACA,M;AACA,kB;AACA,I;;AAEA,kD;AACA,sB;AACA,kE;AACA,+D;AACA,+B;AACA,0B;AACA,kC;AACA,0B;AACA,4B;AACA,uD;AACA,uD;AACA,kB;;AAEA,oD;AACA,oD;;AAEA,4F;AACA,mE;AACA,iB;AACA,qB;AACA,gE;AACA,U;AACA,6B;AACA,gC;AACA,gC;AACA,S;AACA,M;AACA,iE;;AAEA,G;AACA,C;;AAEA,K;AACA,Y;AACA,a;;AAEA,O;AACA,uC;AACA,uC;;AAEA,uB;AACA,U;AACA,wB;AACA,sD;AACA,wB;AACA,wC;AACA,K;AACA,I;AACA,C;;AAEA,K;AACA,Y;AACA,a;;AAEA,O;AACA,uC;AACA,yC;;AAEA,wB;AACA,4B;AACA,C;;;AAGA,K;AACA,Y;AACA,a;;AAEA,0C;AACA,2C;;AAEA,+B;AACA,U;AACA,kB;AACA,wC;AACA,oD;AACA,uD;AACA,mD;AACA,sE;AACA,W;AACA,Q;AACA,K;AACA,G;AACA,C;AACA,iC;;AAEA,K;AACA,Y;AACA,a;;AAEA,O;AACA,uC;AACA,sD;;AAEA,G;AACA,Y;AACA,G;AACA,6F;AACA,+C;AACA,sB;AACA,uB;AACA,+B;AACA,oB;;AAEA,sB;AACA,+B;AACA,iB;AACA,gC;AACA,8C;AACA,sB;AACA,0B;AACA,wB;AACA,wB;;AAEA,qC;AACA,mC;AACA,6C;AACA,uC;AACA,2C;AACA,6B;AACA,6B;AACA,uB;AACA,uB;AACA,2B;AACA,mC;AACA,yB;AACA,uC;AACA,iC;AACA,mC;AACA,uD;AACA,sE;AACA,8D;;AAEA,S;;AAEA,oB;AACA,8D;AACA,oE;AACA,gE;AACA,8D;AACA,8D;AACA,uF;AACA,gD;AACA,2B;AACA,oC;AACA,G;;AAEA,uB;AACA,+D;AACA,wF;AACA,G;;AAEA,sB;;AAEA,0C;AACA,2E;AACA,G;;AAEA,sC;AACA,+D;AACA,6F;AACA,kD;AACA,G;;AAEA,wD;AACA,sC;AACA,yC;AACA,mB;AACA,oB;AACA,G;;AAEA,2D;AACA,sC;;AAEA,yD;AACA,sC;AACA,8B;AACA,8B;AACA,wC;AACA,gE;AACA,8D;AACA,G;;AAEA,uC;AACA,qE;AACA,gD;AACA,0E;AACA,iE;AACA,gG;AACA,4B;AACA,2F;AACA,qD;;AAEA,4C;AACA,4C;AACA,iD;;AAEA,qF;AACA,+B;AACA,S;AACA,mB;AACA,O;AACA,G;;AAEA,+B;;AAEA,4B;AACA,4B;AACA,2C;AACA,+B;AACA,yC;AACA,c;AACA,4C;AACA,+B;AACA,wC;AACA,c;AACA,sC;AACA,sC;AACA,+B;AACA,4D;AACA,c;AACA,K;AACA,2B;AACA,G;;AAEA,2B;AACA,gE;AACA,0B;AACA,qD;AACA,G;;AAEA,2B;AACA,kC;AACA,2B;AACA,oE;AACA,G;;AAEA,wB;AACA,oD;AACA,qD;AACA,e;AACA,gD;AACA,6B;AACA,+D;AACA,K;AACA,gD;AACA,G;;AAEA,4B;AACA,e;AACA,gD;AACA,6B;AACA,qE;AACA,K;AACA,gG;AACA,G;;AAEA,kC;AACA,+B;AACA,oD;AACA,mD;AACA,kD;AACA,O;AACA,G;;AAEA,gC;AACA,6C;AACA,yD;AACA,mB;AACA,mG;AACA,mC;AACA,iD;AACA,2B;AACA,wF;AACA,K;AACA,0B;AACA,mD;AACA,O;AACA,G;;AAEA,uC;AACA,iB;AACA,mE;AACA,qF;AACA,mF;AACA,mF;AACA,oH;AACA,qC;AACA,U;AACA,6C;AACA,mC;AACA,sC;AACA,Y;AACA,0B;AACA,K;AACA,mB;AACA,uB;AACA,e;AACA,G;;AAEA,qB;;AAEA,2B;AACA,2B;;AAEA,gC;AACA,+E;AACA,mF;AACA,yF;AACA,4E;AACA,6E;AACA,8E;;AAEA,oC;AACA,8F;AACA,wF;;AAEA,oB;AACA,G;;AAEA,2B;AACA,+B;AACA,G;;AAEA,8B;AACA,0D;AACA,+G;AACA,G;;AAEA,iC;AACA,iC;AACA,iC;AACA,kC;AACA,kG;AACA,K;AACA,G;;AAEA,gC;AACA,kD;AACA,G;;AAEA,8B;AACA,0C;AACA,mD;AACA,uF;AACA,2B;AACA,G;;AAEA,0C;AACA,oE;AACA,e;AACA,sC;AACA,oC;AACA,sE;AACA,oC;AACA,sE;AACA,K;AACA,oB;AACA,G;;AAEA,sB;;AAEA,8B;AACA,uD;AACA,+C;AACA,gD;AACA,+B;AACA,O;AACA,2D;AACA,mD;AACA,G;;AAEA,gD;AACA,iB;AACA,+D;AACA,gC;AACA,mE;AACA,4B;AACA,8B;AACA,4C;AACA,2C;AACA,K;AACA,G;;AAEA,6B;AACA,8C;AACA,G;;AAEA,4B;AACA,mC;AACA,6C;AACA,8B;AACA,uC;AACA,gG;AACA,iE;AACA,G;;AAEA,4B;AACA,uD;AACA,e;AACA,G;;AAEA,gC;AACA,2B;AACA,+C;AACA,0C;AACA,O;AACA,iC;AACA,G;;AAEA,4B;AACA,qE;AACA,2D;AACA,G;;AAEA,uC;AACA,iE;AACA,sE;AACA,gE;AACA,iE;AACA,sD;AACA,mD;AACA,sD;AACA,4C;AACA,kB;AACA,Y;AACA,iB;AACA,mB;AACA,2C;AACA,qC;AACA,S;AACA,2B;AACA,qC;AACA,yB;AACA,W;AACA,G;;AAEA,kC;AACA,qD;AACA,sE;AACA,0F;AACA,qF;AACA,yE;AACA,qC;AACA,iD;AACA,mC;AACA,8B;AACA,oD;AACA,4B;AACA,qF;AACA,G;;AAEA,qC;AACA,wC;AACA,0C;AACA,+C;AACA,wC;AACA,4C;AACA,8B;AACA,8B;AACA,qC;AACA,+B;AACA,K;AACA,G;;AAEA,8B;AACA,6D;AACA,0D;AACA,8D;AACA,+B;AACA,sE;AACA,iB;AACA,G;;AAEA,0C;AACA,qE;AACA,oD;AACA,G;AACA,C;AACA,kI;;AAEA,K;AACA,Y;AACA,a;;AAEA,G;AACA,mB;AACA,e;AACA,mC;AACA,E;AACA,c;AACA,E;AACA,e;AACA,wH;AACA,8H;AACA,wD;AACA,E;AACA,8C;AACA,E;AACA,sB;AACA,a;AACA,sC;AACA,sC;AACA,sC;AACA,c;AACA,W;AACA,E;AACA,2C;AACA,E;AACA,0B;AACA,sC;AACA,sC;AACA,E;AACA,wI;AACA,yK;AACA,oL;AACA,E;AACA,oC;AACA,E;AACA,qC;AACA,0F;AACA,E;AACA,oC;AACA,E;AACA,gN;AACA,E;AACA,2I;AACA,E;AACA,wD;AACA,E;AACA,wI;AACA,E;AACA,0C;AACA,0C;AACA,sC;AACA,4C;AACA,sC;AACA,E;AACA,iE;AACA,uE;AACA,0E;AACA,qH;AACA,yI;AACA,0H;AACA,gH;AACA,8E;AACA,E;AACA,S;AACA,qB;AACA,yC;AACA,oD;AACA,Y;AACA,6D;AACA,0C;AACA,iD;AACA,oC;AACA,qB;AACA,sB;AACA,+E;AACA,sB;AACA,oB;AACA,wB;AACA,qB;AACA,c;AACA,a;AACA,U;AACA,E;AACA,G;AACA,O;AACA,uC;AACA,iC;;AAEA,iD;AACA,U;AACA,Y;AACA,wC;AACA,yC;AACA,sC;AACA,oC;AACA,sC;AACA,M;AACA,wC;AACA,+C;AACA,e;AACA,8F;AACA,sC;AACA,0B;AACA,4B;AACA,4B;AACA,yC;AACA,6D;AACA,yE;AACA,mD;AACA,qD;AACA,4D;AACA,4B;AACA,0B;AACA,4B;AACA,4B;AACA,qC;AACA,gE;AACA,4E;AACA,mD;AACA,iD;AACA,4D;AACA,4B;AACA,0B;AACA,2B;AACA,+F;AACA,qD;AACA,0B;AACA,kE;AACA,qE;AACA,iB;AACA,uD;AACA,8B;AACA,mC;AACA,kF;AACA,4D;AACA,2B;AACA,gC;AACA,iC;AACA,mF;AACA,sD;AACA,6B;AACA,yD;AACA,qD;AACA,sE;AACA,gE;AACA,8B;AACA,wD;AACA,wD;AACA,2D;AACA,qB;AACA,mD;AACA,yD;AACA,8D;AACA,0C;AACA,uD;AACA,2D;AACA,qC;AACA,8D;AACA,4B;AACA,gC;AACA,2C;AACA,6B;AACA,yD;AACA,qD;AACA,sE;AACA,yD;AACA,yD;AACA,sD;AACA,0C;AACA,wD;AACA,mB;AACA,4B;AACA,2B;AACA,mE;AACA,0B;AACA,0C;AACA,8B;AACA,oD;AACA,oE;AACA,sE;AACA,6C;AACA,4D;AACA,yC;AACA,oC;AACA,+C;AACA,0B;AACA,6E;AACA,sD;AACA,oD;AACA,qD;AACA,oD;AACA,mC;AACA,mC;AACA,Q;AACA,M;AACA,mC;AACA,gC;AACA,2C;AACA,2C;AACA,kC;;AAEA,kD;;AAEA,2B;AACA,gG;AACA,8C;AACA,4F;AACA,uB;AACA,0B;;AAEA,0C;AACA,sD;AACA,mC;AACA,wD;AACA,O;AACA,K;AACA,I;AACA,C;AACA,uD;;AAEA,K;AACA,Y;AACA,a;;AAEA,O;AACA,uC;AACA,yC;;AAEA,mD;AACA,U;AACA,kB;AACA,e;AACA,Y;AACA,8B;AACA,+B;AACA,kC;AACA,M;AACA,uB;AACA,I;AACA,8C;AACA,sB;AACA,iD;AACA,iC;AACA,+C;AACA,iC;AACA,6B;AACA,oG;AACA,uC;AACA,K;AACA,4B;AACA,4C;AACA,K;AACA,2B;AACA,2C;AACA,K;AACA,G;AACA,C;AACA,yD;;AAEA,K;AACA,a;AACA,kvqC;AACA,K;;;AAGA,2B","file":"/packages/angular_angular-material.js","sourcesContent":["/*!\n * Angular Material Design\n * https://github.com/angular/material\n * @license MIT\n * v0.9.7\n */\n(function( window, angular, undefined ){\n\"use strict\";\n\n(function(){\n\"use strict\";\n\nangular.module('ngMaterial', [\"ng\",\"ngAnimate\",\"ngAria\",\"material.core\",\"material.core.gestures\",\"material.core.theming.palette\",\"material.core.theming\",\"material.components.autocomplete\",\"material.components.backdrop\",\"material.components.bottomSheet\",\"material.components.button\",\"material.components.card\",\"material.components.checkbox\",\"material.components.chips\",\"material.components.content\",\"material.components.dialog\",\"material.components.divider\",\"material.components.gridList\",\"material.components.icon\",\"material.components.input\",\"material.components.list\",\"material.components.progressCircular\",\"material.components.progressLinear\",\"material.components.radioButton\",\"material.components.select\",\"material.components.sidenav\",\"material.components.slider\",\"material.components.sticky\",\"material.components.subheader\",\"material.components.swipe\",\"material.components.switch\",\"material.components.toast\",\"material.components.tabs\",\"material.components.toolbar\",\"material.components.tooltip\",\"material.components.whiteframe\"]);\n})();\n(function(){\n\"use strict\";\n\n\n/**\n * Initialization function that validates environment\n * requirements.\n */\nangular\n  .module('material.core', [ 'material.core.gestures', 'material.core.theming' ])\n  .config( MdCoreConfigure );\n\n\nfunction MdCoreConfigure($provide, $mdThemingProvider) {\n\n  $provide.decorator('$$rAF', [\"$delegate\", rAFDecorator]);\n\n  $mdThemingProvider.theme('default')\n    .primaryPalette('indigo')\n    .accentPalette('pink')\n    .warnPalette('red')\n    .backgroundPalette('grey');\n}\nMdCoreConfigure.$inject = [\"$provide\", \"$mdThemingProvider\"];\n\nfunction rAFDecorator( $delegate ) {\n  /**\n   * Use this to throttle events that come in often.\n   * The throttled function will always use the *last* invocation before the\n   * coming frame.\n   *\n   * For example, window resize events that fire many times a second:\n   * If we set to use an raf-throttled callback on window resize, then\n   * our callback will only be fired once per frame, with the last resize\n   * event that happened before that frame.\n   *\n   * @param {function} callback function to debounce\n   */\n  $delegate.throttle = function(cb) {\n    var queueArgs, alreadyQueued, queueCb, context;\n    return function debounced() {\n      queueArgs = arguments;\n      context = this;\n      queueCb = cb;\n      if (!alreadyQueued) {\n        alreadyQueued = true;\n        $delegate(function() {\n          queueCb.apply(context, queueArgs);\n          alreadyQueued = false;\n        });\n      }\n    };\n  };\n  return $delegate;\n}\n\n})();\n(function(){\n\"use strict\";\n\nangular.module('material.core')\n.factory('$mdConstant', MdConstantFactory);\n\nfunction MdConstantFactory($$rAF, $sniffer) {\n\n  var webkit = /webkit/i.test($sniffer.vendorPrefix);\n  function vendorProperty(name) {\n    return webkit ?  ('webkit' + name.charAt(0).toUpperCase() + name.substring(1)) : name;\n  }\n\n  return {\n    KEY_CODE: {\n      ENTER: 13,\n      ESCAPE: 27,\n      SPACE: 32,\n      LEFT_ARROW : 37,\n      UP_ARROW : 38,\n      RIGHT_ARROW : 39,\n      DOWN_ARROW : 40,\n      TAB : 9,\n      BACKSPACE: 8,\n      DELETE: 46\n    },\n    CSS: {\n      /* Constants */\n      TRANSITIONEND: 'transitionend' + (webkit ? ' webkitTransitionEnd' : ''),\n      ANIMATIONEND: 'animationend' + (webkit ? ' webkitAnimationEnd' : ''),\n\n      TRANSFORM: vendorProperty('transform'),\n      TRANSFORM_ORIGIN: vendorProperty('transformOrigin'),\n      TRANSITION: vendorProperty('transition'),\n      TRANSITION_DURATION: vendorProperty('transitionDuration'),\n      ANIMATION_PLAY_STATE: vendorProperty('animationPlayState'),\n      ANIMATION_DURATION: vendorProperty('animationDuration'),\n      ANIMATION_NAME: vendorProperty('animationName'),\n      ANIMATION_TIMING: vendorProperty('animationTimingFunction'),\n      ANIMATION_DIRECTION: vendorProperty('animationDirection')\n    },\n    MEDIA: {\n      'sm': '(max-width: 600px)',\n      'gt-sm': '(min-width: 600px)',\n      'md': '(min-width: 600px) and (max-width: 960px)',\n      'gt-md': '(min-width: 960px)',\n      'lg': '(min-width: 960px) and (max-width: 1200px)',\n      'gt-lg': '(min-width: 1200px)'\n    },\n    MEDIA_PRIORITY: [\n      'gt-lg',\n      'lg',\n      'gt-md',\n      'md',\n      'gt-sm',\n      'sm'\n    ]\n  };\n}\nMdConstantFactory.$inject = [\"$$rAF\", \"$sniffer\"];\n\n})();\n(function(){\n\"use strict\";\n\n  angular\n    .module('material.core')\n    .config( [\"$provide\", function($provide){\n       $provide.decorator('$mdUtil', ['$delegate', function ($delegate){\n           /**\n            * Inject the iterator facade to easily support iteration and accessors\n            * @see iterator below\n            */\n           $delegate.iterator = MdIterator;\n\n           return $delegate;\n         }\n       ]);\n     }]);\n\n  /**\n   * iterator is a list facade to easily support iteration and accessors\n   *\n   * @param items Array list which this iterator will enumerate\n   * @param reloop Boolean enables iterator to consider the list as an endless reloop\n   */\n  function MdIterator(items, reloop) {\n    var trueFn = function() { return true; };\n\n    if (items && !angular.isArray(items)) {\n      items = Array.prototype.slice.call(items);\n    }\n\n    reloop = !!reloop;\n    var _items = items || [ ];\n\n    // Published API\n    return {\n      items: getItems,\n      count: count,\n\n      inRange: inRange,\n      contains: contains,\n      indexOf: indexOf,\n      itemAt: itemAt,\n\n      findBy: findBy,\n\n      add: add,\n      remove: remove,\n\n      first: first,\n      last: last,\n      next: angular.bind(null, findSubsequentItem, false),\n      previous: angular.bind(null, findSubsequentItem, true),\n\n      hasPrevious: hasPrevious,\n      hasNext: hasNext\n\n    };\n\n    /**\n     * Publish copy of the enumerable set\n     * @returns {Array|*}\n     */\n    function getItems() {\n      return [].concat(_items);\n    }\n\n    /**\n     * Determine length of the list\n     * @returns {Array.length|*|number}\n     */\n    function count() {\n      return _items.length;\n    }\n\n    /**\n     * Is the index specified valid\n     * @param index\n     * @returns {Array.length|*|number|boolean}\n     */\n    function inRange(index) {\n      return _items.length && ( index > -1 ) && (index < _items.length );\n    }\n\n    /**\n     * Can the iterator proceed to the next item in the list; relative to\n     * the specified item.\n     *\n     * @param item\n     * @returns {Array.length|*|number|boolean}\n     */\n    function hasNext(item) {\n      return item ? inRange(indexOf(item) + 1) : false;\n    }\n\n    /**\n     * Can the iterator proceed to the previous item in the list; relative to\n     * the specified item.\n     *\n     * @param item\n     * @returns {Array.length|*|number|boolean}\n     */\n    function hasPrevious(item) {\n      return item ? inRange(indexOf(item) - 1) : false;\n    }\n\n    /**\n     * Get item at specified index/position\n     * @param index\n     * @returns {*}\n     */\n    function itemAt(index) {\n      return inRange(index) ? _items[index] : null;\n    }\n\n    /**\n     * Find all elements matching the key/value pair\n     * otherwise return null\n     *\n     * @param val\n     * @param key\n     *\n     * @return array\n     */\n    function findBy(key, val) {\n      return _items.filter(function(item) {\n        return item[key] === val;\n      });\n    }\n\n    /**\n     * Add item to list\n     * @param item\n     * @param index\n     * @returns {*}\n     */\n    function add(item, index) {\n      if ( !item ) return -1;\n\n      if (!angular.isNumber(index)) {\n        index = _items.length;\n      }\n\n      _items.splice(index, 0, item);\n\n      return indexOf(item);\n    }\n\n    /**\n     * Remove item from list...\n     * @param item\n     */\n    function remove(item) {\n      if ( contains(item) ){\n        _items.splice(indexOf(item), 1);\n      }\n    }\n\n    /**\n     * Get the zero-based index of the target item\n     * @param item\n     * @returns {*}\n     */\n    function indexOf(item) {\n      return _items.indexOf(item);\n    }\n\n    /**\n     * Boolean existence check\n     * @param item\n     * @returns {boolean}\n     */\n    function contains(item) {\n      return item && (indexOf(item) > -1);\n    }\n\n    /**\n     * Return first item in the list\n     * @returns {*}\n     */\n    function first() {\n      return _items.length ? _items[0] : null;\n    }\n\n    /**\n     * Return last item in the list...\n     * @returns {*}\n     */\n    function last() {\n      return _items.length ? _items[_items.length - 1] : null;\n    }\n\n    /**\n     * Find the next item. If reloop is true and at the end of the list, it will go back to the\n     * first item. If given, the `validate` callback will be used to determine whether the next item\n     * is valid. If not valid, it will try to find the next item again.\n     *\n     * @param {boolean} backwards Specifies the direction of searching (forwards/backwards)\n     * @param {*} item The item whose subsequent item we are looking for\n     * @param {Function=} validate The `validate` function\n     * @param {integer=} limit The recursion limit\n     *\n     * @returns {*} The subsequent item or null\n     */\n    function findSubsequentItem(backwards, item, validate, limit) {\n      validate = validate || trueFn;\n\n      var curIndex = indexOf(item);\n      while (true) {\n        if (!inRange(curIndex)) return null;\n\n        var nextIndex = curIndex + (backwards ? -1 : 1);\n        var foundItem = null;\n        if (inRange(nextIndex)) {\n          foundItem = _items[nextIndex];\n        } else if (reloop) {\n          foundItem = backwards ? last() : first();\n          nextIndex = indexOf(foundItem);\n        }\n\n        if ((foundItem === null) || (nextIndex === limit)) return null;\n        if (validate(foundItem)) return foundItem;\n\n        if (angular.isUndefined(limit)) limit = nextIndex;\n\n        curIndex = nextIndex;\n      }\n    }\n  }\n\n\n})();\n(function(){\n\"use strict\";\n\nangular.module('material.core')\n.factory('$mdMedia', mdMediaFactory);\n\n/**\n * @ngdoc service\n * @name $mdMedia\n * @module material.core\n *\n * @description\n * `$mdMedia` is used to evaluate whether a given media query is true or false given the\n * current device's screen / window size. The media query will be re-evaluated on resize, allowing\n * you to register a watch.\n *\n * `$mdMedia` also has pre-programmed support for media queries that match the layout breakpoints.\n *  (`sm`, `gt-sm`, `md`, `gt-md`, `lg`, `gt-lg`).\n *\n * @returns {boolean} a boolean representing whether or not the given media query is true or false.\n *\n * @usage\n * <hljs lang=\"js\">\n * app.controller('MyController', function($mdMedia, $scope) {\n *   $scope.$watch(function() { return $mdMedia('lg'); }, function(big) {\n *     $scope.bigScreen = big;\n *   });\n *\n *   $scope.screenIsSmall = $mdMedia('sm');\n *   $scope.customQuery = $mdMedia('(min-width: 1234px)');\n *   $scope.anotherCustom = $mdMedia('max-width: 300px');\n * });\n * </hljs>\n */\n\nfunction mdMediaFactory($mdConstant, $rootScope, $window) {\n  var queries = {};\n  var mqls = {};\n  var results = {};\n  var normalizeCache = {};\n\n  $mdMedia.getResponsiveAttribute = getResponsiveAttribute;\n  $mdMedia.getQuery = getQuery;\n  $mdMedia.watchResponsiveAttributes = watchResponsiveAttributes;\n\n  return $mdMedia;\n\n  function $mdMedia(query) {\n    var validated = queries[query];\n    if (angular.isUndefined(validated)) {\n      validated = queries[query] = validate(query);\n    }\n\n    var result = results[validated];\n    if (angular.isUndefined(result)) {\n      result = add(validated);\n    }\n\n    return result;\n  }\n\n  function validate(query) {\n    return $mdConstant.MEDIA[query] ||\n           ((query.charAt(0) !== '(') ? ('(' + query + ')') : query);\n  }\n\n  function add(query) {\n    var result = mqls[query] = $window.matchMedia(query);\n    result.addListener(onQueryChange);\n    return (results[result.media] = !!result.matches);\n  }\n\n  function onQueryChange(query) {\n    $rootScope.$evalAsync(function() {\n      results[query.media] = !!query.matches;\n    });\n  }\n\n  function getQuery(name) {\n    return mqls[name];\n  }\n\n  function getResponsiveAttribute(attrs, attrName) {\n    for (var i = 0; i < $mdConstant.MEDIA_PRIORITY.length; i++) {\n      var mediaName = $mdConstant.MEDIA_PRIORITY[i];\n      if (!mqls[queries[mediaName]].matches) {\n        continue;\n      }\n\n      var normalizedName = getNormalizedName(attrs, attrName + '-' + mediaName);\n      if (attrs[normalizedName]) {\n        return attrs[normalizedName];\n      }\n    }\n\n    // fallback on unprefixed\n    return attrs[getNormalizedName(attrs, attrName)];\n  }\n\n  function watchResponsiveAttributes(attrNames, attrs, watchFn) {\n    var unwatchFns = [];\n    attrNames.forEach(function(attrName) {\n      var normalizedName = getNormalizedName(attrs, attrName);\n      if (attrs[normalizedName]) {\n        unwatchFns.push(\n            attrs.$observe(normalizedName, angular.bind(void 0, watchFn, null)));\n      }\n\n      for (var mediaName in $mdConstant.MEDIA) {\n        normalizedName = getNormalizedName(attrs, attrName + '-' + mediaName);\n        if (!attrs[normalizedName]) {\n          return;\n        }\n\n        unwatchFns.push(attrs.$observe(normalizedName, angular.bind(void 0, watchFn, mediaName)));\n      }\n    });\n\n    return function unwatch() {\n      unwatchFns.forEach(function(fn) { fn(); })\n    };\n  }\n\n  // Improves performance dramatically\n  function getNormalizedName(attrs, attrName) {\n    return normalizeCache[attrName] ||\n        (normalizeCache[attrName] = attrs.$normalize(attrName));\n  }\n}\nmdMediaFactory.$inject = [\"$mdConstant\", \"$rootScope\", \"$window\"];\n\n})();\n(function(){\n\"use strict\";\n\n/*\n * This var has to be outside the angular factory, otherwise when\n * there are multiple material apps on the same page, each app\n * will create its own instance of this array and the app's IDs\n * will not be unique.\n */\nvar nextUniqueId = ['0','0','0'];\n\nangular.module('material.core')\n.factory('$mdUtil', [\"$cacheFactory\", \"$document\", \"$timeout\", \"$q\", \"$window\", \"$mdConstant\", function($cacheFactory, $document, $timeout, $q, $window, $mdConstant) {\n  var Util;\n\n  function getNode(el) {\n    return el[0] || el;\n  }\n\n  return Util = {\n    now: window.performance ?\n      angular.bind(window.performance, window.performance.now) :\n      Date.now,\n\n    clientRect: function(element, offsetParent, isOffsetRect) {\n      var node = getNode(element);\n      offsetParent = getNode(offsetParent || node.offsetParent || document.body);\n      var nodeRect = node.getBoundingClientRect();\n\n      // The user can ask for an offsetRect: a rect relative to the offsetParent,\n      // or a clientRect: a rect relative to the page\n      var offsetRect = isOffsetRect ?\n        offsetParent.getBoundingClientRect() :\n        { left: 0, top: 0, width: 0, height: 0 };\n      return {\n        left: nodeRect.left - offsetRect.left,\n        top: nodeRect.top - offsetRect.top,\n        width: nodeRect.width,\n        height: nodeRect.height\n      };\n    },\n    offsetRect: function(element, offsetParent) {\n      return Util.clientRect(element, offsetParent, true);\n    },\n    // Disables scroll around the passed element. Goes up the DOM to find a\n    // disableTarget (a md-content that is scrolling, or the body as a fallback)\n    // and uses CSS/JS to prevent it from scrolling\n    disableScrollAround: function(element) {\n      element = element instanceof angular.element ? element[0] : element;\n      var parentEl = element;\n      var disableTarget;\n\n      // Find the highest level scrolling md-content\n      while (parentEl = this.getClosest(parentEl, 'MD-CONTENT', true)) {\n        if (isScrolling(parentEl)) {\n          disableTarget = angular.element(parentEl)[0];\n        }\n      }\n\n      // Default to the body if no scrolling md-content\n      if (!disableTarget) {\n        disableTarget = $document[0].body;\n        if (!isScrolling(disableTarget)) return angular.noop;\n      }\n\n      if (disableTarget.nodeName == 'BODY') {\n        return disableBodyScroll();\n      } else {\n        return disableElementScroll();\n      }\n\n      // Creates a virtual scrolling mask to absorb touchmove, keyboard, scrollbar clicking, and wheel events\n      function disableElementScroll() {\n        var scrollMask = angular.element('<div class=\"md-scroll-mask\"><div class=\"md-scroll-mask-bar\"></div></div>');\n        var computedStyle = $window.getComputedStyle(disableTarget);\n        var disableRect = disableTarget.getBoundingClientRect();\n        var scrollWidth = disableRect.width - disableTarget.clientWidth;\n        applyStyles(scrollMask[0], {\n          zIndex: computedStyle.zIndex == 'auto' ? 2 : computedStyle.zIndex + 1,\n          width: disableRect.width + 'px',\n          height: disableRect.height + 'px',\n          top: disableRect.top + 'px',\n          left: disableRect.left + 'px'\n        });\n        scrollMask[0].firstElementChild.style.width = scrollWidth + 'px';\n        $document[0].body.appendChild(scrollMask[0]);\n\n        scrollMask.on('wheel', preventDefault);\n        scrollMask.on('touchmove', preventDefault);\n        $document.on('keydown', disableKeyNav);\n\n        return function restoreScroll() {\n          scrollMask.off('wheel');\n          scrollMask.off('touchmove');\n          scrollMask[0].parentNode.removeChild(scrollMask[0]);\n          $document.off('keydown', disableKeyNav);\n        };\n\n        // Prevent keypresses from elements inside the disableTarget\n        // used to stop the keypresses that could cause the page to scroll\n        // (arrow keys, spacebar, tab, etc).\n        function disableKeyNav(e) {\n          if (disableTarget.contains(e.target)) {\n            e.preventDefault();\n            e.stopImmediatePropagation();\n          }\n        }\n\n        function preventDefault(e) {\n          e.preventDefault();\n        }\n      }\n\n      // Converts the disableTarget (body) to a position fixed block and translate it to the propper scroll position\n      function disableBodyScroll() {\n        var restoreStyle = disableTarget.getAttribute('style') || '';\n        var scrollOffset = disableTarget.scrollTop;\n\n        applyStyles(disableTarget, {\n          position: 'fixed',\n          width: '100%',\n          overflowY: 'scroll',\n          top: -scrollOffset + 'px'\n        });\n\n        return function restoreScroll() {\n          disableTarget.setAttribute('style', restoreStyle);\n          disableTarget.scrollTop = scrollOffset;\n        };\n      }\n\n      function applyStyles (el, styles) {\n        for (var key in styles) {\n          el.style[key] = styles[key];\n        }\n      }\n\n      function isScrolling(el) {\n        if (el instanceof angular.element) el = el[0];\n        return el.scrollHeight > el.offsetHeight;\n      }\n    },\n\n    floatingScrollbars: function() {\n      if (this.floatingScrollbars.cached === undefined) {\n        var tempNode = angular.element('<div style=\"width: 100%; z-index: -1; position: absolute; height: 35px; overflow-y: scroll\"><div style=\"height: 60;\"></div></div>');\n        $document[0].body.appendChild(tempNode[0]);\n        this.floatingScrollbars.cached = (tempNode[0].offsetWidth == tempNode[0].childNodes[0].offsetWidth);\n        tempNode.remove();\n      }\n      return this.floatingScrollbars.cached;\n    },\n\n    // Mobile safari only allows you to set focus in click event listeners...\n    forceFocus: function(element) {\n      var node = element[0] || element;\n\n      document.addEventListener('click', function focusOnClick(ev) {\n        if (ev.target === node && ev.$focus) {\n          node.focus();\n          ev.stopImmediatePropagation();\n          ev.preventDefault();\n          node.removeEventListener('click', focusOnClick);\n        }\n      }, true);\n\n      var newEvent = document.createEvent('MouseEvents');\n      newEvent.initMouseEvent('click', false, true, window, {}, 0, 0, 0, 0,\n                       false, false, false, false, 0, null);\n      newEvent.$material = true;\n      newEvent.$focus = true;\n      node.dispatchEvent(newEvent);\n    },\n\n    transitionEndPromise: function(element, opts) {\n      opts = opts || {};\n      var deferred = $q.defer();\n      element.on($mdConstant.CSS.TRANSITIONEND, finished);\n      function finished(ev) {\n        // Make sure this transitionend didn't bubble up from a child\n        if (!ev || ev.target === element[0]) {\n          element.off($mdConstant.CSS.TRANSITIONEND, finished);\n          deferred.resolve();\n        }\n      }\n      if (opts.timeout) $timeout(finished, opts.timeout);\n      return deferred.promise;\n    },\n\n    fakeNgModel: function() {\n      return {\n        $fake: true,\n        $setTouched: angular.noop,\n        $setViewValue: function(value) {\n          this.$viewValue = value;\n          this.$render(value);\n          this.$viewChangeListeners.forEach(function(cb) { cb(); });\n        },\n        $isEmpty: function(value) {\n          return ('' + value).length === 0;\n        },\n        $parsers: [],\n        $formatters: [],\n        $viewChangeListeners: [],\n        $render: angular.noop\n      };\n    },\n\n    // Returns a function, that, as long as it continues to be invoked, will not\n    // be triggered. The function will be called after it stops being called for\n    // N milliseconds.\n    // @param wait Integer value of msecs to delay (since last debounce reset); default value 10 msecs\n    // @param invokeApply should the $timeout trigger $digest() dirty checking\n    debounce: function (func, wait, scope, invokeApply) {\n      var timer;\n\n      return function debounced() {\n        var context = scope,\n          args = Array.prototype.slice.call(arguments);\n\n        $timeout.cancel(timer);\n        timer = $timeout(function() {\n\n          timer = undefined;\n          func.apply(context, args);\n\n        }, wait || 10, invokeApply );\n      };\n    },\n\n    // Returns a function that can only be triggered every `delay` milliseconds.\n    // In other words, the function will not be called unless it has been more\n    // than `delay` milliseconds since the last call.\n    throttle: function throttle(func, delay) {\n      var recent;\n      return function throttled() {\n        var context = this;\n        var args = arguments;\n        var now = Util.now();\n\n        if (!recent || (now - recent > delay)) {\n          func.apply(context, args);\n          recent = now;\n        }\n      };\n    },\n\n    /**\n     * Measures the number of milliseconds taken to run the provided callback\n     * function. Uses a high-precision timer if available.\n     */\n    time: function time(cb) {\n      var start = Util.now();\n      cb();\n      return Util.now() - start;\n    },\n\n    /**\n     * nextUid, from angular.js.\n     * A consistent way of creating unique IDs in angular. The ID is a sequence of alpha numeric\n     * characters such as '012ABC'. The reason why we are not using simply a number counter is that\n     * the number string gets longer over time, and it can also overflow, where as the nextId\n     * will grow much slower, it is a string, and it will never overflow.\n     *\n     * @returns an unique alpha-numeric string\n     */\n    nextUid: function() {\n      var index = nextUniqueId.length;\n      var digit;\n\n      while (index) {\n        index--;\n        digit = nextUniqueId[index].charCodeAt(0);\n        if (digit == 57 /*'9'*/) {\n          nextUniqueId[index] = 'A';\n          return nextUniqueId.join('');\n        }\n        if (digit == 90  /*'Z'*/) {\n          nextUniqueId[index] = '0';\n        } else {\n          nextUniqueId[index] = String.fromCharCode(digit + 1);\n          return nextUniqueId.join('');\n        }\n      }\n      nextUniqueId.unshift('0');\n      return nextUniqueId.join('');\n    },\n\n    // Stop watchers and events from firing on a scope without destroying it,\n    // by disconnecting it from its parent and its siblings' linked lists.\n    disconnectScope: function disconnectScope(scope) {\n      if (!scope) return;\n\n      // we can't destroy the root scope or a scope that has been already destroyed\n      if (scope.$root === scope) return;\n      if (scope.$$destroyed ) return;\n\n      var parent = scope.$parent;\n      scope.$$disconnected = true;\n\n      // See Scope.$destroy\n      if (parent.$$childHead === scope) parent.$$childHead = scope.$$nextSibling;\n      if (parent.$$childTail === scope) parent.$$childTail = scope.$$prevSibling;\n      if (scope.$$prevSibling) scope.$$prevSibling.$$nextSibling = scope.$$nextSibling;\n      if (scope.$$nextSibling) scope.$$nextSibling.$$prevSibling = scope.$$prevSibling;\n\n      scope.$$nextSibling = scope.$$prevSibling = null;\n\n    },\n\n    // Undo the effects of disconnectScope above.\n    reconnectScope: function reconnectScope(scope) {\n      if (!scope) return;\n\n      // we can't disconnect the root node or scope already disconnected\n      if (scope.$root === scope) return;\n      if (!scope.$$disconnected) return;\n\n      var child = scope;\n\n      var parent = child.$parent;\n      child.$$disconnected = false;\n      // See Scope.$new for this logic...\n      child.$$prevSibling = parent.$$childTail;\n      if (parent.$$childHead) {\n        parent.$$childTail.$$nextSibling = child;\n        parent.$$childTail = child;\n      } else {\n        parent.$$childHead = parent.$$childTail = child;\n      }\n    },\n\n    /*\n     * getClosest replicates jQuery.closest() to walk up the DOM tree until it finds a matching nodeName\n     *\n     * @param el Element to start walking the DOM from\n     * @param tagName Tag name to find closest to el, such as 'form'\n     */\n    getClosest: function getClosest(el, tagName, onlyParent) {\n      if (el instanceof angular.element) el = el[0];\n      tagName = tagName.toUpperCase();\n      if (onlyParent) el = el.parentNode;\n      if (!el) return null;\n      do {\n        if (el.nodeName === tagName) {\n          return el;\n        }\n      } while (el = el.parentNode);\n      return null;\n    },\n\n    /**\n     * Functional equivalent for $element.filter(‘md-bottom-sheet’)\n     * useful with interimElements where the element and its container are important...\n     */\n    extractElementByName: function (element, nodeName) {\n      for (var i = 0, len = element.length; i < len; i++) {\n        if (element[i].nodeName.toLowerCase() === nodeName){\n          return angular.element(element[i]);\n        }\n      }\n      return element;\n    },\n\n    /**\n     * Give optional properties with no value a boolean true by default\n     */\n    initOptionalProperties: function (scope, attr, defaults ) {\n       defaults = defaults || { };\n       angular.forEach(scope.$$isolateBindings, function (binding, key) {\n         if (binding.optional && angular.isUndefined(scope[key])) {\n           var hasKey = attr.hasOwnProperty(attr.$normalize(binding.attrName));\n\n           scope[key] = angular.isDefined(defaults[key]) ? defaults[key] : hasKey;\n         }\n       });\n    }\n\n  };\n\n}]);\n\n/*\n * Since removing jQuery from the demos, some code that uses `element.focus()` is broken.\n *\n * We need to add `element.focus()`, because it's testable unlike `element[0].focus`.\n *\n * TODO(ajoslin): This should be added in a better place later.\n */\n\nangular.element.prototype.focus = angular.element.prototype.focus || function() {\n  if (this.length) {\n    this[0].focus();\n  }\n  return this;\n};\nangular.element.prototype.blur = angular.element.prototype.blur || function() {\n  if (this.length) {\n    this[0].blur();\n  }\n  return this;\n};\n\n})();\n(function(){\n\"use strict\";\n\n\nangular.module('material.core')\n  .service('$mdAria', AriaService);\n\n/*\n * @ngInject\n */\nfunction AriaService($$rAF, $log, $window) {\n\n  return {\n    expect: expect,\n    expectAsync: expectAsync,\n    expectWithText: expectWithText\n  };\n\n  /**\n   * Check if expected attribute has been specified on the target element or child\n   * @param element\n   * @param attrName\n   * @param {optional} defaultValue What to set the attr to if no value is found\n   */\n  function expect(element, attrName, defaultValue) {\n    var node = element[0] || element;\n\n    // if node exists and neither it nor its children have the attribute\n    if (node &&\n       ((!node.hasAttribute(attrName) ||\n        node.getAttribute(attrName).length === 0) &&\n        !childHasAttribute(node, attrName))) {\n\n      defaultValue = angular.isString(defaultValue) ? defaultValue.trim() : '';\n      if (defaultValue.length) {\n        element.attr(attrName, defaultValue);\n      } else {\n        $log.warn('ARIA: Attribute \"', attrName, '\", required for accessibility, is missing on node:', node);\n      }\n\n    }\n  }\n\n  function expectAsync(element, attrName, defaultValueGetter) {\n    // Problem: when retrieving the element's contents synchronously to find the label,\n    // the text may not be defined yet in the case of a binding.\n    // There is a higher chance that a binding will be defined if we wait one frame.\n    $$rAF(function() {\n      expect(element, attrName, defaultValueGetter());\n    });\n  }\n\n  function expectWithText(element, attrName) {\n    expectAsync(element, attrName, function() {\n      return getText(element);\n    });\n  }\n\n  function getText(element) {\n    return element.text().trim();\n  }\n\n  function childHasAttribute(node, attrName) {\n    var hasChildren = node.hasChildNodes(),\n        hasAttr = false;\n\n    function isHidden(el) {\n      var style = el.currentStyle ? el.currentStyle : $window.getComputedStyle(el);\n      return (style.display === 'none');\n    }\n\n    if(hasChildren) {\n      var children = node.childNodes;\n      for(var i=0; i<children.length; i++){\n        var child = children[i];\n        if(child.nodeType === 1 && child.hasAttribute(attrName)) {\n          if(!isHidden(child)){\n            hasAttr = true;\n          }\n        }\n      }\n    }\n    return hasAttr;\n  }\n}\nAriaService.$inject = [\"$$rAF\", \"$log\", \"$window\"];\n\n})();\n(function(){\n\"use strict\";\n\nangular.module('material.core')\n  .service('$mdCompiler', mdCompilerService);\n\nfunction mdCompilerService($q, $http, $injector, $compile, $controller, $templateCache) {\n  /* jshint validthis: true */\n\n  /*\n   * @ngdoc service\n   * @name $mdCompiler\n   * @module material.core\n   * @description\n   * The $mdCompiler service is an abstraction of angular's compiler, that allows the developer\n   * to easily compile an element with a templateUrl, controller, and locals.\n   *\n   * @usage\n   * <hljs lang=\"js\">\n   * $mdCompiler.compile({\n   *   templateUrl: 'modal.html',\n   *   controller: 'ModalCtrl',\n   *   locals: {\n   *     modal: myModalInstance;\n   *   }\n   * }).then(function(compileData) {\n   *   compileData.element; // modal.html's template in an element\n   *   compileData.link(myScope); //attach controller & scope to element\n   * });\n   * </hljs>\n   */\n\n   /*\n    * @ngdoc method\n    * @name $mdCompiler#compile\n    * @description A helper to compile an HTML template/templateUrl with a given controller,\n    * locals, and scope.\n    * @param {object} options An options object, with the following properties:\n    *\n    *    - `controller` - `{(string=|function()=}` Controller fn that should be associated with\n    *      newly created scope or the name of a registered controller if passed as a string.\n    *    - `controllerAs` - `{string=}` A controller alias name. If present the controller will be\n    *      published to scope under the `controllerAs` name.\n    *    - `template` - `{string=}` An html template as a string.\n    *    - `templateUrl` - `{string=}` A path to an html template.\n    *    - `transformTemplate` - `{function(template)=}` A function which transforms the template after\n    *      it is loaded. It will be given the template string as a parameter, and should\n    *      return a a new string representing the transformed template.\n    *    - `resolve` - `{Object.<string, function>=}` - An optional map of dependencies which should\n    *      be injected into the controller. If any of these dependencies are promises, the compiler\n    *      will wait for them all to be resolved, or if one is rejected before the controller is\n    *      instantiated `compile()` will fail..\n    *      * `key` - `{string}`: a name of a dependency to be injected into the controller.\n    *      * `factory` - `{string|function}`: If `string` then it is an alias for a service.\n    *        Otherwise if function, then it is injected and the return value is treated as the\n    *        dependency. If the result is a promise, it is resolved before its value is \n    *        injected into the controller.\n    *\n    * @returns {object=} promise A promise, which will be resolved with a `compileData` object.\n    * `compileData` has the following properties: \n    *\n    *   - `element` - `{element}`: an uncompiled element matching the provided template.\n    *   - `link` - `{function(scope)}`: A link function, which, when called, will compile\n    *     the element and instantiate the provided controller (if given).\n    *   - `locals` - `{object}`: The locals which will be passed into the controller once `link` is\n    *     called. If `bindToController` is true, they will be coppied to the ctrl instead\n    *   - `bindToController` - `bool`: bind the locals to the controller, instead of passing them in.\n    */\n  this.compile = function(options) {\n    var templateUrl = options.templateUrl;\n    var template = options.template || '';\n    var controller = options.controller;\n    var controllerAs = options.controllerAs;\n    var resolve = options.resolve || {};\n    var locals = options.locals || {};\n    var transformTemplate = options.transformTemplate || angular.identity;\n    var bindToController = options.bindToController;\n\n    // Take resolve values and invoke them.  \n    // Resolves can either be a string (value: 'MyRegisteredAngularConst'),\n    // or an invokable 'factory' of sorts: (value: function ValueGetter($dependency) {})\n    angular.forEach(resolve, function(value, key) {\n      if (angular.isString(value)) {\n        resolve[key] = $injector.get(value);\n      } else {\n        resolve[key] = $injector.invoke(value);\n      }\n    });\n    //Add the locals, which are just straight values to inject\n    //eg locals: { three: 3 }, will inject three into the controller\n    angular.extend(resolve, locals);\n\n    if (templateUrl) {\n      resolve.$template = $http.get(templateUrl, {cache: $templateCache})\n        .then(function(response) {\n          return response.data;\n        });\n    } else {\n      resolve.$template = $q.when(template);\n    }\n\n    // Wait for all the resolves to finish if they are promises\n    return $q.all(resolve).then(function(locals) {\n\n      var template = transformTemplate(locals.$template);\n      var element = options.element || angular.element('<div>').html(template.trim()).contents();\n      var linkFn = $compile(element);\n\n      //Return a linking function that can be used later when the element is ready\n      return {\n        locals: locals,\n        element: element,\n        link: function link(scope) {\n          locals.$scope = scope;\n\n          //Instantiate controller if it exists, because we have scope\n          if (controller) {\n            var invokeCtrl = $controller(controller, locals, true);\n            if (bindToController) {\n              angular.extend(invokeCtrl.instance, locals);\n            }\n            var ctrl = invokeCtrl();\n            //See angular-route source for this logic\n            element.data('$ngControllerController', ctrl);\n            element.children().data('$ngControllerController', ctrl);\n\n            if (controllerAs) {\n              scope[controllerAs] = ctrl;\n            }\n          }\n          return linkFn(scope);\n        }\n      };\n    });\n\n  };\n}\nmdCompilerService.$inject = [\"$q\", \"$http\", \"$injector\", \"$compile\", \"$controller\", \"$templateCache\"];\n\n})();\n(function(){\n\"use strict\";\n\n  var HANDLERS = {};\n  /* The state of the current 'pointer'\n   * The pointer represents the state of the current touch.\n   * It contains normalized x and y coordinates from DOM events,\n   * as well as other information abstracted from the DOM.\n   */\n  var pointer, lastPointer, forceSkipClickHijack = false;\n\n  // Used to attach event listeners once when multiple ng-apps are running.\n  var isInitialized = false;\n  \n  angular\n    .module('material.core.gestures', [ ])\n    .provider('$mdGesture', MdGestureProvider)\n    .factory('$$MdGestureHandler', MdGestureHandler)\n    .run( attachToDocument );\n\n  /**\n     * @ngdoc service\n     * @name $mdGestureProvider\n     * @module material.core.gestures\n     *\n     * @description\n     * In some scenarios on Mobile devices (without jQuery), the click events should NOT be hijacked.\n     * `$mdGestureProvider` is used to configure the Gesture module to ignore or skip click hijacking on mobile\n     * devices.\n     *\n     * <hljs lang=\"js\">\n     *   app.config(function($mdGestureProvider) {\n     *\n     *     // For mobile devices without jQuery loaded, do not\n     *     // intercept click events during the capture phase.\n     *     $mdGestureProvider.skipClickHijack();\n     *\n     *   });\n     * </hljs>\n     *\n     */\n  function MdGestureProvider() { }\n\n  MdGestureProvider.prototype = {\n\n    // Publish access to setter to configure a variable  BEFORE the\n    // $mdGesture service is instantiated...\n    skipClickHijack: function() {\n      return forceSkipClickHijack = true;\n    },\n\n    /**\n     * $get is used to build an instance of $mdGesture\n     * @ngInject\n     */\n    $get : [\"$$MdGestureHandler\", \"$$rAF\", \"$timeout\", function($$MdGestureHandler, $$rAF, $timeout) {\n         return new MdGesture($$MdGestureHandler, $$rAF, $timeout);\n    }]\n  };\n\n\n\n  /**\n   * MdGesture factory construction function\n   * @ngInject\n   */\n  function MdGesture($$MdGestureHandler, $$rAF, $timeout) {\n    var userAgent = navigator.userAgent || navigator.vendor || window.opera;\n    var isIos = userAgent.match(/ipad|iphone|ipod/i);\n    var isAndroid = userAgent.match(/android/i);\n    var hasJQuery =  (typeof window.jQuery !== 'undefined') && (angular.element === window.jQuery);\n\n    var self = {\n      handler: addHandler,\n      register: register,\n      // On mobile w/out jQuery, we normally intercept clicks. Should we skip that?\n      isHijackingClicks: (isIos || isAndroid) && !hasJQuery && !forceSkipClickHijack\n    };\n\n    if (self.isHijackingClicks) {\n      self.handler('click', {\n        options: {\n          maxDistance: 6\n        },\n        onEnd: function (ev, pointer) {\n          if (pointer.distance < this.state.options.maxDistance) {\n            this.dispatchEvent(ev, 'click');\n          }\n        }\n      });\n    }\n\n    /*\n     * Register an element to listen for a handler.\n     * This allows an element to override the default options for a handler.\n     * Additionally, some handlers like drag and hold only dispatch events if\n     * the domEvent happens inside an element that's registered to listen for these events.\n     *\n     * @see GestureHandler for how overriding of default options works.\n     * @example $mdGesture.register(myElement, 'drag', { minDistance: 20, horziontal: false })\n     */\n    function register(element, handlerName, options) {\n      var handler = HANDLERS[handlerName.replace(/^\\$md./, '')];\n      if (!handler) {\n        throw new Error('Failed to register element with handler ' + handlerName + '. ' +\n        'Available handlers: ' + Object.keys(HANDLERS).join(', '));\n      }\n      return handler.registerElement(element, options);\n    }\n\n    /*\n     * add a handler to $mdGesture. see below.\n     */\n    function addHandler(name, definition) {\n      var handler = new $$MdGestureHandler(name);\n      angular.extend(handler, definition);\n      HANDLERS[name] = handler;\n\n      return self;\n    }\n\n    /*\n     * Register handlers. These listen to touch/start/move events, interpret them,\n     * and dispatch gesture events depending on options & conditions. These are all\n     * instances of GestureHandler.\n     * @see GestureHandler \n     */\n    return self\n      /*\n       * The press handler dispatches an event on touchdown/touchend.\n       * It's a simple abstraction of touch/mouse/pointer start and end.\n       */\n      .handler('press', {\n        onStart: function (ev, pointer) {\n          this.dispatchEvent(ev, '$md.pressdown');\n        },\n        onEnd: function (ev, pointer) {\n          this.dispatchEvent(ev, '$md.pressup');\n        }\n      })\n\n      /*\n       * The hold handler dispatches an event if the user keeps their finger within\n       * the same <maxDistance> area for <delay> ms.\n       * The hold handler will only run if a parent of the touch target is registered\n       * to listen for hold events through $mdGesture.register()\n       */\n      .handler('hold', {\n        options: {\n          maxDistance: 6,\n          delay: 500\n        },\n        onCancel: function () {\n          $timeout.cancel(this.state.timeout);\n        },\n        onStart: function (ev, pointer) {\n          // For hold, require a parent to be registered with $mdGesture.register()\n          // Because we prevent scroll events, this is necessary.\n          if (!this.state.registeredParent) return this.cancel();\n\n          this.state.pos = {x: pointer.x, y: pointer.y};\n          this.state.timeout = $timeout(angular.bind(this, function holdDelayFn() {\n            this.dispatchEvent(ev, '$md.hold');\n            this.cancel(); //we're done!\n          }), this.state.options.delay, false);\n        },\n        onMove: function (ev, pointer) {\n          // Don't scroll while waiting for hold.\n          // If we don't preventDefault touchmove events here, Android will assume we don't\n          // want to listen to anymore touch events. It will start scrolling and stop sending\n          // touchmove events.\n          ev.preventDefault();\n\n          // If the user moves greater than <maxDistance> pixels, stop the hold timer\n          // set in onStart\n          var dx = this.state.pos.x - pointer.x;\n          var dy = this.state.pos.y - pointer.y;\n          if (Math.sqrt(dx * dx + dy * dy) > this.options.maxDistance) {\n            this.cancel();\n          }\n        },\n        onEnd: function () {\n          this.onCancel();\n        }\n      })\n\n      /*\n       * The drag handler dispatches a drag event if the user holds and moves his finger greater than\n       * <minDistance> px in the x or y direction, depending on options.horizontal.\n       * The drag will be cancelled if the user moves his finger greater than <minDistance>*<cancelMultiplier> in\n       * the perpindicular direction. Eg if the drag is horizontal and the user moves his finger <minDistance>*<cancelMultiplier>\n       * pixels vertically, this handler won't consider the move part of a drag.\n       */\n      .handler('drag', {\n        options: {\n          minDistance: 6,\n          horizontal: true,\n          cancelMultiplier: 1.5\n        },\n        onStart: function (ev) {\n          // For drag, require a parent to be registered with $mdGesture.register()\n          if (!this.state.registeredParent) this.cancel();\n        },\n        onMove: function (ev, pointer) {\n          var shouldStartDrag, shouldCancel;\n          // Don't scroll while deciding if this touchmove qualifies as a drag event.\n          // If we don't preventDefault touchmove events here, Android will assume we don't\n          // want to listen to anymore touch events. It will start scrolling and stop sending\n          // touchmove events.\n          ev.preventDefault();\n\n          if (!this.state.dragPointer) {\n            if (this.state.options.horizontal) {\n              shouldStartDrag = Math.abs(pointer.distanceX) > this.state.options.minDistance;\n              shouldCancel = Math.abs(pointer.distanceY) > this.state.options.minDistance * this.state.options.cancelMultiplier;\n            } else {\n              shouldStartDrag = Math.abs(pointer.distanceY) > this.state.options.minDistance;\n              shouldCancel = Math.abs(pointer.distanceX) > this.state.options.minDistance * this.state.options.cancelMultiplier;\n            }\n\n            if (shouldStartDrag) {\n              // Create a new pointer representing this drag, starting at this point where the drag started.\n              this.state.dragPointer = makeStartPointer(ev);\n              updatePointerState(ev, this.state.dragPointer);\n              this.dispatchEvent(ev, '$md.dragstart', this.state.dragPointer);\n\n            } else if (shouldCancel) {\n              this.cancel();\n            }\n          } else {\n            this.dispatchDragMove(ev);\n          }\n        },\n        // Only dispatch dragmove events every frame; any more is unnecessray\n        dispatchDragMove: $$rAF.throttle(function (ev) {\n          // Make sure the drag didn't stop while waiting for the next frame\n          if (this.state.isRunning) {\n            updatePointerState(ev, this.state.dragPointer);\n            this.dispatchEvent(ev, '$md.drag', this.state.dragPointer);\n          }\n        }),\n        onEnd: function (ev, pointer) {\n          if (this.state.dragPointer) {\n            updatePointerState(ev, this.state.dragPointer);\n            this.dispatchEvent(ev, '$md.dragend', this.state.dragPointer);\n          }\n        }\n      })\n\n      /*\n       * The swipe handler will dispatch a swipe event if, on the end of a touch,\n       * the velocity and distance were high enough.\n       * TODO: add vertical swiping with a `horizontal` option similar to the drag handler.\n       */\n      .handler('swipe', {\n        options: {\n          minVelocity: 0.65,\n          minDistance: 10\n        },\n        onEnd: function (ev, pointer) {\n          if (Math.abs(pointer.velocityX) > this.state.options.minVelocity &&\n            Math.abs(pointer.distanceX) > this.state.options.minDistance) {\n            var eventType = pointer.directionX == 'left' ? '$md.swipeleft' : '$md.swiperight';\n            this.dispatchEvent(ev, eventType);\n          }\n        }\n      });\n\n  }\n  MdGesture.$inject = [\"$$MdGestureHandler\", \"$$rAF\", \"$timeout\"];\n\n  /**\n   * MdGestureHandler\n   * A GestureHandler is an object which is able to dispatch custom dom events\n   * based on native dom {touch,pointer,mouse}{start,move,end} events.\n   *\n   * A gesture will manage its lifecycle through the start,move,end, and cancel\n   * functions, which are called by native dom events.\n   *\n   * A gesture has the concept of 'options' (eg a swipe's required velocity), which can be\n   * overridden by elements registering through $mdGesture.register()\n   */\n  function GestureHandler (name) {\n    this.name = name;\n    this.state = {};\n  }\n\n  function MdGestureHandler() {\n    var hasJQuery =  (typeof window.jQuery !== 'undefined') && (angular.element === window.jQuery);\n\n    GestureHandler.prototype = {\n      options: {},\n      // jQuery listeners don't work with custom DOMEvents, so we have to dispatch events\n      // differently when jQuery is loaded\n      dispatchEvent: hasJQuery ?  jQueryDispatchEvent : nativeDispatchEvent,\n\n      // These are overridden by the registered handler\n      onStart: angular.noop,\n      onMove: angular.noop,\n      onEnd: angular.noop,\n      onCancel: angular.noop,\n\n      // onStart sets up a new state for the handler, which includes options from the\n      // nearest registered parent element of ev.target.\n      start: function (ev, pointer) {\n        if (this.state.isRunning) return;\n        var parentTarget = this.getNearestParent(ev.target);\n        // Get the options from the nearest registered parent\n        var parentTargetOptions = parentTarget && parentTarget.$mdGesture[this.name] || {};\n\n        this.state = {\n          isRunning: true,\n          // Override the default options with the nearest registered parent's options\n          options: angular.extend({}, this.options, parentTargetOptions),\n          // Pass in the registered parent node to the state so the onStart listener can use\n          registeredParent: parentTarget\n        };\n        this.onStart(ev, pointer);\n      },\n      move: function (ev, pointer) {\n        if (!this.state.isRunning) return;\n        this.onMove(ev, pointer);\n      },\n      end: function (ev, pointer) {\n        if (!this.state.isRunning) return;\n        this.onEnd(ev, pointer);\n        this.state.isRunning = false;\n      },\n      cancel: function (ev, pointer) {\n        this.onCancel(ev, pointer);\n        this.state = {};\n      },\n\n      // Find and return the nearest parent element that has been registered to\n      // listen for this handler via $mdGesture.register(element, 'handlerName').\n      getNearestParent: function (node) {\n        var current = node;\n        while (current) {\n          if ((current.$mdGesture || {})[this.name]) {\n            return current;\n          }\n          current = current.parentNode;\n        }\n        return null;\n      },\n\n      // Called from $mdGesture.register when an element reigsters itself with a handler.\n      // Store the options the user gave on the DOMElement itself. These options will\n      // be retrieved with getNearestParent when the handler starts.\n      registerElement: function (element, options) {\n        var self = this;\n        element[0].$mdGesture = element[0].$mdGesture || {};\n        element[0].$mdGesture[this.name] = options || {};\n        element.on('$destroy', onDestroy);\n\n        return onDestroy;\n\n        function onDestroy() {\n          delete element[0].$mdGesture[self.name];\n          element.off('$destroy', onDestroy);\n        }\n      }\n    };\n\n    return GestureHandler;\n\n    /*\n     * Dispatch an event with jQuery\n     * TODO: Make sure this sends bubbling events\n     *\n     * @param srcEvent the original DOM touch event that started this.\n     * @param eventType the name of the custom event to send (eg 'click' or '$md.drag')\n     * @param eventPointer the pointer object that matches this event.\n     */\n    function jQueryDispatchEvent(srcEvent, eventType, eventPointer) {\n      eventPointer = eventPointer || pointer;\n      var eventObj = new angular.element.Event(eventType);\n\n      eventObj.$material = true;\n      eventObj.pointer = eventPointer;\n      eventObj.srcEvent = srcEvent;\n\n      angular.extend(eventObj, {\n        clientX: eventPointer.x,\n        clientY: eventPointer.y,\n        screenX: eventPointer.x,\n        screenY: eventPointer.y,\n        pageX: eventPointer.x,\n        pageY: eventPointer.y,\n        ctrlKey: srcEvent.ctrlKey,\n        altKey: srcEvent.altKey,\n        shiftKey: srcEvent.shiftKey,\n        metaKey: srcEvent.metaKey\n      });\n      angular.element(eventPointer.target).trigger(eventObj);\n    }\n\n    /*\n     * NOTE: nativeDispatchEvent is very performance sensitive.\n     * @param srcEvent the original DOM touch event that started this.\n     * @param eventType the name of the custom event to send (eg 'click' or '$md.drag')\n     * @param eventPointer the pointer object that matches this event.\n     */\n    function nativeDispatchEvent(srcEvent, eventType, eventPointer) {\n      eventPointer = eventPointer || pointer;\n      var eventObj;\n\n      if (eventType === 'click') {\n        eventObj = document.createEvent('MouseEvents');\n        eventObj.initMouseEvent(\n          'click', true, true, window, srcEvent.detail,\n          eventPointer.x, eventPointer.y, eventPointer.x, eventPointer.y,\n          srcEvent.ctrlKey, srcEvent.altKey, srcEvent.shiftKey, srcEvent.metaKey,\n          srcEvent.button, srcEvent.relatedTarget || null\n        );\n\n      } else {\n        eventObj = document.createEvent('CustomEvent');\n        eventObj.initCustomEvent(eventType, true, true, {});\n      }\n      eventObj.$material = true;\n      eventObj.pointer = eventPointer;\n      eventObj.srcEvent = srcEvent;\n      eventPointer.target.dispatchEvent(eventObj);\n    }\n\n  }\n\n  /**\n   * Attach Gestures: hook document and check shouldHijack clicks\n   * @ngInject\n   */\n  function attachToDocument( $mdGesture, $$MdGestureHandler ) {\n\n    // Polyfill document.contains for IE11.\n    // TODO: move to util\n    document.contains || (document.contains = function (node) {\n      return document.body.contains(node);\n    });\n\n    if (!isInitialized && $mdGesture.isHijackingClicks ) {\n      /*\n       * If hijack clicks is true, we preventDefault any click that wasn't\n       * sent by ngMaterial. This is because on older Android & iOS, a false, or 'ghost',\n       * click event will be sent ~400ms after a touchend event happens.\n       * The only way to know if this click is real is to prevent any normal\n       * click events, and add a flag to events sent by material so we know not to prevent those.\n       * \n       * Two exceptions to click events that should be prevented are:\n       *  - click events sent by the keyboard (eg form submit)\n       *  - events that originate from an Ionic app\n       */\n      document.addEventListener('click', function clickHijacker(ev) {\n        var isKeyClick = ev.clientX === 0 && ev.clientY === 0;\n        if (!isKeyClick && !ev.$material && !ev.isIonicTap) {\n          ev.preventDefault();\n          ev.stopPropagation();\n        }\n      }, true);\n      \n      isInitialized = true;\n    }\n\n    // Listen to all events to cover all platforms.\n    var START_EVENTS = 'mousedown touchstart pointerdown';\n    var MOVE_EVENTS = 'mousemove touchmove pointermove';\n    var END_EVENTS = 'mouseup mouseleave touchend touchcancel pointerup pointercancel';\n\n    angular.element(document)\n      .on(START_EVENTS, gestureStart)\n      .on(MOVE_EVENTS, gestureMove)\n      .on(END_EVENTS, gestureEnd)\n      // For testing\n      .on('$$mdGestureReset', function gestureClearCache () {\n        lastPointer = pointer = null;\n      });\n\n    /*\n     * When a DOM event happens, run all registered gesture handlers' lifecycle\n     * methods which match the DOM event.\n     * Eg when a 'touchstart' event happens, runHandlers('start') will call and\n     * run `handler.cancel()` and `handler.start()` on all registered handlers.\n     */\n    function runHandlers(handlerEvent, event) {\n      var handler;\n      for (var name in HANDLERS) {\n        handler = HANDLERS[name];\n        if( handler instanceof $$MdGestureHandler ) {\n\n          if (handlerEvent === 'start') {\n            // Run cancel to reset any handlers' state\n            handler.cancel();\n          }\n          handler[handlerEvent](event, pointer);\n\n        }\n      }\n    }\n\n    /*\n     * gestureStart vets if a start event is legitimate (and not part of a 'ghost click' from iOS/Android)\n     * If it is legitimate, we initiate the pointer state and mark the current pointer's type\n     * For example, for a touchstart event, mark the current pointer as a 'touch' pointer, so mouse events\n     * won't effect it.\n     */\n    function gestureStart(ev) {\n      // If we're already touched down, abort\n      if (pointer) return;\n\n      var now = +Date.now();\n\n      // iOS & old android bug: after a touch event, a click event is sent 350 ms later.\n      // If <400ms have passed, don't allow an event of a different type than the previous event\n      if (lastPointer && !typesMatch(ev, lastPointer) && (now - lastPointer.endTime < 1500)) {\n        return;\n      }\n\n      pointer = makeStartPointer(ev);\n\n      runHandlers('start', ev);\n    }\n    /*\n     * If a move event happens of the right type, update the pointer and run all the move handlers.\n     * \"of the right type\": if a mousemove happens but our pointer started with a touch event, do nothing.\n     */\n    function gestureMove(ev) {\n      if (!pointer || !typesMatch(ev, pointer)) return;\n\n      updatePointerState(ev, pointer);\n      runHandlers('move', ev);\n    }\n    /*\n     * If an end event happens of the right type, update the pointer, run endHandlers, and save the pointer as 'lastPointer'\n     */\n    function gestureEnd(ev) {\n      if (!pointer || !typesMatch(ev, pointer)) return;\n\n      updatePointerState(ev, pointer);\n      pointer.endTime = +Date.now();\n\n      runHandlers('end', ev);\n\n      lastPointer = pointer;\n      pointer = null;\n    }\n\n  }\n  attachToDocument.$inject = [\"$mdGesture\", \"$$MdGestureHandler\"];\n\n  // ********************\n  // Module Functions\n  // ********************\n\n  /*\n   * Initiate the pointer. x, y, and the pointer's type.\n   */\n  function makeStartPointer(ev) {\n    var point = getEventPoint(ev);\n    var startPointer = {\n      startTime: +Date.now(),\n      target: ev.target,\n      // 'p' for pointer events, 'm' for mouse, 't' for touch\n      type: ev.type.charAt(0)\n    };\n    startPointer.startX = startPointer.x = point.pageX;\n    startPointer.startY = startPointer.y = point.pageY;\n    return startPointer;\n  }\n\n  /*\n   * return whether the pointer's type matches the event's type.\n   * Eg if a touch event happens but the pointer has a mouse type, return false.\n   */\n  function typesMatch(ev, pointer) {\n    return ev && pointer && ev.type.charAt(0) === pointer.type;\n  }\n\n  /*\n   * Update the given pointer based upon the given DOMEvent.\n   * Distance, velocity, direction, duration, etc\n   */\n  function updatePointerState(ev, pointer) {\n    var point = getEventPoint(ev);\n    var x = pointer.x = point.pageX;\n    var y = pointer.y = point.pageY;\n\n    pointer.distanceX = x - pointer.startX;\n    pointer.distanceY = y - pointer.startY;\n    pointer.distance = Math.sqrt(\n      pointer.distanceX * pointer.distanceX + pointer.distanceY * pointer.distanceY\n    );\n\n    pointer.directionX = pointer.distanceX > 0 ? 'right' : pointer.distanceX < 0 ? 'left' : '';\n    pointer.directionY = pointer.distanceY > 0 ? 'up' : pointer.distanceY < 0 ? 'down' : '';\n\n    pointer.duration = +Date.now() - pointer.startTime;\n    pointer.velocityX = pointer.distanceX / pointer.duration;\n    pointer.velocityY = pointer.distanceY / pointer.duration;\n  }\n\n  /*\n   * Normalize the point where the DOM event happened whether it's touch or mouse.\n   * @returns point event obj with pageX and pageY on it.\n   */\n  function getEventPoint(ev) {\n    ev = ev.originalEvent || ev; // support jQuery events\n    return (ev.touches && ev.touches[0]) ||\n      (ev.changedTouches && ev.changedTouches[0]) ||\n      ev;\n  }\n\n})();\n(function(){\n\"use strict\";\n\nangular.module('material.core')\n  .provider('$$interimElement', InterimElementProvider);\n\n/*\n * @ngdoc service\n * @name $$interimElement\n * @module material.core\n *\n * @description\n *\n * Factory that contructs `$$interimElement.$service` services.\n * Used internally in material design for elements that appear on screen temporarily.\n * The service provides a promise-like API for interacting with the temporary\n * elements.\n *\n * ```js\n * app.service('$mdToast', function($$interimElement) {\n *   var $mdToast = $$interimElement(toastDefaultOptions);\n *   return $mdToast;\n * });\n * ```\n * @param {object=} defaultOptions Options used by default for the `show` method on the service.\n *\n * @returns {$$interimElement.$service}\n *\n */\n\nfunction InterimElementProvider() {\n  createInterimElementProvider.$get = InterimElementFactory;\n  InterimElementFactory.$inject = [\"$document\", \"$q\", \"$rootScope\", \"$timeout\", \"$rootElement\", \"$animate\", \"$interpolate\", \"$mdCompiler\", \"$mdTheming\"];\n  return createInterimElementProvider;\n\n  /**\n   * Returns a new provider which allows configuration of a new interimElement\n   * service. Allows configuration of default options & methods for options,\n   * as well as configuration of 'preset' methods (eg dialog.basic(): basic is a preset method)\n   */\n  function createInterimElementProvider(interimFactoryName) {\n    var EXPOSED_METHODS = ['onHide', 'onShow', 'onRemove'];\n\n    var customMethods = {};\n    var providerConfig = {\n      presets: {}\n    };\n\n    var provider = {\n      setDefaults: setDefaults,\n      addPreset: addPreset,\n      addMethod: addMethod,\n      $get: factory\n    };\n\n    /**\n     * all interim elements will come with the 'build' preset\n     */\n    provider.addPreset('build', {\n      methods: ['controller', 'controllerAs', 'resolve',\n        'template', 'templateUrl', 'themable', 'transformTemplate', 'parent']\n    });\n\n    factory.$inject = [\"$$interimElement\", \"$animate\", \"$injector\"];\n    return provider;\n\n    /**\n     * Save the configured defaults to be used when the factory is instantiated\n     */\n    function setDefaults(definition) {\n      providerConfig.optionsFactory = definition.options;\n      providerConfig.methods = (definition.methods || []).concat(EXPOSED_METHODS);\n      return provider;\n    }\n\n    /**\n     * Add a method to the factory that isn't specific to any interim element operations\n     */\n\n    function addMethod(name, fn) {\n      customMethods[name] = fn;\n      return provider;\n    }\n\n    /**\n     * Save the configured preset to be used when the factory is instantiated\n     */\n    function addPreset(name, definition) {\n      definition = definition || {};\n      definition.methods = definition.methods || [];\n      definition.options = definition.options || function() { return {}; };\n\n      if (/^cancel|hide|show$/.test(name)) {\n        throw new Error(\"Preset '\" + name + \"' in \" + interimFactoryName + \" is reserved!\");\n      }\n      if (definition.methods.indexOf('_options') > -1) {\n        throw new Error(\"Method '_options' in \" + interimFactoryName + \" is reserved!\");\n      }\n      providerConfig.presets[name] = {\n        methods: definition.methods.concat(EXPOSED_METHODS),\n        optionsFactory: definition.options,\n        argOption: definition.argOption\n      };\n      return provider;\n    }\n\n    /**\n     * Create a factory that has the given methods & defaults implementing interimElement\n     */\n    /* @ngInject */\n    function factory($$interimElement, $animate, $injector) {\n      var defaultMethods;\n      var defaultOptions;\n      var interimElementService = $$interimElement();\n\n      /*\n       * publicService is what the developer will be using.\n       * It has methods hide(), cancel(), show(), build(), and any other\n       * presets which were set during the config phase.\n       */\n      var publicService = {\n        hide: interimElementService.hide,\n        cancel: interimElementService.cancel,\n        show: showInterimElement\n      };\n\n      defaultMethods = providerConfig.methods || [];\n      // This must be invoked after the publicService is initialized\n      defaultOptions = invokeFactory(providerConfig.optionsFactory, {});\n\n      // Copy over the simple custom methods\n      angular.forEach(customMethods, function(fn, name) {\n        publicService[name] = fn;\n      });\n\n      angular.forEach(providerConfig.presets, function(definition, name) {\n        var presetDefaults = invokeFactory(definition.optionsFactory, {});\n        var presetMethods = (definition.methods || []).concat(defaultMethods);\n\n        // Every interimElement built with a preset has a field called `$type`,\n        // which matches the name of the preset.\n        // Eg in preset 'confirm', options.$type === 'confirm'\n        angular.extend(presetDefaults, { $type: name });\n\n        // This creates a preset class which has setter methods for every\n        // method given in the `.addPreset()` function, as well as every\n        // method given in the `.setDefaults()` function.\n        //\n        // @example\n        // .setDefaults({\n        //   methods: ['hasBackdrop', 'clickOutsideToClose', 'escapeToClose', 'targetEvent'],\n        //   options: dialogDefaultOptions\n        // })\n        // .addPreset('alert', {\n        //   methods: ['title', 'ok'],\n        //   options: alertDialogOptions\n        // })\n        //\n        // Set values will be passed to the options when interimElemnt.show() is called.\n        function Preset(opts) {\n          this._options = angular.extend({}, presetDefaults, opts);\n        }\n        angular.forEach(presetMethods, function(name) {\n          Preset.prototype[name] = function(value) {\n            this._options[name] = value;\n            return this;\n          };\n        });\n\n        // Create shortcut method for one-linear methods\n        if (definition.argOption) {\n          var methodName = 'show' + name.charAt(0).toUpperCase() + name.slice(1);\n          publicService[methodName] = function(arg) {\n            var config = publicService[name](arg);\n            return publicService.show(config);\n          };\n        }\n\n        // eg $mdDialog.alert() will return a new alert preset\n        publicService[name] = function(arg) {\n          // If argOption is supplied, eg `argOption: 'content'`, then we assume\n          // if the argument is not an options object then it is the `argOption` option.\n          //\n          // @example `$mdToast.simple('hello')` // sets options.content to hello\n          //                                     // because argOption === 'content'\n          if (arguments.length && definition.argOption && !angular.isObject(arg) &&\n              !angular.isArray(arg)) {\n            return (new Preset())[definition.argOption](arg);\n          } else {\n            return new Preset(arg);\n          }\n\n        };\n      });\n\n      return publicService;\n\n      function showInterimElement(opts) {\n        // opts is either a preset which stores its options on an _options field,\n        // or just an object made up of options\n        if (opts && opts._options) opts = opts._options;\n        return interimElementService.show(\n          angular.extend({}, defaultOptions, opts)\n        );\n      }\n\n      /**\n       * Helper to call $injector.invoke with a local of the factory name for\n       * this provider.\n       * If an $mdDialog is providing options for a dialog and tries to inject\n       * $mdDialog, a circular dependency error will happen.\n       * We get around that by manually injecting $mdDialog as a local.\n       */\n      function invokeFactory(factory, defaultVal) {\n        var locals = {};\n        locals[interimFactoryName] = publicService;\n        return $injector.invoke(factory || function() { return defaultVal; }, {}, locals);\n      }\n\n    }\n\n  }\n\n  /* @ngInject */\n  function InterimElementFactory($document, $q, $rootScope, $timeout, $rootElement, $animate,\n                                 $interpolate, $mdCompiler, $mdTheming ) {\n    var startSymbol = $interpolate.startSymbol(),\n        endSymbol = $interpolate.endSymbol(),\n        usesStandardSymbols = ((startSymbol === '{{') && (endSymbol === '}}')),\n        processTemplate  = usesStandardSymbols ? angular.identity : replaceInterpolationSymbols;\n\n    return function createInterimElementService() {\n      /*\n       * @ngdoc service\n       * @name $$interimElement.$service\n       *\n       * @description\n       * A service used to control inserting and removing an element into the DOM.\n       *\n       */\n      var stack = [];\n      var service;\n      return service = {\n        show: show,\n        hide: hide,\n        cancel: cancel\n      };\n\n      /*\n       * @ngdoc method\n       * @name $$interimElement.$service#show\n       * @kind function\n       *\n       * @description\n       * Adds the `$interimElement` to the DOM and returns a promise that will be resolved or rejected\n       * with hide or cancel, respectively.\n       *\n       * @param {*} options is hashMap of settings\n       * @returns a Promise\n       *\n       */\n      function show(options) {\n        if (stack.length) {\n          return service.cancel().then(function() {\n            return show(options);\n          });\n        } else {\n          var interimElement = new InterimElement(options);\n          stack.push(interimElement);\n          return interimElement.show().then(function() {\n            return interimElement.deferred.promise;\n          });\n        }\n      }\n\n      /*\n       * @ngdoc method\n       * @name $$interimElement.$service#hide\n       * @kind function\n       *\n       * @description\n       * Removes the `$interimElement` from the DOM and resolves the promise returned from `show`\n       *\n       * @param {*} resolveParam Data to resolve the promise with\n       * @returns a Promise that will be resolved after the element has been removed.\n       *\n       */\n      function hide(response) {\n        var interimElement = stack.shift();\n        return interimElement && interimElement.remove().then(function() {\n          interimElement.deferred.resolve(response);\n        });\n      }\n\n      /*\n       * @ngdoc method\n       * @name $$interimElement.$service#cancel\n       * @kind function\n       *\n       * @description\n       * Removes the `$interimElement` from the DOM and rejects the promise returned from `show`\n       *\n       * @param {*} reason Data to reject the promise with\n       * @returns Promise that will be resolved after the element has been removed.\n       *\n       */\n      function cancel(reason) {\n        var interimElement = stack.shift();\n        return $q.when(interimElement && interimElement.remove().then(function() {\n          interimElement.deferred.reject(reason);\n        }));\n      }\n\n\n      /*\n       * Internal Interim Element Object\n       * Used internally to manage the DOM element and related data\n       */\n      function InterimElement(options) {\n        var self;\n        var hideTimeout, element, showDone, removeDone;\n\n        options = options || {};\n        options = angular.extend({\n          preserveScope: false,\n          scope: options.scope || $rootScope.$new(options.isolateScope),\n          onShow: function(scope, element, options) {\n            return $animate.enter(element, options.parent);\n          },\n          onRemove: function(scope, element, options) {\n            // Element could be undefined if a new element is shown before\n            // the old one finishes compiling.\n            return element && $animate.leave(element) || $q.when();\n          }\n        }, options);\n\n        if (options.template) {\n          options.template = processTemplate(options.template);\n        }\n\n        return self = {\n          options: options,\n          deferred: $q.defer(),\n          show: function() {\n            var compilePromise;\n            if (options.skipCompile) {\n              compilePromise = $q(function(resolve) { \n                resolve({\n                  locals: {},\n                  link: function() { return options.element; }\n                });\n              });\n            } else {\n              compilePromise = $mdCompiler.compile(options);\n            }\n\n            return showDone = compilePromise.then(function(compileData) {\n              angular.extend(compileData.locals, self.options);\n\n              element = compileData.link(options.scope);\n\n              // Search for parent at insertion time, if not specified\n              if (angular.isFunction(options.parent)) {\n                options.parent = options.parent(options.scope, element, options);\n              } else if (angular.isString(options.parent)) {\n                options.parent = angular.element($document[0].querySelector(options.parent));\n              }\n\n              // If parent querySelector/getter function fails, or it's just null,\n              // find a default.\n              if (!(options.parent || {}).length) {\n                var el;\n                if ($rootElement[0] && $rootElement[0].querySelector) {\n                  el = $rootElement[0].querySelector(':not(svg) > body');\n                }\n                if (!el) el = $rootElement[0];\n                if (el.nodeName == '#comment') {\n                  el = $document[0].body;\n                }\n                options.parent = angular.element(el);\n              }\n\n              if (options.themable) $mdTheming(element);\n              var ret = options.onShow(options.scope, element, options);\n              return $q.when(ret)\n                .then(function(){\n                  // Issue onComplete callback when the `show()` finishes\n                  (options.onComplete || angular.noop)(options.scope, element, options);\n                  startHideTimeout();\n                });\n\n              function startHideTimeout() {\n                if (options.hideDelay) {\n                  hideTimeout = $timeout(service.cancel, options.hideDelay) ;\n                }\n              }\n            }, function(reason) { showDone = true; self.deferred.reject(reason); });\n          },\n          cancelTimeout: function() {\n            if (hideTimeout) {\n              $timeout.cancel(hideTimeout);\n              hideTimeout = undefined;\n            }\n          },\n          remove: function() {\n            self.cancelTimeout();\n            return removeDone = $q.when(showDone).then(function() {\n              var ret = element ? options.onRemove(options.scope, element, options) : true;\n              return $q.when(ret).then(function() {\n                if (!options.preserveScope) options.scope.$destroy();\n                removeDone = true;\n              });\n            });\n          }\n        };\n      }\n    };\n\n    /*\n     * Replace `{{` and `}}` in a string (usually a template) with the actual start-/endSymbols used\n     * for interpolation. This allows pre-defined templates (for components such as dialog, toast etc)\n     * to continue to work in apps that use custom interpolation start-/endSymbols.\n     *\n     * @param {string} text The text in which to replace `{{` / `}}`\n     * @returns {string} The modified string using the actual interpolation start-/endSymbols\n     */\n    function replaceInterpolationSymbols(text) {\n      if (!text || !angular.isString(text)) return text;\n      return text.replace(/\\{\\{/g, startSymbol).replace(/}}/g, endSymbol);\n    }\n  }\n\n}\n\n})();\n(function(){\n\"use strict\";\n\n  /**\n   * @ngdoc module\n   * @name material.core.componentRegistry\n   *\n   * @description\n   * A component instance registration service.\n   * Note: currently this as a private service in the SideNav component.\n   */\n  angular.module('material.core')\n    .factory('$mdComponentRegistry', ComponentRegistry);\n\n  /*\n   * @private\n   * @ngdoc factory\n   * @name ComponentRegistry\n   * @module material.core.componentRegistry\n   *\n   */\n  function ComponentRegistry($log, $q) {\n\n    var self;\n    var instances = [ ];\n    var pendings = { };\n\n    return self = {\n      /**\n       * Used to print an error when an instance for a handle isn't found.\n       */\n      notFoundError: function(handle) {\n        $log.error('No instance found for handle', handle);\n      },\n      /**\n       * Return all registered instances as an array.\n       */\n      getInstances: function() {\n        return instances;\n      },\n\n      /**\n       * Get a registered instance.\n       * @param handle the String handle to look up for a registered instance.\n       */\n      get: function(handle) {\n        if ( !isValidID(handle) ) return null;\n\n        var i, j, instance;\n        for(i = 0, j = instances.length; i < j; i++) {\n          instance = instances[i];\n          if(instance.$$mdHandle === handle) {\n            return instance;\n          }\n        }\n        return null;\n      },\n\n      /**\n       * Register an instance.\n       * @param instance the instance to register\n       * @param handle the handle to identify the instance under.\n       */\n      register: function(instance, handle) {\n        if ( !handle ) return angular.noop;\n\n        instance.$$mdHandle = handle;\n        instances.push(instance);\n        resolveWhen();\n\n        return deregister;\n\n        /**\n         * Remove registration for an instance\n         */\n        function deregister() {\n          var index = instances.indexOf(instance);\n          if (index !== -1) {\n            instances.splice(index, 1);\n          }\n        }\n\n        /**\n         * Resolve any pending promises for this instance\n         */\n        function resolveWhen() {\n          var dfd = pendings[handle];\n          if ( dfd ) {\n            dfd.resolve( instance );\n            delete pendings[handle];\n          }\n        }\n      },\n\n      /**\n       * Async accessor to registered component instance\n       * If not available then a promise is created to notify\n       * all listeners when the instance is registered.\n       */\n      when : function(handle) {\n        if ( isValidID(handle) ) {\n          var deferred = $q.defer();\n          var instance = self.get(handle);\n\n          if ( instance )  {\n            deferred.resolve( instance );\n          } else {\n            pendings[handle] = deferred;\n          }\n\n          return deferred.promise;\n        }\n        return $q.reject(\"Invalid `md-component-id` value.\");\n      }\n\n    };\n\n    function isValidID(handle){\n      return handle && (handle !== \"\");\n    }\n\n  }\n  ComponentRegistry.$inject = [\"$log\", \"$q\"];\n\n})();\n(function(){\n\"use strict\";\n\n(function() {\n  'use strict';\n\n  /**\n   * @ngdoc service\n   * @name $mdButtonInkRipple\n   * @module material.core\n   *\n   * @description\n   * Provides ripple effects for md-button.  See $mdInkRipple service for all possible configuration options.\n   *\n   * @param {object=} scope Scope within the current context\n   * @param {object=} element The element the ripple effect should be applied to\n   * @param {object=} options (Optional) Configuration options to override the defaultripple configuration\n   */\n\n  angular.module('material.core')\n    .factory('$mdButtonInkRipple', MdButtonInkRipple);\n\n  function MdButtonInkRipple($mdInkRipple) {\n    return {\n      attach: attach\n    };\n\n    function attach(scope, element, options) {\n      var elementOptions = optionsForElement(element);\n      return $mdInkRipple.attach(scope, element, angular.extend(elementOptions, options));\n    };\n\n    function optionsForElement(element) {\n      if (element.hasClass('md-icon-button')) {\n        return {\n          isMenuItem: element.hasClass('md-menu-item'),\n          fitRipple: true,\n          center: true\n        };\n      } else {\n        return {\n          isMenuItem: element.hasClass('md-menu-item'),\n          dimBackground: true\n        }\n      }\n    };\n  }\n  MdButtonInkRipple.$inject = [\"$mdInkRipple\"];;\n})();\n\n})();\n(function(){\n\"use strict\";\n\n(function() {\n  'use strict';\n\n    /**\n   * @ngdoc service\n   * @name $mdCheckboxInkRipple\n   * @module material.core\n   *\n   * @description\n   * Provides ripple effects for md-checkbox.  See $mdInkRipple service for all possible configuration options.\n   *\n   * @param {object=} scope Scope within the current context\n   * @param {object=} element The element the ripple effect should be applied to\n   * @param {object=} options (Optional) Configuration options to override the defaultripple configuration\n   */\n\n  angular.module('material.core')\n    .factory('$mdCheckboxInkRipple', MdCheckboxInkRipple);\n\n  function MdCheckboxInkRipple($mdInkRipple) {\n    return {\n      attach: attach\n    };\n\n    function attach(scope, element, options) {\n      return $mdInkRipple.attach(scope, element, angular.extend({\n        center: true,\n        dimBackground: false,\n        fitRipple: true\n      }, options));\n    };\n  }\n  MdCheckboxInkRipple.$inject = [\"$mdInkRipple\"];;\n})();\n\n})();\n(function(){\n\"use strict\";\n\n(function() {\n  'use strict';\n\n  /**\n   * @ngdoc service\n   * @name $mdListInkRipple\n   * @module material.core\n   *\n   * @description\n   * Provides ripple effects for md-list.  See $mdInkRipple service for all possible configuration options.\n   *\n   * @param {object=} scope Scope within the current context\n   * @param {object=} element The element the ripple effect should be applied to\n   * @param {object=} options (Optional) Configuration options to override the defaultripple configuration\n   */\n\n  angular.module('material.core')\n    .factory('$mdListInkRipple', MdListInkRipple);\n\n  function MdListInkRipple($mdInkRipple) {\n    return {\n      attach: attach\n    };\n\n    function attach(scope, element, options) {\n      return $mdInkRipple.attach(scope, element, angular.extend({\n        center: false,\n        dimBackground: true,\n        outline: false,\n        rippleSize: 'full'\n      }, options));\n    };\n  }\n  MdListInkRipple.$inject = [\"$mdInkRipple\"];;\n})();\n\n})();\n(function(){\n\"use strict\";\n\nangular.module('material.core')\n  .factory('$mdInkRipple', InkRippleService)\n  .directive('mdInkRipple', InkRippleDirective)\n  .directive('mdNoInk', attrNoDirective())\n  .directive('mdNoBar', attrNoDirective())\n  .directive('mdNoStretch', attrNoDirective());\n\nfunction InkRippleDirective($mdButtonInkRipple, $mdCheckboxInkRipple) {\n  return {\n    controller: angular.noop,\n    link: function (scope, element, attr) {\n      if (attr.hasOwnProperty('mdInkRippleCheckbox')) {\n        $mdCheckboxInkRipple.attach(scope, element);\n      } else {\n        $mdButtonInkRipple.attach(scope, element);\n      }\n    }\n  };\n}\nInkRippleDirective.$inject = [\"$mdButtonInkRipple\", \"$mdCheckboxInkRipple\"];\n\nfunction InkRippleService($window, $timeout) {\n\n  return {\n    attach: attach\n  };\n\n  function attach(scope, element, options) {\n    if (element.controller('mdNoInk')) return angular.noop;\n\n    options = angular.extend({\n      colorElement: element,\n      mousedown: true,\n      hover: true,\n      focus: true,\n      center: false,\n      mousedownPauseTime: 150,\n      dimBackground: false,\n      outline: false,\n      fullRipple: true,\n      isMenuItem: false,\n      fitRipple: false\n    }, options);\n\n    var rippleSize,\n        controller = element.controller('mdInkRipple') || {},\n        counter = 0,\n        ripples = [],\n        states = [],\n        isActiveExpr = element.attr('md-highlight'),\n        isActive = false,\n        isHeld = false,\n        node = element[0],\n        rippleSizeSetting = element.attr('md-ripple-size'),\n        color = parseColor(element.attr('md-ink-ripple')) || parseColor(options.colorElement.length && $window.getComputedStyle(options.colorElement[0]).color || 'rgb(0, 0, 0)');\n\n    switch (rippleSizeSetting) {\n      case 'full':\n        options.fullRipple = true;\n        break;\n      case 'partial':\n        options.fullRipple = false;\n        break;\n    }\n\n    // expose onInput for ripple testing\n    if (options.mousedown) {\n      element.on('$md.pressdown', onPressDown)\n        .on('$md.pressup', onPressUp);\n    }\n\n    controller.createRipple = createRipple;\n\n    if (isActiveExpr) {\n      scope.$watch(isActiveExpr, function watchActive(newValue) {\n        isActive = newValue;\n        if (isActive && !ripples.length) {\n          $timeout(function () { createRipple(0, 0); }, 0, false);\n        }\n        angular.forEach(ripples, updateElement);\n      });\n    }\n\n    // Publish self-detach method if desired...\n    return function detach() {\n      element.off('$md.pressdown', onPressDown)\n        .off('$md.pressup', onPressUp);\n      getRippleContainer().remove();\n    };\n\n    /**\n     * Gets the current ripple container\n     * If there is no ripple container, it creates one and returns it\n     *\n     * @returns {angular.element} ripple container element\n     */\n    function getRippleContainer() {\n      var container = element.data('$mdRippleContainer');\n      if (container) return container;\n      container = angular.element('<div class=\"md-ripple-container\">');\n      element.append(container);\n      element.data('$mdRippleContainer', container);\n      return container;\n    }\n\n    function parseColor(color) {\n      if (!color) return;\n      if (color.indexOf('rgba') === 0) return color.replace(/\\d?\\.?\\d*\\s*\\)\\s*$/, '0.1)');\n      if (color.indexOf('rgb')  === 0) return rgbToRGBA(color);\n      if (color.indexOf('#')    === 0) return hexToRGBA(color);\n\n      /**\n       * Converts a hex value to an rgba string\n       *\n       * @param {string} hex value (3 or 6 digits) to be converted\n       *\n       * @returns {string} rgba color with 0.1 alpha\n       */\n      function hexToRGBA(color) {\n        var hex = color.charAt(0) === '#' ? color.substr(1) : color,\n          dig = hex.length / 3,\n          red = hex.substr(0, dig),\n          grn = hex.substr(dig, dig),\n          blu = hex.substr(dig * 2);\n        if (dig === 1) {\n          red += red;\n          grn += grn;\n          blu += blu;\n        }\n        return 'rgba(' + parseInt(red, 16) + ',' + parseInt(grn, 16) + ',' + parseInt(blu, 16) + ',0.1)';\n      }\n\n      /**\n       * Converts rgb value to rgba string\n       *\n       * @param {string} rgb color string\n       *\n       * @returns {string} rgba color with 0.1 alpha\n       */\n      function rgbToRGBA(color) {\n        return color.replace(')', ', 0.1)').replace('(', 'a(');\n      }\n\n    }\n\n    function removeElement(elem, wait) {\n      ripples.splice(ripples.indexOf(elem), 1);\n      if (ripples.length === 0) {\n        getRippleContainer().css({ backgroundColor: '' });\n      }\n      $timeout(function () { elem.remove(); }, wait, false);\n    }\n\n    function updateElement(elem) {\n      var index = ripples.indexOf(elem),\n          state = states[index] || {},\n          elemIsActive = ripples.length > 1 ? false : isActive,\n          elemIsHeld   = ripples.length > 1 ? false : isHeld;\n      if (elemIsActive || state.animating || elemIsHeld) {\n        elem.addClass('md-ripple-visible');\n      } else if (elem) {\n        elem.removeClass('md-ripple-visible');\n        if (options.outline) {\n          elem.css({\n            width: rippleSize + 'px',\n            height: rippleSize + 'px',\n            marginLeft: (rippleSize * -1) + 'px',\n            marginTop: (rippleSize * -1) + 'px'\n          });\n        }\n        removeElement(elem, options.outline ? 450 : 650);\n      }\n    }\n\n    /**\n     * Creates a ripple at the provided coordinates\n     *\n     * @param {number} left cursor position\n     * @param {number} top cursor position\n     *\n     * @returns {angular.element} the generated ripple element\n     */\n    function createRipple(left, top) {\n\n      color = parseColor(element.attr('md-ink-ripple')) || parseColor($window.getComputedStyle(options.colorElement[0]).color || 'rgb(0, 0, 0)');\n\n      var container = getRippleContainer(),\n          size = getRippleSize(left, top),\n          css = getRippleCss(size, left, top),\n          elem = getRippleElement(css),\n          index = ripples.indexOf(elem),\n          state = states[index] || {};\n\n      rippleSize = size;\n\n      state.animating = true;\n\n      $timeout(function () {\n        if (options.dimBackground) {\n          container.css({ backgroundColor: color });\n        }\n        elem.addClass('md-ripple-placed md-ripple-scaled');\n        if (options.outline) {\n          elem.css({\n            borderWidth: (size * 0.5) + 'px',\n            marginLeft: (size * -0.5) + 'px',\n            marginTop: (size * -0.5) + 'px'\n          });\n        } else {\n          elem.css({ left: '50%', top: '50%' });\n        }\n        updateElement(elem);\n        $timeout(function () {\n          state.animating = false;\n          updateElement(elem);\n        }, (options.outline ? 450 : 225), false);\n      }, 0, false);\n\n      return elem;\n\n      /**\n       * Creates the ripple element with the provided css\n       *\n       * @param {object} css properties to be applied\n       *\n       * @returns {angular.element} the generated ripple element\n       */\n      function getRippleElement(css) {\n        var elem = angular.element('<div class=\"md-ripple\" data-counter=\"' + counter++ + '\">');\n        ripples.unshift(elem);\n        states.unshift({ animating: true });\n        container.append(elem);\n        css && elem.css(css);\n        return elem;\n      }\n\n      /**\n       * Calculate the ripple size\n       *\n       * @returns {number} calculated ripple diameter\n       */\n      function getRippleSize(left, top) {\n        var width = container.prop('offsetWidth'),\n            height = container.prop('offsetHeight'),\n            multiplier, size, rect;\n        if (options.isMenuItem) {\n          size = Math.sqrt(Math.pow(width, 2) + Math.pow(height, 2));\n        } else if (options.outline) {\n          rect = node.getBoundingClientRect();\n          left -= rect.left;\n          top -= rect.top;\n          width = Math.max(left, width - left);\n          height = Math.max(top, height - top);\n          size = 2 * Math.sqrt(Math.pow(width, 2) + Math.pow(height, 2));\n        } else {\n          multiplier = options.fullRipple ? 1.1 : 0.8;\n          size = Math.sqrt(Math.pow(width, 2) + Math.pow(height, 2)) * multiplier;\n          if (options.fitRipple) {\n            size = Math.min(height, width, size);\n          }\n        }\n        return size;\n      }\n\n      /**\n       * Generates the ripple css\n       *\n       * @param {number} the diameter of the ripple\n       * @param {number} the left cursor offset\n       * @param {number} the top cursor offset\n       *\n       * @returns {{backgroundColor: string, borderColor: string, width: string, height: string}}\n       */\n      function getRippleCss(size, left, top) {\n        var rect = node.getBoundingClientRect(),\n            css  = {\n              backgroundColor: rgbaToRGB(color),\n              borderColor: rgbaToRGB(color),\n              width: size + 'px',\n              height: size + 'px'\n            };\n\n        if (options.outline) {\n          css.width = 0;\n          css.height = 0;\n        } else {\n          css.marginLeft = css.marginTop = (size * -0.5) + 'px';\n        }\n\n        if (options.center) {\n          css.left = css.top = '50%';\n        } else {\n          css.left = Math.round((left - rect.left) / container.prop('offsetWidth') * 100) + '%';\n          css.top = Math.round((top - rect.top) / container.prop('offsetHeight') * 100) + '%';\n        }\n\n        return css;\n\n        /**\n         * Converts rgba string to rgb, removing the alpha value\n         *\n         * @param {string} rgba color\n         *\n         * @returns {string} rgb color\n         */\n        function rgbaToRGB(color) {\n          return color.replace('rgba', 'rgb').replace(/,[^\\),]+\\)/, ')');\n        }\n      }\n    }\n\n    /**\n     * Handles user input start and stop events\n     *\n     */\n    function onPressDown(ev) {\n      if (!isRippleAllowed()) return;\n\n      createRipple(ev.pointer.x, ev.pointer.y);\n      isHeld = true;\n    }\n    function onPressUp() {\n      isHeld = false;\n      var ripple = ripples[ ripples.length - 1 ];\n      $timeout(function () { updateElement(ripple); }, 0, false);\n    }\n\n    /**\n     * Determines if the ripple is allowed\n     *\n     * @returns {boolean} true if the ripple is allowed, false if not\n     */\n    function isRippleAllowed() {\n      var parent = node.parentNode;\n      var grandparent = parent && parent.parentNode;\n      var ancestor = grandparent && grandparent.parentNode;\n      return !isDisabled(node) && !isDisabled(parent) && !isDisabled(grandparent) && !isDisabled(ancestor);\n      function isDisabled (elem) {\n        return elem && elem.hasAttribute && elem.hasAttribute('disabled');\n      }\n    }\n\n  }\n}\nInkRippleService.$inject = [\"$window\", \"$timeout\"];\n\n/**\n * noink/nobar/nostretch directive: make any element that has one of\n * these attributes be given a controller, so that other directives can\n * `require:` these and see if there is a `no<xxx>` parent attribute.\n *\n * @usage\n * <hljs lang=\"html\">\n * <parent md-no-ink>\n *   <child detect-no>\n *   </child>\n * </parent>\n * </hljs>\n *\n * <hljs lang=\"js\">\n * myApp.directive('detectNo', function() {\n *   return {\n *     require: ['^?mdNoInk', ^?mdNoBar'],\n *     link: function(scope, element, attr, ctrls) {\n *       var noinkCtrl = ctrls[0];\n *       var nobarCtrl = ctrls[1];\n *       if (noInkCtrl) {\n *         alert(\"the md-no-ink flag has been specified on an ancestor!\");\n *       }\n *       if (nobarCtrl) {\n *         alert(\"the md-no-bar flag has been specified on an ancestor!\");\n *       }\n *     }\n *   };\n * });\n * </hljs>\n */\nfunction attrNoDirective() {\n  return function() {\n    return {\n      controller: angular.noop\n    };\n  };\n}\n\n})();\n(function(){\n\"use strict\";\n\n(function() {\n  'use strict';\n\n    /**\n   * @ngdoc service\n   * @name $mdTabInkRipple\n   * @module material.core\n   *\n   * @description\n   * Provides ripple effects for md-tabs.  See $mdInkRipple service for all possible configuration options.\n   *\n   * @param {object=} scope Scope within the current context\n   * @param {object=} element The element the ripple effect should be applied to\n   * @param {object=} options (Optional) Configuration options to override the defaultripple configuration\n   */\n\n  angular.module('material.core')\n    .factory('$mdTabInkRipple', MdTabInkRipple);\n\n  function MdTabInkRipple($mdInkRipple) {\n    return {\n      attach: attach\n    };\n\n    function attach(scope, element, options) {\n      return $mdInkRipple.attach(scope, element, angular.extend({\n        center: false,\n        dimBackground: true,\n        outline: false,\n        rippleSize: 'full'\n      }, options));\n    };\n  }\n  MdTabInkRipple.$inject = [\"$mdInkRipple\"];;\n})();\n\n})();\n(function(){\n\"use strict\";\n\nangular.module('material.core.theming.palette', [])\n.constant('$mdColorPalette', {\n  'red': {\n    '50': '#ffebee',\n    '100': '#ffcdd2',\n    '200': '#ef9a9a',\n    '300': '#e57373',\n    '400': '#ef5350',\n    '500': '#f44336',\n    '600': '#e53935',\n    '700': '#d32f2f',\n    '800': '#c62828',\n    '900': '#b71c1c',\n    'A100': '#ff8a80',\n    'A200': '#ff5252',\n    'A400': '#ff1744',\n    'A700': '#d50000',\n    'contrastDefaultColor': 'light',\n    'contrastDarkColors': '50 100 200 300 400 A100',\n    'contrastStrongLightColors': '500 600 700 A200 A400 A700'\n  },\n  'pink': {\n    '50': '#fce4ec',\n    '100': '#f8bbd0',\n    '200': '#f48fb1',\n    '300': '#f06292',\n    '400': '#ec407a',\n    '500': '#e91e63',\n    '600': '#d81b60',\n    '700': '#c2185b',\n    '800': '#ad1457',\n    '900': '#880e4f',\n    'A100': '#ff80ab',\n    'A200': '#ff4081',\n    'A400': '#f50057',\n    'A700': '#c51162',\n    'contrastDefaultColor': 'light',\n    'contrastDarkColors': '50 100 200 300 400 A100',\n    'contrastStrongLightColors': '500 600 A200 A400 A700'\n  },\n  'purple': {\n    '50': '#f3e5f5',\n    '100': '#e1bee7',\n    '200': '#ce93d8',\n    '300': '#ba68c8',\n    '400': '#ab47bc',\n    '500': '#9c27b0',\n    '600': '#8e24aa',\n    '700': '#7b1fa2',\n    '800': '#6a1b9a',\n    '900': '#4a148c',\n    'A100': '#ea80fc',\n    'A200': '#e040fb',\n    'A400': '#d500f9',\n    'A700': '#aa00ff',\n    'contrastDefaultColor': 'light',\n    'contrastDarkColors': '50 100 200 A100',\n    'contrastStrongLightColors': '300 400 A200 A400 A700'\n  },\n  'deep-purple': {\n    '50': '#ede7f6',\n    '100': '#d1c4e9',\n    '200': '#b39ddb',\n    '300': '#9575cd',\n    '400': '#7e57c2',\n    '500': '#673ab7',\n    '600': '#5e35b1',\n    '700': '#512da8',\n    '800': '#4527a0',\n    '900': '#311b92',\n    'A100': '#b388ff',\n    'A200': '#7c4dff',\n    'A400': '#651fff',\n    'A700': '#6200ea',\n    'contrastDefaultColor': 'light',\n    'contrastDarkColors': '50 100 200 A100',\n    'contrastStrongLightColors': '300 400 A200'\n  },\n  'indigo': {\n    '50': '#e8eaf6',\n    '100': '#c5cae9',\n    '200': '#9fa8da',\n    '300': '#7986cb',\n    '400': '#5c6bc0',\n    '500': '#3f51b5',\n    '600': '#3949ab',\n    '700': '#303f9f',\n    '800': '#283593',\n    '900': '#1a237e',\n    'A100': '#8c9eff',\n    'A200': '#536dfe',\n    'A400': '#3d5afe',\n    'A700': '#304ffe',\n    'contrastDefaultColor': 'light',\n    'contrastDarkColors': '50 100 200 A100',\n    'contrastStrongLightColors': '300 400 A200 A400'\n  },\n  'blue': {\n    '50': '#e3f2fd',\n    '100': '#bbdefb',\n    '200': '#90caf9',\n    '300': '#64b5f6',\n    '400': '#42a5f5',\n    '500': '#2196f3',\n    '600': '#1e88e5',\n    '700': '#1976d2',\n    '800': '#1565c0',\n    '900': '#0d47a1',\n    'A100': '#82b1ff',\n    'A200': '#448aff',\n    'A400': '#2979ff',\n    'A700': '#2962ff',\n    'contrastDefaultColor': 'light',\n    'contrastDarkColors': '100 200 300 400 A100',\n    'contrastStrongLightColors': '500 600 700 A200 A400 A700'\n  },\n  'light-blue': {\n    '50': '#e1f5fe',\n    '100': '#b3e5fc',\n    '200': '#81d4fa',\n    '300': '#4fc3f7',\n    '400': '#29b6f6',\n    '500': '#03a9f4',\n    '600': '#039be5',\n    '700': '#0288d1',\n    '800': '#0277bd',\n    '900': '#01579b',\n    'A100': '#80d8ff',\n    'A200': '#40c4ff',\n    'A400': '#00b0ff',\n    'A700': '#0091ea',\n    'contrastDefaultColor': 'dark',\n    'contrastLightColors': '500 600 700 800 900 A700',\n    'contrastStrongLightColors': '500 600 700 800 A700'\n  },\n  'cyan': {\n    '50': '#e0f7fa',\n    '100': '#b2ebf2',\n    '200': '#80deea',\n    '300': '#4dd0e1',\n    '400': '#26c6da',\n    '500': '#00bcd4',\n    '600': '#00acc1',\n    '700': '#0097a7',\n    '800': '#00838f',\n    '900': '#006064',\n    'A100': '#84ffff',\n    'A200': '#18ffff',\n    'A400': '#00e5ff',\n    'A700': '#00b8d4',\n    'contrastDefaultColor': 'dark',\n    'contrastLightColors': '500 600 700 800 900',\n    'contrastStrongLightColors': '500 600 700 800'\n  },\n  'teal': {\n    '50': '#e0f2f1',\n    '100': '#b2dfdb',\n    '200': '#80cbc4',\n    '300': '#4db6ac',\n    '400': '#26a69a',\n    '500': '#009688',\n    '600': '#00897b',\n    '700': '#00796b',\n    '800': '#00695c',\n    '900': '#004d40',\n    'A100': '#a7ffeb',\n    'A200': '#64ffda',\n    'A400': '#1de9b6',\n    'A700': '#00bfa5',\n    'contrastDefaultColor': 'dark',\n    'contrastLightColors': '500 600 700 800 900',\n    'contrastStrongLightColors': '500 600 700'\n  },\n  'green': {\n    '50': '#e8f5e9',\n    '100': '#c8e6c9',\n    '200': '#a5d6a7',\n    '300': '#81c784',\n    '400': '#66bb6a',\n    '500': '#4caf50',\n    '600': '#43a047',\n    '700': '#388e3c',\n    '800': '#2e7d32',\n    '900': '#1b5e20',\n    'A100': '#b9f6ca',\n    'A200': '#69f0ae',\n    'A400': '#00e676',\n    'A700': '#00c853',\n    'contrastDefaultColor': 'dark',\n    'contrastLightColors': '500 600 700 800 900',\n    'contrastStrongLightColors': '500 600 700'\n  },\n  'light-green': {\n    '50': '#f1f8e9',\n    '100': '#dcedc8',\n    '200': '#c5e1a5',\n    '300': '#aed581',\n    '400': '#9ccc65',\n    '500': '#8bc34a',\n    '600': '#7cb342',\n    '700': '#689f38',\n    '800': '#558b2f',\n    '900': '#33691e',\n    'A100': '#ccff90',\n    'A200': '#b2ff59',\n    'A400': '#76ff03',\n    'A700': '#64dd17',\n    'contrastDefaultColor': 'dark',\n    'contrastLightColors': '800 900',\n    'contrastStrongLightColors': '800 900'\n  },\n  'lime': {\n    '50': '#f9fbe7',\n    '100': '#f0f4c3',\n    '200': '#e6ee9c',\n    '300': '#dce775',\n    '400': '#d4e157',\n    '500': '#cddc39',\n    '600': '#c0ca33',\n    '700': '#afb42b',\n    '800': '#9e9d24',\n    '900': '#827717',\n    'A100': '#f4ff81',\n    'A200': '#eeff41',\n    'A400': '#c6ff00',\n    'A700': '#aeea00',\n    'contrastDefaultColor': 'dark',\n    'contrastLightColors': '900',\n    'contrastStrongLightColors': '900'\n  },\n  'yellow': {\n    '50': '#fffde7',\n    '100': '#fff9c4',\n    '200': '#fff59d',\n    '300': '#fff176',\n    '400': '#ffee58',\n    '500': '#ffeb3b',\n    '600': '#fdd835',\n    '700': '#fbc02d',\n    '800': '#f9a825',\n    '900': '#f57f17',\n    'A100': '#ffff8d',\n    'A200': '#ffff00',\n    'A400': '#ffea00',\n    'A700': '#ffd600',\n    'contrastDefaultColor': 'dark'\n  },\n  'amber': {\n    '50': '#fff8e1',\n    '100': '#ffecb3',\n    '200': '#ffe082',\n    '300': '#ffd54f',\n    '400': '#ffca28',\n    '500': '#ffc107',\n    '600': '#ffb300',\n    '700': '#ffa000',\n    '800': '#ff8f00',\n    '900': '#ff6f00',\n    'A100': '#ffe57f',\n    'A200': '#ffd740',\n    'A400': '#ffc400',\n    'A700': '#ffab00',\n    'contrastDefaultColor': 'dark'\n  },\n  'orange': {\n    '50': '#fff3e0',\n    '100': '#ffe0b2',\n    '200': '#ffcc80',\n    '300': '#ffb74d',\n    '400': '#ffa726',\n    '500': '#ff9800',\n    '600': '#fb8c00',\n    '700': '#f57c00',\n    '800': '#ef6c00',\n    '900': '#e65100',\n    'A100': '#ffd180',\n    'A200': '#ffab40',\n    'A400': '#ff9100',\n    'A700': '#ff6d00',\n    'contrastDefaultColor': 'dark',\n    'contrastLightColors': '800 900',\n    'contrastStrongLightColors': '800 900'\n  },\n  'deep-orange': {\n    '50': '#fbe9e7',\n    '100': '#ffccbc',\n    '200': '#ffab91',\n    '300': '#ff8a65',\n    '400': '#ff7043',\n    '500': '#ff5722',\n    '600': '#f4511e',\n    '700': '#e64a19',\n    '800': '#d84315',\n    '900': '#bf360c',\n    'A100': '#ff9e80',\n    'A200': '#ff6e40',\n    'A400': '#ff3d00',\n    'A700': '#dd2c00',\n    'contrastDefaultColor': 'light',\n    'contrastDarkColors': '50 100 200 300 400 A100 A200',\n    'contrastStrongLightColors': '500 600 700 800 900 A400 A700'\n  },\n  'brown': {\n    '50': '#efebe9',\n    '100': '#d7ccc8',\n    '200': '#bcaaa4',\n    '300': '#a1887f',\n    '400': '#8d6e63',\n    '500': '#795548',\n    '600': '#6d4c41',\n    '700': '#5d4037',\n    '800': '#4e342e',\n    '900': '#3e2723',\n    'A100': '#d7ccc8',\n    'A200': '#bcaaa4',\n    'A400': '#8d6e63',\n    'A700': '#5d4037',\n    'contrastDefaultColor': 'light',\n    'contrastDarkColors': '50 100 200',\n    'contrastStrongLightColors': '300 400'\n  },\n  'grey': {\n    '50': '#fafafa',\n    '100': '#f5f5f5',\n    '200': '#eeeeee',\n    '300': '#e0e0e0',\n    '400': '#bdbdbd',\n    '500': '#9e9e9e',\n    '600': '#757575',\n    '700': '#616161',\n    '800': '#424242',\n    '900': '#212121',\n    '1000': '#000000',\n    'A100': '#ffffff',\n    'A200': '#eeeeee',\n    'A400': '#bdbdbd',\n    'A700': '#616161',\n    'contrastDefaultColor': 'dark',\n    'contrastLightColors': '600 700 800 900'\n  },\n  'blue-grey': {\n    '50': '#eceff1',\n    '100': '#cfd8dc',\n    '200': '#b0bec5',\n    '300': '#90a4ae',\n    '400': '#78909c',\n    '500': '#607d8b',\n    '600': '#546e7a',\n    '700': '#455a64',\n    '800': '#37474f',\n    '900': '#263238',\n    'A100': '#cfd8dc',\n    'A200': '#b0bec5',\n    'A400': '#78909c',\n    'A700': '#455a64',\n    'contrastDefaultColor': 'light',\n    'contrastDarkColors': '50 100 200 300',\n    'contrastStrongLightColors': '400 500'\n  }\n});\n\n})();\n(function(){\n\"use strict\";\n\nangular.module('material.core.theming', ['material.core.theming.palette'])\n  .directive('mdTheme', ThemingDirective)\n  .directive('mdThemable', ThemableDirective)\n  .provider('$mdTheming', ThemingProvider)\n  .run(generateThemes);\n\n/**\n * @ngdoc provider\n * @name $mdThemingProvider\n * @module material.core\n *\n * @description Provider to configure the `$mdTheming` service.\n */\n\n/**\n * @ngdoc method\n * @name $mdThemingProvider#setDefaultTheme\n * @param {string} themeName Default theme name to be applied to elements. Default value is `default`.\n */\n\n/**\n * @ngdoc method\n * @name $mdThemingProvider#alwaysWatchTheme\n * @param {boolean} watch Whether or not to always watch themes for changes and re-apply\n * classes when they change. Default is `false`. Enabling can reduce performance.\n */\n\n/* Some Example Valid Theming Expressions\n * =======================================\n *\n * Intention group expansion: (valid for primary, accent, warn, background)\n *\n * {{primary-100}} - grab shade 100 from the primary palette\n * {{primary-100-0.7}} - grab shade 100, apply opacity of 0.7\n * {{primary-hue-1}} - grab the shade assigned to hue-1 from the primary palette\n * {{primary-hue-1-0.7}} - apply 0.7 opacity to primary-hue-1\n * {{primary-color}} - Generates .md-hue-1, .md-hue-2, .md-hue-3 with configured shades set for each hue\n * {{primary-color-0.7}} - Apply 0.7 opacity to each of the above rules\n * {{primary-contrast}} - Generates .md-hue-1, .md-hue-2, .md-hue-3 with configured contrast (ie. text) color shades set for each hue\n * {{primary-contrast-0.7}} - Apply 0.7 opacity to each of the above rules\n *\n * Foreground expansion: Applies rgba to black/white foreground text\n *\n * {{foreground-1}} - used for primary text\n * {{foreground-2}} - used for secondary text/divider\n * {{foreground-3}} - used for disabled text\n * {{foreground-4}} - used for dividers\n *\n */\n\n// In memory generated CSS rules; registered by theme.name\nvar GENERATED = { };\n\n// In memory storage of defined themes and color palettes (both loaded by CSS, and user specified)\nvar PALETTES;\nvar THEMES;\n\nvar DARK_FOREGROUND = {\n  name: 'dark',\n  '1': 'rgba(0,0,0,0.87)',\n  '2': 'rgba(0,0,0,0.54)',\n  '3': 'rgba(0,0,0,0.26)',\n  '4': 'rgba(0,0,0,0.12)'\n};\nvar LIGHT_FOREGROUND = {\n  name: 'light',\n  '1': 'rgba(255,255,255,1.0)',\n  '2': 'rgba(255,255,255,0.7)',\n  '3': 'rgba(255,255,255,0.3)',\n  '4': 'rgba(255,255,255,0.12)'\n};\n\nvar DARK_SHADOW = '1px 1px 0px rgba(0,0,0,0.4), -1px -1px 0px rgba(0,0,0,0.4)';\nvar LIGHT_SHADOW = '';\n\nvar DARK_CONTRAST_COLOR = colorToRgbaArray('rgba(0,0,0,0.87)');\nvar LIGHT_CONTRAST_COLOR = colorToRgbaArray('rgba(255,255,255,0.87');\nvar STRONG_LIGHT_CONTRAST_COLOR = colorToRgbaArray('rgb(255,255,255)');\n\nvar THEME_COLOR_TYPES = ['primary', 'accent', 'warn', 'background'];\nvar DEFAULT_COLOR_TYPE = 'primary';\n\n// A color in a theme will use these hues by default, if not specified by user.\nvar LIGHT_DEFAULT_HUES = {\n  'accent': {\n    'default': 'A200',\n    'hue-1': 'A100',\n    'hue-2': 'A400',\n    'hue-3': 'A700'\n  },\n  'background': {\n    'default': 'A100',\n    'hue-1': '300',\n    'hue-2': '800',\n    'hue-3': '900'\n  }\n};\n\nvar DARK_DEFAULT_HUES = {\n  'background': {\n    'default': '800',\n    'hue-1': '300',\n    'hue-2': '600',\n    'hue-3': '900'\n  }\n};\nTHEME_COLOR_TYPES.forEach(function(colorType) {\n  // Color types with unspecified default hues will use these default hue values\n  var defaultDefaultHues = {\n    'default': '500',\n    'hue-1': '300',\n    'hue-2': '800',\n    'hue-3': 'A100'\n  };\n  if (!LIGHT_DEFAULT_HUES[colorType]) LIGHT_DEFAULT_HUES[colorType] = defaultDefaultHues;\n  if (!DARK_DEFAULT_HUES[colorType]) DARK_DEFAULT_HUES[colorType] = defaultDefaultHues;\n});\n\nvar VALID_HUE_VALUES = [\n  '50', '100', '200', '300', '400', '500', '600',\n  '700', '800', '900', 'A100', 'A200', 'A400', 'A700'\n];\n\nfunction ThemingProvider($mdColorPalette) {\n  PALETTES = { };\n  THEMES = { };\n\n  var themingProvider;\n  var defaultTheme = 'default';\n  var alwaysWatchTheme = false;\n\n  // Load JS Defined Palettes\n  angular.extend(PALETTES, $mdColorPalette);\n\n  // Default theme defined in core.js\n\n  ThemingService.$inject = [\"$rootScope\", \"$log\"];\n  return themingProvider = {\n    definePalette: definePalette,\n    extendPalette: extendPalette,\n    theme: registerTheme,\n\n    setDefaultTheme: function(theme) {\n      defaultTheme = theme;\n    },\n    alwaysWatchTheme: function(alwaysWatch) {\n      alwaysWatchTheme = alwaysWatch;\n    },\n    $get: ThemingService,\n    _LIGHT_DEFAULT_HUES: LIGHT_DEFAULT_HUES,\n    _DARK_DEFAULT_HUES: DARK_DEFAULT_HUES,\n    _PALETTES: PALETTES,\n    _THEMES: THEMES,\n    _parseRules: parseRules,\n    _rgba: rgba\n  };\n\n  // Example: $mdThemingProvider.definePalette('neonRed', { 50: '#f5fafa', ... });\n  function definePalette(name, map) {\n    map = map || {};\n    PALETTES[name] = checkPaletteValid(name, map);\n    return themingProvider;\n  }\n\n  // Returns an new object which is a copy of a given palette `name` with variables from\n  // `map` overwritten\n  // Example: var neonRedMap = $mdThemingProvider.extendPalette('red', { 50: '#f5fafafa' });\n  function extendPalette(name, map) {\n    return checkPaletteValid(name,  angular.extend({}, PALETTES[name] || {}, map) );\n  }\n\n  // Make sure that palette has all required hues\n  function checkPaletteValid(name, map) {\n    var missingColors = VALID_HUE_VALUES.filter(function(field) {\n      return !map[field];\n    });\n    if (missingColors.length) {\n      throw new Error(\"Missing colors %1 in palette %2!\"\n                      .replace('%1', missingColors.join(', '))\n                      .replace('%2', name));\n    }\n\n    return map;\n  }\n\n  // Register a theme (which is a collection of color palettes to use with various states\n  // ie. warn, accent, primary )\n  // Optionally inherit from an existing theme\n  // $mdThemingProvider.theme('custom-theme').primaryPalette('red');\n  function registerTheme(name, inheritFrom) {\n    if (THEMES[name]) return THEMES[name];\n\n    inheritFrom = inheritFrom || 'default';\n\n    var parentTheme = typeof inheritFrom === 'string' ? THEMES[inheritFrom] : inheritFrom;\n    var theme = new Theme(name);\n\n    if (parentTheme) {\n      angular.forEach(parentTheme.colors, function(color, colorType) {\n        theme.colors[colorType] = {\n          name: color.name,\n          // Make sure a COPY of the hues is given to the child color,\n          // not the same reference.\n          hues: angular.extend({}, color.hues)\n        };\n      });\n    }\n    THEMES[name] = theme;\n\n    return theme;\n  }\n\n  function Theme(name) {\n    var self = this;\n    self.name = name;\n    self.colors = {};\n\n    self.dark = setDark;\n    setDark(false);\n\n    function setDark(isDark) {\n      isDark = arguments.length === 0 ? true : !!isDark;\n\n      // If no change, abort\n      if (isDark === self.isDark) return;\n\n      self.isDark = isDark;\n\n      self.foregroundPalette = self.isDark ? LIGHT_FOREGROUND : DARK_FOREGROUND;\n      self.foregroundShadow = self.isDark ? DARK_SHADOW : LIGHT_SHADOW;\n\n      // Light and dark themes have different default hues.\n      // Go through each existing color type for this theme, and for every\n      // hue value that is still the default hue value from the previous light/dark setting,\n      // set it to the default hue value from the new light/dark setting.\n      var newDefaultHues = self.isDark ? DARK_DEFAULT_HUES : LIGHT_DEFAULT_HUES;\n      var oldDefaultHues = self.isDark ? LIGHT_DEFAULT_HUES : DARK_DEFAULT_HUES;\n      angular.forEach(newDefaultHues, function(newDefaults, colorType) {\n        var color = self.colors[colorType];\n        var oldDefaults = oldDefaultHues[colorType];\n        if (color) {\n          for (var hueName in color.hues) {\n            if (color.hues[hueName] === oldDefaults[hueName]) {\n              color.hues[hueName] = newDefaults[hueName];\n            }\n          }\n        }\n      });\n\n      return self;\n    }\n\n    THEME_COLOR_TYPES.forEach(function(colorType) {\n      var defaultHues = (self.isDark ? DARK_DEFAULT_HUES : LIGHT_DEFAULT_HUES)[colorType];\n      self[colorType + 'Palette'] = function setPaletteType(paletteName, hues) {\n        var color = self.colors[colorType] = {\n          name: paletteName,\n          hues: angular.extend({}, defaultHues, hues)\n        };\n\n        Object.keys(color.hues).forEach(function(name) {\n          if (!defaultHues[name]) {\n            throw new Error(\"Invalid hue name '%1' in theme %2's %3 color %4. Available hue names: %4\"\n              .replace('%1', name)\n              .replace('%2', self.name)\n              .replace('%3', paletteName)\n              .replace('%4', Object.keys(defaultHues).join(', '))\n            );\n          }\n        });\n        Object.keys(color.hues).map(function(key) {\n          return color.hues[key];\n        }).forEach(function(hueValue) {\n          if (VALID_HUE_VALUES.indexOf(hueValue) == -1) {\n            throw new Error(\"Invalid hue value '%1' in theme %2's %3 color %4. Available hue values: %5\"\n              .replace('%1', hueValue)\n              .replace('%2', self.name)\n              .replace('%3', colorType)\n              .replace('%4', paletteName)\n              .replace('%5', VALID_HUE_VALUES.join(', '))\n            );\n          }\n        });\n        return self;\n      };\n\n      self[colorType + 'Color'] = function() {\n        var args = Array.prototype.slice.call(arguments);\n        console.warn('$mdThemingProviderTheme.' + colorType + 'Color() has been deprecated. ' +\n                     'Use $mdThemingProviderTheme.' + colorType + 'Palette() instead.');\n        return self[colorType + 'Palette'].apply(self, args);\n      };\n    });\n  }\n\n  /**\n   * @ngdoc service\n   * @name $mdTheming\n   *\n   * @description\n   *\n   * Service that makes an element apply theming related classes to itself.\n   *\n   * ```js\n   * app.directive('myFancyDirective', function($mdTheming) {\n   *   return {\n   *     restrict: 'e',\n   *     link: function(scope, el, attrs) {\n   *       $mdTheming(el);\n   *     }\n   *   };\n   * });\n   * ```\n   * @param {el=} element to apply theming to\n   */\n  /* @ngInject */\n  function ThemingService($rootScope, $log) {\n\n    applyTheme.inherit = function(el, parent) {\n      var ctrl = parent.controller('mdTheme');\n\n      var attrThemeValue = el.attr('md-theme-watch');\n      if ( (alwaysWatchTheme || angular.isDefined(attrThemeValue)) && attrThemeValue != 'false') {\n        var deregisterWatch = $rootScope.$watch(function() {\n          return ctrl && ctrl.$mdTheme || defaultTheme;\n        }, changeTheme);\n        el.on('$destroy', deregisterWatch);\n      } else {\n        var theme = ctrl && ctrl.$mdTheme || defaultTheme;\n        changeTheme(theme);\n      }\n\n      function changeTheme(theme) {\n        if (!registered(theme)) {\n          $log.warn('Attempted to use unregistered theme \\'' + theme + '\\'. ' +\n                    'Register it with $mdThemingProvider.theme().');\n        }\n        var oldTheme = el.data('$mdThemeName');\n        if (oldTheme) el.removeClass('md-' + oldTheme +'-theme');\n        el.addClass('md-' + theme + '-theme');\n        el.data('$mdThemeName', theme);\n      }\n    };\n\n    applyTheme.THEMES = angular.extend({}, THEMES);\n    applyTheme.defaultTheme = function() { return defaultTheme; };\n    applyTheme.registered = registered;\n\n    return applyTheme;\n\n    function registered(themeName) {\n      if (themeName === undefined || themeName === '') return true;\n      return applyTheme.THEMES[themeName] !== undefined;\n    }\n\n    function applyTheme(scope, el) {\n      // Allow us to be invoked via a linking function signature.\n      if (el === undefined) {\n        el = scope;\n        scope = undefined;\n      }\n      if (scope === undefined) {\n        scope = $rootScope;\n      }\n      applyTheme.inherit(el, el);\n    }\n  }\n}\nThemingProvider.$inject = [\"$mdColorPalette\"];\n\nfunction ThemingDirective($mdTheming, $interpolate, $log) {\n  return {\n    priority: 100,\n    link: {\n      pre: function(scope, el, attrs) {\n        var ctrl = {\n          $setTheme: function(theme) {\n            if (!$mdTheming.registered(theme)) {\n              $log.warn('attempted to use unregistered theme \\'' + theme + '\\'');\n            }\n            ctrl.$mdTheme = theme;\n          }\n        };\n        el.data('$mdThemeController', ctrl);\n        ctrl.$setTheme($interpolate(attrs.mdTheme)(scope));\n        attrs.$observe('mdTheme', ctrl.$setTheme);\n      }\n    }\n  };\n}\nThemingDirective.$inject = [\"$mdTheming\", \"$interpolate\", \"$log\"];\n\nfunction ThemableDirective($mdTheming) {\n  return $mdTheming;\n}\nThemableDirective.$inject = [\"$mdTheming\"];\n\nfunction parseRules(theme, colorType, rules) {\n  checkValidPalette(theme, colorType);\n\n  rules = rules.replace(/THEME_NAME/g, theme.name);\n  var generatedRules = [];\n  var color = theme.colors[colorType];\n\n  var themeNameRegex = new RegExp('.md-' + theme.name + '-theme', 'g');\n  // Matches '{{ primary-color }}', etc\n  var hueRegex = new RegExp('(\\'|\")?{{\\\\s*(' + colorType + ')-(color|contrast)-?(\\\\d\\\\.?\\\\d*)?\\\\s*}}(\\\"|\\')?','g');\n  var simpleVariableRegex = /'?\"?\\{\\{\\s*([a-zA-Z]+)-(A?\\d+|hue\\-[0-3]|shadow)-?(\\d\\.?\\d*)?\\s*\\}\\}'?\"?/g;\n  var palette = PALETTES[color.name];\n\n  // find and replace simple variables where we use a specific hue, not an entire palette\n  // eg. \"{{primary-100}}\"\n  //\\(' + THEME_COLOR_TYPES.join('\\|') + '\\)'\n  rules = rules.replace(simpleVariableRegex, function(match, colorType, hue, opacity) {\n    if (colorType === 'foreground') {\n      if (hue == 'shadow') {\n        return theme.foregroundShadow;\n      } else {\n        return theme.foregroundPalette[hue] || theme.foregroundPalette['1'];\n      }\n    }\n    if (hue.indexOf('hue') === 0) {\n      hue = theme.colors[colorType].hues[hue];\n    }\n    return rgba( (PALETTES[ theme.colors[colorType].name ][hue] || '').value, opacity );\n  });\n\n  // For each type, generate rules for each hue (ie. default, md-hue-1, md-hue-2, md-hue-3)\n  angular.forEach(color.hues, function(hueValue, hueName) {\n    var newRule = rules\n      .replace(hueRegex, function(match, _, colorType, hueType, opacity) {\n        return rgba(palette[hueValue][hueType === 'color' ? 'value' : 'contrast'], opacity);\n      });\n    if (hueName !== 'default') {\n      newRule = newRule.replace(themeNameRegex, '.md-' + theme.name + '-theme.md-' + hueName);\n    }\n    generatedRules.push(newRule);\n  });\n\n  return generatedRules;\n}\n\n// Generate our themes at run time given the state of THEMES and PALETTES\nfunction generateThemes($injector) {\n\n  var head = document.getElementsByTagName('head')[0];\n  var firstChild = head ? head.firstElementChild : null;\n  var themeCss = $injector.has('$MD_THEME_CSS') ? $injector.get('$MD_THEME_CSS') : '';\n\n  if ( !firstChild ) return;\n  if (themeCss.length === 0) return; // no rules, so no point in running this expensive task\n\n  // Expose contrast colors for palettes to ensure that text is always readable\n  angular.forEach(PALETTES, sanitizePalette);\n\n  // MD_THEME_CSS is a string generated by the build process that includes all the themable\n  // components as templates\n\n  // Break the CSS into individual rules\n  var rulesByType = {};\n  var rules = themeCss\n                  .split(/\\}(?!(\\}|'|\"|;))/)\n                  .filter(function(rule) { return rule && rule.length; })\n                  .map(function(rule) { return rule.trim() + '}'; });\n\n\n  var ruleMatchRegex = new RegExp('md-(' + THEME_COLOR_TYPES.join('|') + ')', 'g');\n\n  THEME_COLOR_TYPES.forEach(function(type) {\n    rulesByType[type] = '';\n  });\n\n\n  // Sort the rules based on type, allowing us to do color substitution on a per-type basis\n  rules.forEach(function(rule) {\n    var match = rule.match(ruleMatchRegex);\n    // First: test that if the rule has '.md-accent', it goes into the accent set of rules\n    for (var i = 0, type; type = THEME_COLOR_TYPES[i]; i++) {\n      if (rule.indexOf('.md-' + type) > -1) {\n        return rulesByType[type] += rule;\n      }\n    }\n\n    // If no eg 'md-accent' class is found, try to just find 'accent' in the rule and guess from\n    // there\n    for (i = 0; type = THEME_COLOR_TYPES[i]; i++) {\n      if (rule.indexOf(type) > -1) {\n        return rulesByType[type] += rule;\n      }\n    }\n\n    // Default to the primary array\n    return rulesByType[DEFAULT_COLOR_TYPE] += rule;\n  });\n\n    // For each theme, use the color palettes specified for\n    // `primary`, `warn` and `accent` to generate CSS rules.\n\n    angular.forEach(THEMES, function(theme) {\n      if ( !GENERATED[theme.name] ) {\n\n\n        THEME_COLOR_TYPES.forEach(function(colorType) {\n          var styleStrings = parseRules(theme, colorType, rulesByType[colorType]);\n          while (styleStrings.length) {\n            var style = document.createElement('style');\n                style.setAttribute('type', 'text/css');\n            style.appendChild(document.createTextNode(styleStrings.shift()));\n            head.insertBefore(style, firstChild);\n          }\n        });\n\n\n        if (theme.colors.primary.name == theme.colors.accent.name) {\n          console.warn(\"$mdThemingProvider: Using the same palette for primary and\" +\n                       \" accent. This violates the material design spec.\");\n        }\n\n        GENERATED[theme.name] = true;\n      }\n    });\n\n\n  // *************************\n  // Internal functions\n  // *************************\n\n  // The user specifies a 'default' contrast color as either light or dark,\n  // then explicitly lists which hues are the opposite contrast (eg. A100 has dark, A200 has light)\n  function sanitizePalette(palette) {\n    var defaultContrast = palette.contrastDefaultColor;\n    var lightColors = palette.contrastLightColors || [];\n    var strongLightColors = palette.contrastStrongLightColors || [];\n    var darkColors = palette.contrastDarkColors || [];\n\n    // These colors are provided as space-separated lists\n    if (typeof lightColors === 'string') lightColors = lightColors.split(' ');\n    if (typeof strongLightColors === 'string') strongLightColors = strongLightColors.split(' ');\n    if (typeof darkColors === 'string') darkColors = darkColors.split(' ');\n\n    // Cleanup after ourselves\n    delete palette.contrastDefaultColor;\n    delete palette.contrastLightColors;\n    delete palette.contrastStrongLightColors;\n    delete palette.contrastDarkColors;\n\n    // Change { 'A100': '#fffeee' } to { 'A100': { value: '#fffeee', contrast:DARK_CONTRAST_COLOR }\n    angular.forEach(palette, function(hueValue, hueName) {\n      if (angular.isObject(hueValue)) return; // Already converted\n      // Map everything to rgb colors\n      var rgbValue = colorToRgbaArray(hueValue);\n      if (!rgbValue) {\n        throw new Error(\"Color %1, in palette %2's hue %3, is invalid. Hex or rgb(a) color expected.\"\n                        .replace('%1', hueValue)\n                        .replace('%2', palette.name)\n                        .replace('%3', hueName));\n      }\n\n      palette[hueName] = {\n        value: rgbValue,\n        contrast: getContrastColor()\n      };\n      function getContrastColor() {\n        if (defaultContrast === 'light') {\n          if (darkColors.indexOf(hueName) > -1) {\n            return DARK_CONTRAST_COLOR;\n          } else {\n            return strongLightColors.indexOf(hueName) > -1 ? STRONG_LIGHT_CONTRAST_COLOR\n              : LIGHT_CONTRAST_COLOR;\n          }\n        } else {\n          if (lightColors.indexOf(hueName) > -1) {\n            return strongLightColors.indexOf(hueName) > -1 ? STRONG_LIGHT_CONTRAST_COLOR\n              : LIGHT_CONTRAST_COLOR;\n          } else {\n            return DARK_CONTRAST_COLOR;\n          }\n        }\n      }\n    });\n  }\n\n\n}\ngenerateThemes.$inject = [\"$injector\"];\n\nfunction checkValidPalette(theme, colorType) {\n  // If theme attempts to use a palette that doesnt exist, throw error\n  if (!PALETTES[ (theme.colors[colorType] || {}).name ]) {\n    throw new Error(\n      \"You supplied an invalid color palette for theme %1's %2 palette. Available palettes: %3\"\n                    .replace('%1', theme.name)\n                    .replace('%2', colorType)\n                    .replace('%3', Object.keys(PALETTES).join(', '))\n    );\n  }\n}\n\nfunction colorToRgbaArray(clr) {\n  if (angular.isArray(clr) && clr.length == 3) return clr;\n  if (/^rgb/.test(clr)) {\n    return clr.replace(/(^\\s*rgba?\\(|\\)\\s*$)/g, '').split(',').map(function(value, i) {\n      return i == 3 ? parseFloat(value, 10) : parseInt(value, 10);\n    });\n  }\n  if (clr.charAt(0) == '#') clr = clr.substring(1);\n  if (!/^([a-fA-F0-9]{3}){1,2}$/g.test(clr)) return;\n\n  var dig = clr.length / 3;\n  var red = clr.substr(0, dig);\n  var grn = clr.substr(dig, dig);\n  var blu = clr.substr(dig * 2);\n  if (dig === 1) {\n    red += red;\n    grn += grn;\n    blu += blu;\n  }\n  return [parseInt(red, 16), parseInt(grn, 16), parseInt(blu, 16)];\n}\n\nfunction rgba(rgbArray, opacity) {\n  if ( !rgbArray ) return \"rgb('0,0,0')\";\n\n  if (rgbArray.length == 4) {\n    rgbArray = angular.copy(rgbArray);\n    opacity ? rgbArray.pop() : opacity = rgbArray.pop();\n  }\n  return opacity && (typeof opacity == 'number' || (typeof opacity == 'string' && opacity.length)) ?\n    'rgba(' + rgbArray.join(',') + ',' + opacity + ')' :\n    'rgb(' + rgbArray.join(',') + ')';\n}\n\n\n})();\n(function(){\n\"use strict\";\n\n/**\n * @ngdoc module\n * @name material.components.autocomplete\n */\n/*\n * @see js folder for autocomplete implementation\n */\nangular.module('material.components.autocomplete', [\n  'material.core',\n  'material.components.icon'\n]);\n\n})();\n(function(){\n\"use strict\";\n\n/*\n * @ngdoc module\n * @name material.components.backdrop\n * @description Backdrop\n */\n\n/**\n * @ngdoc directive\n * @name mdBackdrop\n * @module material.components.backdrop\n *\n * @restrict E\n *\n * @description\n * `<md-backdrop>` is a backdrop element used by other components, such as dialog and bottom sheet.\n * Apply class `opaque` to make the backdrop use the theme backdrop color.\n *\n */\n\nangular.module('material.components.backdrop', [\n  'material.core'\n])\n  .directive('mdBackdrop', BackdropDirective);\n\nfunction BackdropDirective($mdTheming) {\n  return $mdTheming;\n}\nBackdropDirective.$inject = [\"$mdTheming\"];\n\n})();\n(function(){\n\"use strict\";\n\n/**\n * @ngdoc module\n * @name material.components.bottomSheet\n * @description\n * BottomSheet\n */\nangular.module('material.components.bottomSheet', [\n  'material.core',\n  'material.components.backdrop'\n])\n  .directive('mdBottomSheet', MdBottomSheetDirective)\n  .provider('$mdBottomSheet', MdBottomSheetProvider);\n\nfunction MdBottomSheetDirective() {\n  return {\n    restrict: 'E'\n  };\n}\n\n/**\n * @ngdoc service\n * @name $mdBottomSheet\n * @module material.components.bottomSheet\n *\n * @description\n * `$mdBottomSheet` opens a bottom sheet over the app and provides a simple promise API.\n *\n * ## Restrictions\n *\n * - The bottom sheet's template must have an outer `<md-bottom-sheet>` element.\n * - Add the `md-grid` class to the bottom sheet for a grid layout.\n * - Add the `md-list` class to the bottom sheet for a list layout.\n *\n * @usage\n * <hljs lang=\"html\">\n * <div ng-controller=\"MyController\">\n *   <md-button ng-click=\"openBottomSheet()\">\n *     Open a Bottom Sheet!\n *   </md-button>\n * </div>\n * </hljs>\n * <hljs lang=\"js\">\n * var app = angular.module('app', ['ngMaterial']);\n * app.controller('MyController', function($scope, $mdBottomSheet) {\n *   $scope.openBottomSheet = function() {\n *     $mdBottomSheet.show({\n *       template: '<md-bottom-sheet>Hello!</md-bottom-sheet>'\n *     });\n *   };\n * });\n * </hljs>\n */\n\n /**\n * @ngdoc method\n * @name $mdBottomSheet#show\n *\n * @description\n * Show a bottom sheet with the specified options.\n *\n * @param {object} options An options object, with the following properties:\n *\n *   - `templateUrl` - `{string=}`: The url of an html template file that will\n *   be used as the content of the bottom sheet. Restrictions: the template must\n *   have an outer `md-bottom-sheet` element.\n *   - `template` - `{string=}`: Same as templateUrl, except this is an actual\n *   template string.\n *   - `scope` - `{object=}`: the scope to link the template / controller to. If none is specified, it will create a new child scope.\n *     This scope will be destroyed when the bottom sheet is removed unless `preserveScope` is set to true.\n *   - `preserveScope` - `{boolean=}`: whether to preserve the scope when the element is removed. Default is false\n *   - `controller` - `{string=}`: The controller to associate with this bottom sheet.\n *   - `locals` - `{string=}`: An object containing key/value pairs. The keys will\n *   be used as names of values to inject into the controller. For example,\n *   `locals: {three: 3}` would inject `three` into the controller with the value\n *   of 3.\n *   - `targetEvent` - `{DOMClickEvent=}`: A click's event object. When passed in as an option,\n *   the location of the click will be used as the starting point for the opening animation\n *   of the the dialog.\n *   - `resolve` - `{object=}`: Similar to locals, except it takes promises as values\n *   and the bottom sheet will not open until the promises resolve.\n *   - `controllerAs` - `{string=}`: An alias to assign the controller to on the scope.\n *   - `parent` - `{element=}`: The element to append the bottom sheet to. The `parent` may be a `function`, `string`,\n *   `object`, or null. Defaults to appending to the body of the root element (or the root element) of the application.\n *   e.g. angular.element(document.getElementById('content')) or \"#content\"\n *   - `disableParentScroll` - `{boolean=}`: Whether to disable scrolling while the bottom sheet is open.\n *     Default true.\n *\n * @returns {promise} A promise that can be resolved with `$mdBottomSheet.hide()` or\n * rejected with `$mdBottomSheet.cancel()`.\n */\n\n/**\n * @ngdoc method\n * @name $mdBottomSheet#hide\n *\n * @description\n * Hide the existing bottom sheet and resolve the promise returned from\n * `$mdBottomSheet.show()`. This call will close the most recently opened/current bottomsheet (if any).\n *\n * @param {*=} response An argument for the resolved promise.\n *\n */\n\n/**\n * @ngdoc method\n * @name $mdBottomSheet#cancel\n *\n * @description\n * Hide the existing bottom sheet and reject the promise returned from\n * `$mdBottomSheet.show()`.\n *\n * @param {*=} response An argument for the rejected promise.\n *\n */\n\nfunction MdBottomSheetProvider($$interimElementProvider) {\n  // how fast we need to flick down to close the sheet, pixels/ms\n  var CLOSING_VELOCITY = 0.5;\n  var PADDING = 80; // same as css\n\n  bottomSheetDefaults.$inject = [\"$animate\", \"$mdConstant\", \"$mdUtil\", \"$timeout\", \"$compile\", \"$mdTheming\", \"$mdBottomSheet\", \"$rootElement\", \"$mdGesture\"];\n  return $$interimElementProvider('$mdBottomSheet')\n    .setDefaults({\n      methods: ['disableParentScroll', 'escapeToClose', 'targetEvent'],\n      options: bottomSheetDefaults\n    });\n\n  /* @ngInject */\n  function bottomSheetDefaults($animate, $mdConstant, $mdUtil, $timeout, $compile, $mdTheming, $mdBottomSheet, $rootElement, $mdGesture) {\n    var backdrop;\n\n    return {\n      themable: true,\n      targetEvent: null,\n      onShow: onShow,\n      onRemove: onRemove,\n      escapeToClose: true,\n      disableParentScroll: true\n    };\n\n\n    function onShow(scope, element, options) {\n\n      element = $mdUtil.extractElementByName(element, 'md-bottom-sheet');\n\n      // Add a backdrop that will close on click\n      backdrop = $compile('<md-backdrop class=\"md-opaque md-bottom-sheet-backdrop\">')(scope);\n      backdrop.on('click', function() {\n        $timeout($mdBottomSheet.cancel);\n      });\n      $mdTheming.inherit(backdrop, options.parent);\n\n      $animate.enter(backdrop, options.parent, null);\n\n      var bottomSheet = new BottomSheet(element, options.parent);\n      options.bottomSheet = bottomSheet;\n\n      // Give up focus on calling item\n      options.targetEvent && angular.element(options.targetEvent.target).blur();\n      $mdTheming.inherit(bottomSheet.element, options.parent);\n\n      if (options.disableParentScroll) {\n        options.lastOverflow = options.parent.css('overflow');\n        options.parent.css('overflow', 'hidden');\n      }\n\n      return $animate.enter(bottomSheet.element, options.parent)\n        .then(function() {\n          var focusable = angular.element(\n            element[0].querySelector('button') ||\n            element[0].querySelector('a') ||\n            element[0].querySelector('[ng-click]')\n          );\n          focusable.focus();\n\n          if (options.escapeToClose) {\n            options.rootElementKeyupCallback = function(e) {\n              if (e.keyCode === $mdConstant.KEY_CODE.ESCAPE) {\n                $timeout($mdBottomSheet.cancel);\n              }\n            };\n            $rootElement.on('keyup', options.rootElementKeyupCallback);\n          }\n        });\n\n    }\n\n    function onRemove(scope, element, options) {\n\n      var bottomSheet = options.bottomSheet;\n\n      $animate.leave(backdrop);\n      return $animate.leave(bottomSheet.element).then(function() {\n        if (options.disableParentScroll) {\n          options.parent.css('overflow', options.lastOverflow);\n          delete options.lastOverflow;\n        }\n\n        bottomSheet.cleanup();\n\n        // Restore focus\n        options.targetEvent && angular.element(options.targetEvent.target).focus();\n      });\n    }\n\n    /**\n     * BottomSheet class to apply bottom-sheet behavior to an element\n     */\n    function BottomSheet(element, parent) {\n      var deregister = $mdGesture.register(parent, 'drag', { horizontal: false });\n      parent.on('$md.dragstart', onDragStart)\n        .on('$md.drag', onDrag)\n        .on('$md.dragend', onDragEnd);\n\n      return {\n        element: element,\n        cleanup: function cleanup() {\n          deregister();\n          parent.off('$md.dragstart', onDragStart)\n            .off('$md.drag', onDrag)\n            .off('$md.dragend', onDragEnd);\n        }\n      };\n\n      function onDragStart(ev) {\n        // Disable transitions on transform so that it feels fast\n        element.css($mdConstant.CSS.TRANSITION_DURATION, '0ms');\n      }\n\n      function onDrag(ev) {\n        var transform = ev.pointer.distanceY;\n        if (transform < 5) {\n          // Slow down drag when trying to drag up, and stop after PADDING\n          transform = Math.max(-PADDING, transform / 2);\n        }\n        element.css($mdConstant.CSS.TRANSFORM, 'translate3d(0,' + (PADDING + transform) + 'px,0)');\n      }\n\n      function onDragEnd(ev) {\n        if (ev.pointer.distanceY > 0 &&\n            (ev.pointer.distanceY > 20 || Math.abs(ev.pointer.velocityY) > CLOSING_VELOCITY)) {\n          var distanceRemaining = element.prop('offsetHeight') - ev.pointer.distanceY;\n          var transitionDuration = Math.min(distanceRemaining / ev.pointer.velocityY * 0.75, 500);\n          element.css($mdConstant.CSS.TRANSITION_DURATION, transitionDuration + 'ms');\n          $timeout($mdBottomSheet.cancel);\n        } else {\n          element.css($mdConstant.CSS.TRANSITION_DURATION, '');\n          element.css($mdConstant.CSS.TRANSFORM, '');\n        }\n      }\n    }\n\n  }\n\n}\nMdBottomSheetProvider.$inject = [\"$$interimElementProvider\"];\n\n})();\n(function(){\n\"use strict\";\n\n/**\n * @ngdoc module\n * @name material.components.button\n * @description\n *\n * Button\n */\nangular\n    .module('material.components.button', [ 'material.core' ])\n    .directive('mdButton', MdButtonDirective);\n\n/**\n * @ngdoc directive\n * @name mdButton\n * @module material.components.button\n *\n * @restrict E\n *\n * @description\n * `<md-button>` is a button directive with optional ink ripples (default enabled).\n *\n * If you supply a `href` or `ng-href` attribute, it will become an `<a>` element. Otherwise, it will\n * become a `<button>` element. As per the [Material Design specifications](http://www.google.com/design/spec/style/color.html#color-ui-color-application)\n * the FAB button background is filled with the accent color [by default]. The primary color palette may be used with\n * the `md-primary` class.\n *\n * @param {boolean=} md-no-ink If present, disable ripple ink effects.\n * @param {expression=} ng-disabled En/Disable based on the expression\n * @param {string=} md-ripple-size Overrides the default ripple size logic. Options: `full`, `partial`, `auto`\n * @param {string=} aria-label Adds alternative text to button for accessibility, useful for icon buttons.\n * If no default text is found, a warning will be logged.\n *\n * @usage\n *\n * Regular buttons:\n *\n * <hljs lang=\"html\">\n *  <md-button> Flat Button </md-button>\n *  <md-button href=\"http://google.com\"> Flat link </md-button>\n *  <md-button class=\"md-raised\"> Raised Button </md-button>\n *  <md-button ng-disabled=\"true\"> Disabled Button </md-button>\n *  <md-button>\n *    <md-icon md-svg-src=\"your/icon.svg\"></md-icon>\n *    Register Now\n *  </md-button>\n * </hljs>\n *\n * FAB buttons:\n *\n * <hljs lang=\"html\">\n *  <md-button class=\"md-fab\" aria-label=\"FAB\">\n *    <md-icon md-svg-src=\"your/icon.svg\"></md-icon>\n *  </md-button>\n *  <!-- mini-FAB -->\n *  <md-button class=\"md-fab md-mini\" aria-label=\"Mini FAB\">\n *    <md-icon md-svg-src=\"your/icon.svg\"></md-icon>\n *  </md-button>\n *  <!-- Button with SVG Icon -->\n *  <md-button class=\"md-icon-button\" aria-label=\"Custom Icon Button\">\n *    <md-icon md-svg-icon=\"path/to/your.svg\"></md-icon>\n *  </md-button>\n * </hljs>\n */\nfunction MdButtonDirective($mdButtonInkRipple, $mdTheming, $mdAria, $timeout) {\n\n  return {\n    restrict: 'EA',\n    replace: true,\n    transclude: true,\n    template: getTemplate,\n    link: postLink\n  };\n\n  function isAnchor(attr) {\n    return angular.isDefined(attr.href) || angular.isDefined(attr.ngHref) || angular.isDefined(attr.ngLink) || angular.isDefined(attr.uiSref);\n  }\n\n  function getTemplate(element, attr) {\n    return isAnchor(attr) ?\n           '<a class=\"md-button\" ng-transclude></a>' :\n           '<button class=\"md-button\" ng-transclude></button>';\n  }\n\n  function postLink(scope, element, attr) {\n    var node = element[0];\n    $mdTheming(element);\n    $mdButtonInkRipple.attach(scope, element);\n\n    var elementHasText = node.textContent.trim();\n    if (!elementHasText) {\n      $mdAria.expect(element, 'aria-label');\n    }\n\n    // For anchor elements, we have to set tabindex manually when the\n    // element is disabled\n    if (isAnchor(attr) && angular.isDefined(attr.ngDisabled) ) {\n      scope.$watch(attr.ngDisabled, function(isDisabled) {\n        element.attr('tabindex', isDisabled ? -1 : 0);\n      });\n    }\n\n    // disabling click event when disabled is true\n    element.on('click', function(e){\n      if (attr.disabled === true) {\n        e.preventDefault();\n        e.stopImmediatePropagation();\n      }\n    });\n\n    // restrict focus styles to the keyboard\n    scope.mouseActive = false;\n    element.on('mousedown', function() {\n        scope.mouseActive = true;\n        $timeout(function(){\n          scope.mouseActive = false;\n        }, 100);\n      })\n      .on('focus', function() {\n        if(scope.mouseActive === false) { element.addClass('md-focused'); }\n      })\n      .on('blur', function() { element.removeClass('md-focused'); });\n  }\n\n}\nMdButtonDirective.$inject = [\"$mdButtonInkRipple\", \"$mdTheming\", \"$mdAria\", \"$timeout\"];\n\n})();\n(function(){\n\"use strict\";\n\n/**\n * @ngdoc module\n * @name material.components.card\n *\n * @description\n * Card components.\n */\nangular.module('material.components.card', [\n  'material.core'\n])\n  .directive('mdCard', mdCardDirective);\n\n\n\n/**\n * @ngdoc directive\n * @name mdCard\n * @module material.components.card\n *\n * @restrict E\n *\n * @description\n * The `<md-card>` directive is a container element used within `<md-content>` containers.\n *\n * An image included as a direct descendant will fill the card's width, while the `<md-card-content>`\n * container will wrap text content and provide padding. An `<md-card-footer>` element can be\n * optionally included to put content flush against the bottom edge of the card.\n *\n * Action buttons can be included in an element with the `.md-actions` class, also used in `md-dialog`.\n * You can then position buttons using layout attributes.\n *\n * Cards have constant width and variable heights; where the maximum height is limited to what can\n * fit within a single view on a platform, but it can temporarily expand as needed.\n *\n * @usage\n * ###Card with optional footer\n * <hljs lang=\"html\">\n * <md-card>\n *  <img src=\"card-image.png\" class=\"md-card-image\" alt=\"image caption\">\n *  <md-card-content>\n *    <h2>Card headline</h2>\n *    <p>Card content</p>\n *  </md-card-content>\n *  <md-card-footer>\n *    Card footer\n *  </md-card-footer>\n * </md-card>\n * </hljs>\n *\n * ###Card with actions\n * <hljs lang=\"html\">\n * <md-card>\n *  <img src=\"card-image.png\" class=\"md-card-image\" alt=\"image caption\">\n *  <md-card-content>\n *    <h2>Card headline</h2>\n *    <p>Card content</p>\n *  </md-card-content>\n *  <div class=\"md-actions\" layout=\"row\" layout-align=\"end center\">\n *    <md-button>Action 1</md-button>\n *    <md-button>Action 2</md-button>\n *  </div>\n * </md-card>\n * </hljs>\n *\n */\nfunction mdCardDirective($mdTheming) {\n  return {\n    restrict: 'E',\n    link: function($scope, $element, $attr) {\n      $mdTheming($element);\n    }\n  };\n}\nmdCardDirective.$inject = [\"$mdTheming\"];\n\n})();\n(function(){\n\"use strict\";\n\n/**\n * @ngdoc module\n * @name material.components.checkbox\n * @description Checkbox module!\n */\nangular\n  .module('material.components.checkbox', ['material.core'])\n  .directive('mdCheckbox', MdCheckboxDirective);\n\n/**\n * @ngdoc directive\n * @name mdCheckbox\n * @module material.components.checkbox\n * @restrict E\n *\n * @description\n * The checkbox directive is used like the normal [angular checkbox](https://docs.angularjs.org/api/ng/input/input%5Bcheckbox%5D).\n *\n * As per the [material design spec](http://www.google.com/design/spec/style/color.html#color-ui-color-application)\n * the checkbox is in the accent color by default. The primary color palette may be used with\n * the `md-primary` class.\n *\n * @param {string} ng-model Assignable angular expression to data-bind to.\n * @param {string=} name Property name of the form under which the control is published.\n * @param {expression=} ng-true-value The value to which the expression should be set when selected.\n * @param {expression=} ng-false-value The value to which the expression should be set when not selected.\n * @param {string=} ng-change Angular expression to be executed when input changes due to user interaction with the input element.\n * @param {boolean=} md-no-ink Use of attribute indicates use of ripple ink effects\n * @param {string=} aria-label Adds label to checkbox for accessibility.\n * Defaults to checkbox's text. If no default text is found, a warning will be logged.\n *\n * @usage\n * <hljs lang=\"html\">\n * <md-checkbox ng-model=\"isChecked\" aria-label=\"Finished?\">\n *   Finished ?\n * </md-checkbox>\n *\n * <md-checkbox md-no-ink ng-model=\"hasInk\" aria-label=\"No Ink Effects\">\n *   No Ink Effects\n * </md-checkbox>\n *\n * <md-checkbox ng-disabled=\"true\" ng-model=\"isDisabled\" aria-label=\"Disabled\">\n *   Disabled\n * </md-checkbox>\n *\n * </hljs>\n *\n */\nfunction MdCheckboxDirective(inputDirective, $mdInkRipple, $mdAria, $mdConstant, $mdTheming, $mdUtil, $timeout) {\n  inputDirective = inputDirective[0];\n  var CHECKED_CSS = 'md-checked';\n\n  return {\n    restrict: 'E',\n    transclude: true,\n    require: '?ngModel',\n    priority:210, // Run before ngAria\n    template: \n      '<div class=\"md-container\" md-ink-ripple md-ink-ripple-checkbox>' +\n        '<div class=\"md-icon\"></div>' +\n      '</div>' +\n      '<div ng-transclude class=\"md-label\"></div>',\n    compile: compile\n  };\n\n  // **********************************************************\n  // Private Methods\n  // **********************************************************\n\n  function compile (tElement, tAttrs) {\n\n    tAttrs.type = 'checkbox';\n    tAttrs.tabindex = tAttrs.tabindex || '0';\n    tElement.attr('role', tAttrs.type);\n\n    return function postLink(scope, element, attr, ngModelCtrl) {\n      ngModelCtrl = ngModelCtrl || $mdUtil.fakeNgModel();\n      $mdTheming(element);\n\n      if (attr.ngChecked) {\n        scope.$watch(\n            scope.$eval.bind(scope, attr.ngChecked),\n            ngModelCtrl.$setViewValue.bind(ngModelCtrl)\n        );\n      }\n      $$watchExpr('ngDisabled', 'tabindex', {\n        true: '-1',\n        false: attr.tabindex\n      });\n      $mdAria.expectWithText(element, 'aria-label');\n\n      // Reuse the original input[type=checkbox] directive from Angular core.\n      // This is a bit hacky as we need our own event listener and own render\n      // function.\n      inputDirective.link.pre(scope, {\n        on: angular.noop,\n        0: {}\n      }, attr, [ngModelCtrl]);\n\n      scope.mouseActive = false;\n      element.on('click', listener)\n        .on('keypress', keypressHandler)\n        .on('mousedown', function() {\n          scope.mouseActive = true;\n          $timeout(function(){\n            scope.mouseActive = false;\n          }, 100);\n        })\n        .on('focus', function() {\n          if(scope.mouseActive === false) { element.addClass('md-focused'); }\n        })\n        .on('blur', function() { element.removeClass('md-focused'); });\n\n      ngModelCtrl.$render = render;\n\n      function $$watchExpr(expr, htmlAttr, valueOpts) {\n        if (attr[expr]) {\n          scope.$watch(attr[expr], function(val) {\n            if (valueOpts[val]) {\n              element.attr(htmlAttr, valueOpts[val]);\n            }\n          });\n        }\n      }\n\n      function keypressHandler(ev) {\n        var keyCode = ev.which || ev.keyCode;\n        if (keyCode === $mdConstant.KEY_CODE.SPACE || keyCode === $mdConstant.KEY_CODE.ENTER) {\n          ev.preventDefault();\n          if (!element.hasClass('md-focused')) { element.addClass('md-focused'); }\n          listener(ev);\n        }\n      }\n      function listener(ev) {\n        if (element[0].hasAttribute('disabled')) return;\n\n        scope.$apply(function() {\n          // Toggle the checkbox value...\n          var viewValue = attr.ngChecked ? attr.checked : !ngModelCtrl.$viewValue;\n\n          ngModelCtrl.$setViewValue( viewValue, ev && ev.type);\n          ngModelCtrl.$render();\n        });\n      }\n\n      function render() {\n        if(ngModelCtrl.$viewValue) {\n          element.addClass(CHECKED_CSS);\n        } else {\n          element.removeClass(CHECKED_CSS);\n        }\n      }\n    };\n  }\n}\nMdCheckboxDirective.$inject = [\"inputDirective\", \"$mdInkRipple\", \"$mdAria\", \"$mdConstant\", \"$mdTheming\", \"$mdUtil\", \"$timeout\"];\n\n})();\n(function(){\n\"use strict\";\n\n/**\n * @ngdoc module\n * @name material.components.chips\n */\n/*\n * @see js folder for chips implementation\n */\nangular.module('material.components.chips', [\n  'material.core',\n  'material.components.autocomplete'\n]);\n\n})();\n(function(){\n\"use strict\";\n\n/**\n * @ngdoc module\n * @name material.components.content\n *\n * @description\n * Scrollable content\n */\nangular.module('material.components.content', [\n  'material.core'\n])\n  .directive('mdContent', mdContentDirective);\n\n/**\n * @ngdoc directive\n * @name mdContent\n * @module material.components.content\n *\n * @restrict E\n *\n * @description\n * The `<md-content>` directive is a container element useful for scrollable content\n *\n * @usage\n *\n * - Add the `[layout-padding]` attribute to make the content padded.\n *\n * <hljs lang=\"html\">\n *  <md-content layout-padding>\n *      Lorem ipsum dolor sit amet, ne quod novum mei.\n *  </md-content>\n * </hljs>\n *\n */\n\nfunction mdContentDirective($mdTheming) {\n  return {\n    restrict: 'E',\n    controller: ['$scope', '$element', ContentController],\n    link: function(scope, element, attr) {\n      var node = element[0];\n\n      $mdTheming(element);\n      scope.$broadcast('$mdContentLoaded', element);\n\n      iosScrollFix(element[0]);\n    }\n  };\n\n  function ContentController($scope, $element) {\n    this.$scope = $scope;\n    this.$element = $element;\n  }\n}\nmdContentDirective.$inject = [\"$mdTheming\"];\n\nfunction iosScrollFix(node) {\n  // IOS FIX:\n  // If we scroll where there is no more room for the webview to scroll,\n  // by default the webview itself will scroll up and down, this looks really\n  // bad.  So if we are scrolling to the very top or bottom, add/subtract one\n  angular.element(node).on('$md.pressdown', function(ev) {\n    // Only touch events\n    if (ev.pointer.type !== 't') return;\n    // Don't let a child content's touchstart ruin it for us.\n    if (ev.$materialScrollFixed) return;\n    ev.$materialScrollFixed = true;\n\n    if (node.scrollTop === 0) {\n      node.scrollTop = 1;\n    } else if (node.scrollHeight === node.scrollTop + node.offsetHeight) {\n      node.scrollTop -= 1;\n    }\n  });\n}\n\n})();\n(function(){\n\"use strict\";\n\n/**\n * @ngdoc module\n * @name material.components.dialog\n */\nangular.module('material.components.dialog', [\n  'material.core',\n  'material.components.backdrop'\n])\n  .directive('mdDialog', MdDialogDirective)\n  .provider('$mdDialog', MdDialogProvider);\n\nfunction MdDialogDirective($$rAF, $mdTheming) {\n  return {\n    restrict: 'E',\n    link: function(scope, element, attr) {\n      $mdTheming(element);\n      $$rAF(function() {\n        var content = element[0].querySelector('md-dialog-content');\n        if (content && content.scrollHeight > content.clientHeight) {\n          element.addClass('md-content-overflow');\n        }\n      });\n    }\n  };\n}\nMdDialogDirective.$inject = [\"$$rAF\", \"$mdTheming\"];\n\n/**\n * @ngdoc service\n * @name $mdDialog\n * @module material.components.dialog\n *\n * @description\n * `$mdDialog` opens a dialog over the app to inform users about critical information or require\n *  them to make decisions. There are two approaches for setup: a simple promise API\n *  and regular object syntax.\n *\n * ## Restrictions\n *\n * - The dialog is always given an isolate scope.\n * - The dialog's template must have an outer `<md-dialog>` element.\n *   Inside, use an `<md-dialog-content>` element for the dialog's content, and use\n *   an element with class `md-actions` for the dialog's actions.\n * - Dialogs must cover the entire application to keep interactions inside of them.\n * Use the `parent` option to change where dialogs are appended.\n *\n * ## Sizing\n * - Complex dialogs can be sized with `flex=\"percentage\"`, i.e. `flex=\"66\"`.\n * - Default max-width is 80% of the `rootElement` or `parent`.\n *\n * @usage\n * <hljs lang=\"html\">\n * <div  ng-app=\"demoApp\" ng-controller=\"EmployeeController\">\n *   <div>\n *     <md-button ng-click=\"showAlert()\" class=\"md-raised md-warn\">\n *       Employee Alert!\n *       </md-button>\n *   </div>\n *   <div>\n *     <md-button ng-click=\"showDialog($event)\" class=\"md-raised\">\n *       Custom Dialog\n *       </md-button>\n *   </div>\n *   <div>\n *     <md-button ng-click=\"closeAlert()\" ng-disabled=\"!hasAlert()\" class=\"md-raised\">\n *       Close Alert\n *     </md-button>\n *   </div>\n *   <div>\n *     <md-button ng-click=\"showGreeting($event)\" class=\"md-raised md-primary\" >\n *       Greet Employee\n *       </md-button>\n *   </div>\n * </div>\n * </hljs>\n *\n * ### JavaScript: object syntax\n * <hljs lang=\"js\">\n * (function(angular, undefined){\n *   \"use strict\";\n *\n *   angular\n *    .module('demoApp', ['ngMaterial'])\n *    .controller('AppCtrl', AppController);\n *\n *   function AppController($scope, $mdDialog) {\n *     var alert;\n *     $scope.showAlert = showAlert;\n *     $scope.showDialog = showDialog;\n *     $scope.items = [1, 2, 3];\n *\n *     // Internal method\n *     function showAlert() {\n *       alert = $mdDialog.alert({\n *         title: 'Attention',\n *         content: 'This is an example of how easy dialogs can be!',\n *         ok: 'Close'\n *       });\n *\n *       $mdDialog\n *         .show( alert )\n *         .finally(function() {\n *           alert = undefined;\n *         });\n *     }\n *\n *     function showDialog($event) {\n *        var parentEl = angular.element(document.body);\n *        $mdDialog.show({\n *          parent: parentEl,\n *          targetEvent: $event,\n *          template:\n *            '<md-dialog aria-label=\"List dialog\">' +\n *            '  <md-dialog-content>'+\n *            '    <md-list>'+\n *            '      <md-list-item ng-repeat=\"item in items\">'+\n *            '       <p>Number {{item}}</p>' +\n *            '      </md-item>'+\n *            '    </md-list>'+\n *            '  </md-dialog-content>' +\n *            '  <div class=\"md-actions\">' +\n *            '    <md-button ng-click=\"closeDialog()\" class=\"md-primary\">' +\n *            '      Close Dialog' +\n *            '    </md-button>' +\n *            '  </div>' +\n *            '</md-dialog>',\n *          locals: {\n *            items: $scope.items\n *          },\n *          controller: DialogController\n *       });\n *       function DialogController(scope, $mdDialog, items) {\n *         scope.items = items;\n *         scope.closeDialog = function() {\n *           $mdDialog.hide();\n *         }\n *       }\n *     }\n *\n * })(angular);\n * </hljs>\n *\n * ### JavaScript: promise API syntax, custom dialog template\n * <hljs lang=\"js\">\n * (function(angular, undefined){\n *   \"use strict\";\n *\n *   angular\n *     .module('demoApp', ['ngMaterial'])\n *     .controller('EmployeeController', EmployeeEditor)\n *     .controller('GreetingController', GreetingController);\n *\n *   // Fictitious Employee Editor to show how to use simple and complex dialogs.\n *\n *   function EmployeeEditor($scope, $mdDialog) {\n *     var alert;\n *\n *     $scope.showAlert = showAlert;\n *     $scope.closeAlert = closeAlert;\n *     $scope.showGreeting = showCustomGreeting;\n *\n *     $scope.hasAlert = function() { return !!alert };\n *     $scope.userName = $scope.userName || 'Bobby';\n *\n *     // Dialog #1 - Show simple alert dialog and cache\n *     // reference to dialog instance\n *\n *     function showAlert() {\n *       alert = $mdDialog.alert()\n *         .title('Attention, ' + $scope.userName)\n *         .content('This is an example of how easy dialogs can be!')\n *         .ok('Close');\n *\n *       $mdDialog\n *           .show( alert )\n *           .finally(function() {\n *             alert = undefined;\n *           });\n *     }\n *\n *     // Close the specified dialog instance and resolve with 'finished' flag\n *     // Normally this is not needed, just use '$mdDialog.hide()' to close\n *     // the most recent dialog popup.\n *\n *     function closeAlert() {\n *       $mdDialog.hide( alert, \"finished\" );\n *       alert = undefined;\n *     }\n *\n *     // Dialog #2 - Demonstrate more complex dialogs construction and popup.\n *\n *     function showCustomGreeting($event) {\n *         $mdDialog.show({\n *           targetEvent: $event,\n *           template:\n *             '<md-dialog>' +\n *\n *             '  <md-dialog-content>Hello {{ employee }}!</md-dialog-content>' +\n *\n *             '  <div class=\"md-actions\">' +\n *             '    <md-button ng-click=\"closeDialog()\" class=\"md-primary\">' +\n *             '      Close Greeting' +\n *             '    </md-button>' +\n *             '  </div>' +\n *             '</md-dialog>',\n *           controller: 'GreetingController',\n *           onComplete: afterShowAnimation,\n *           locals: { employee: $scope.userName }\n *         });\n *\n *         // When the 'enter' animation finishes...\n *\n *         function afterShowAnimation(scope, element, options) {\n *            // post-show code here: DOM element focus, etc.\n *         }\n *     }\n *\n *     // Dialog #3 - Demonstrate use of ControllerAs and passing $scope to dialog\n *     //             Here we used ng-controller=\"GreetingController as vm\" and\n *     //             $scope.vm === <controller instance>\n *\n *     function showCustomGreeting() {\n *\n *        $mdDialog.show({\n *           clickOutsideToClose: true,\n *\n *           scope: $scope,        // use parent scope in template\n *           preserveScope: true,  // do not forget this if use parent scope\n\n *           // Since GreetingController is instantiated with ControllerAs syntax\n *           // AND we are passing the parent '$scope' to the dialog, we MUST\n *           // use 'vm.<xxx>' in the template markup\n *\n *           template: '<md-dialog>' +\n *                     '  <md-dialog-content>' +\n *                     '     Hi There {{vm.employee}}' +\n *                     '  </md-dialog-content>' +\n *                     '</md-dialog>',\n *\n *           controller: function DialogController($scope, $mdDialog) {\n *             $scope.closeDialog = function() {\n *               $mdDialog.hide();\n *             }\n *           }\n *        });\n *     }\n *\n *   }\n *\n *   // Greeting controller used with the more complex 'showCustomGreeting()' custom dialog\n *\n *   function GreetingController($scope, $mdDialog, employee) {\n *     // Assigned from construction <code>locals</code> options...\n *     $scope.employee = employee;\n *\n *     $scope.closeDialog = function() {\n *       // Easily hides most recent dialog shown...\n *       // no specific instance reference is needed.\n *       $mdDialog.hide();\n *     };\n *   }\n *\n * })(angular);\n * </hljs>\n */\n\n /**\n * @ngdoc method\n * @name $mdDialog#alert\n *\n * @description\n * Builds a preconfigured dialog with the specified message.\n *\n * @returns {obj} an `$mdDialogPreset` with the chainable configuration methods:\n *\n * - $mdDialogPreset#title(string) - sets title to string\n * - $mdDialogPreset#content(string) - sets content / message to string\n * - $mdDialogPreset#ok(string) - sets okay button text to string\n * - $mdDialogPreset#theme(string) - sets the theme of the dialog\n *\n */\n\n /**\n * @ngdoc method\n * @name $mdDialog#confirm\n *\n * @description\n * Builds a preconfigured dialog with the specified message. You can call show and the promise returned\n * will be resolved only if the user clicks the confirm action on the dialog.\n *\n * @returns {obj} an `$mdDialogPreset` with the chainable configuration methods:\n *\n * Additionally, it supports the following methods:\n *\n * - $mdDialogPreset#title(string) - sets title to string\n * - $mdDialogPreset#content(string) - sets content / message to string\n * - $mdDialogPreset#ok(string) - sets okay button text to string\n * - $mdDialogPreset#cancel(string) - sets cancel button text to string\n * - $mdDialogPreset#theme(string) - sets the theme of the dialog\n *\n */\n\n/**\n * @ngdoc method\n * @name $mdDialog#show\n *\n * @description\n * Show a dialog with the specified options.\n *\n * @param {object} optionsOrPreset Either provide an `$mdDialogPreset` returned from `alert()`, and\n * `confirm()`, or an options object with the following properties:\n *   - `templateUrl` - `{string=}`: The url of a template that will be used as the content\n *   of the dialog.\n *   - `template` - `{string=}`: Same as templateUrl, except this is an actual template string.\n *   - `targetEvent` - `{DOMClickEvent=}`: A click's event object. When passed in as an option,\n *     the location of the click will be used as the starting point for the opening animation\n *     of the the dialog.\n *   - `scope` - `{object=}`: the scope to link the template / controller to. If none is specified,\n *     it will create a new isolate scope.\n *     This scope will be destroyed when the dialog is removed unless `preserveScope` is set to true.\n *   - `preserveScope` - `{boolean=}`: whether to preserve the scope when the element is removed. Default is false\n *   - `disableParentScroll` - `{boolean=}`: Whether to disable scrolling while the dialog is open.\n *     Default true.\n *   - `hasBackdrop` - `{boolean=}`: Whether there should be an opaque backdrop behind the dialog.\n *     Default true.\n *   - `clickOutsideToClose` - `{boolean=}`: Whether the user can click outside the dialog to\n *     close it. Default false.\n *   - `escapeToClose` - `{boolean=}`: Whether the user can press escape to close the dialog.\n *     Default true.\n *   - `focusOnOpen` - `{boolean=}`: An option to override focus behavior on open. Only disable if\n *     focusing some other way, as focus management is required for dialogs to be accessible.\n *     Defaults to true.\n *   - `controller` - `{string=}`: The controller to associate with the dialog. The controller\n *     will be injected with the local `$mdDialog`, which passes along a scope for the dialog.\n *   - `locals` - `{object=}`: An object containing key/value pairs. The keys will be used as names\n *     of values to inject into the controller. For example, `locals: {three: 3}` would inject\n *     `three` into the controller, with the value 3. If `bindToController` is true, they will be\n *     copied to the controller instead.\n *   - `bindToController` - `bool`: bind the locals to the controller, instead of passing them in.\n *     These values will not be available until after initialization.\n *   - `resolve` - `{object=}`: Similar to locals, except it takes promises as values, and the\n *     dialog will not open until all of the promises resolve.\n *   - `controllerAs` - `{string=}`: An alias to assign the controller to on the scope.\n *   - `parent` - `{element=}`: The element to append the dialog to. Defaults to appending\n *     to the root element of the application.\n *   - `onComplete` `{function=}`: Callback function used to announce when the show() action is\n *     finished.\n *\n * @returns {promise} A promise that can be resolved with `$mdDialog.hide()` or\n * rejected with `$mdDialog.cancel()`.\n */\n\n/**\n * @ngdoc method\n * @name $mdDialog#hide\n *\n * @description\n * Hide an existing dialog and resolve the promise returned from `$mdDialog.show()`.\n *\n * @param {*=} response An argument for the resolved promise.\n */\n\n/**\n * @ngdoc method\n * @name $mdDialog#cancel\n *\n * @description\n * Hide an existing dialog and reject the promise returned from `$mdDialog.show()`.\n *\n * @param {*=} response An argument for the rejected promise.\n */\n\nfunction MdDialogProvider($$interimElementProvider) {\n\n  var alertDialogMethods = ['title', 'content', 'ariaLabel', 'ok'];\n\n  advancedDialogOptions.$inject = [\"$mdDialog\", \"$mdTheming\"];\n  dialogDefaultOptions.$inject = [\"$mdAria\", \"$document\", \"$mdUtil\", \"$mdConstant\", \"$mdTheming\", \"$mdDialog\", \"$timeout\", \"$rootElement\", \"$animate\", \"$$rAF\", \"$q\"];\n  return $$interimElementProvider('$mdDialog')\n    .setDefaults({\n      methods: ['disableParentScroll', 'hasBackdrop', 'clickOutsideToClose', 'escapeToClose', 'targetEvent', 'parent'],\n      options: dialogDefaultOptions\n    })\n    .addPreset('alert', {\n      methods: ['title', 'content', 'ariaLabel', 'ok', 'theme'],\n      options: advancedDialogOptions\n    })\n    .addPreset('confirm', {\n      methods: ['title', 'content', 'ariaLabel', 'ok', 'cancel', 'theme'],\n      options: advancedDialogOptions\n    });\n\n  /* @ngInject */\n  function advancedDialogOptions($mdDialog, $mdTheming) {\n    return {\n      template: [\n        '<md-dialog md-theme=\"{{ dialog.theme }}\" aria-label=\"{{ dialog.ariaLabel }}\">',\n          '<md-dialog-content role=\"document\" tabIndex=\"-1\">',\n            '<h2 class=\"md-title\">{{ dialog.title }}</h2>',\n            '<p>{{ dialog.content }}</p>',\n          '</md-dialog-content>',\n          '<div class=\"md-actions\">',\n            '<md-button ng-if=\"dialog.$type == \\'confirm\\'\"' +\n                      ' ng-click=\"dialog.abort()\" class=\"md-primary\">',\n              '{{ dialog.cancel }}',\n            '</md-button>',\n            '<md-button ng-click=\"dialog.hide()\" class=\"md-primary\">',\n              '{{ dialog.ok }}',\n            '</md-button>',\n          '</div>',\n        '</md-dialog>'\n      ].join(''),\n      controller: function mdDialogCtrl() {\n        this.hide = function() {\n          $mdDialog.hide(true);\n        };\n        this.abort = function() {\n          $mdDialog.cancel();\n        };\n      },\n      controllerAs: 'dialog',\n      bindToController: true,\n      theme: $mdTheming.defaultTheme()\n    };\n  }\n\n  /* @ngInject */\n  function dialogDefaultOptions($mdAria, $document, $mdUtil, $mdConstant, $mdTheming, $mdDialog, $timeout, $rootElement, $animate, $$rAF, $q) {\n    return {\n      hasBackdrop: true,\n      isolateScope: true,\n      onShow: onShow,\n      onRemove: onRemove,\n      clickOutsideToClose: false,\n      escapeToClose: true,\n      targetEvent: null,\n      focusOnOpen: true,\n      disableParentScroll: true,\n      transformTemplate: function(template) {\n        return '<div class=\"md-dialog-container\">' + template + '</div>';\n      }\n    };\n\n    function trapFocus(ev) {\n      var dialog = document.querySelector('md-dialog');\n\n      if (dialog && !dialog.contains(ev.target)) {\n        ev.stopImmediatePropagation();\n        dialog.focus();\n      }\n    }\n\n    // On show method for dialogs\n    function onShow(scope, element, options) {\n      angular.element($document[0].body).addClass('md-dialog-is-showing');\n      element = $mdUtil.extractElementByName(element, 'md-dialog');\n\n      // Incase the user provides a raw dom element, always wrap it in jqLite\n      options.parent = angular.element(options.parent);\n\n      options.popInTarget = angular.element((options.targetEvent || {}).target);\n      var closeButton = findCloseButton();\n\n      if (options.hasBackdrop) {\n        // Fix for IE 10\n        var computeFrom = (options.parent[0] == $document[0].body && $document[0].documentElement\n                           && $document[0].documentElement.scrollTop) ? angular.element($document[0].documentElement) : options.parent;\n        var parentOffset = computeFrom.prop('scrollTop');\n        options.backdrop = angular.element('<md-backdrop class=\"md-dialog-backdrop md-opaque\">');\n        options.backdrop.css('top', parentOffset +'px');\n        $mdTheming.inherit(options.backdrop, options.parent);\n        $animate.enter(options.backdrop, options.parent);\n        element.css('top', parentOffset +'px');\n      }\n\n      var role = 'dialog',\n          elementToFocus = closeButton;\n\n      if (options.$type === 'alert') {\n        role = 'alertdialog';\n        elementToFocus = element.find('md-dialog-content');\n      }\n\n      configureAria(element.find('md-dialog'), role, options);\n\n      document.addEventListener('focus', trapFocus, true);\n\n      if (options.disableParentScroll) {\n        options.lastOverflow = options.parent.css('overflow');\n        options.parent.css('overflow', 'hidden');\n      }\n\n      return dialogPopIn(\n        element,\n        options.parent,\n        options.popInTarget && options.popInTarget.length && options.popInTarget\n      )\n      .then(function() {\n\n        applyAriaToSiblings(element, true);\n\n        if (options.escapeToClose) {\n          options.rootElementKeyupCallback = function(e) {\n            if (e.keyCode === $mdConstant.KEY_CODE.ESCAPE) {\n              $timeout($mdDialog.cancel);\n            }\n          };\n          $rootElement.on('keyup', options.rootElementKeyupCallback);\n        }\n\n        if (options.clickOutsideToClose) {\n          options.dialogClickOutsideCallback = function(ev) {\n            // Only close if we click the flex container outside the backdrop\n            if (ev.target === element[0]) {\n              $timeout($mdDialog.cancel);\n            }\n          };\n          element.on('click', options.dialogClickOutsideCallback);\n        }\n\n        if (options.focusOnOpen) {\n          elementToFocus.focus();\n        }\n      });\n\n\n      function findCloseButton() {\n        //If no element with class dialog-close, try to find the last\n        //button child in md-actions and assume it is a close button\n        var closeButton = element[0].querySelector('.dialog-close');\n        if (!closeButton) {\n          var actionButtons = element[0].querySelectorAll('.md-actions button');\n          closeButton = actionButtons[ actionButtons.length - 1 ];\n        }\n        return angular.element(closeButton);\n      }\n\n    }\n\n    // On remove function for all dialogs\n    function onRemove(scope, element, options) {\n      angular.element($document[0].body).removeClass('md-dialog-is-showing');\n\n      if (options.backdrop) {\n        $animate.leave(options.backdrop);\n      }\n      if (options.disableParentScroll) {\n        options.parent.css('overflow', options.lastOverflow);\n        delete options.lastOverflow;\n      }\n      if (options.escapeToClose) {\n        $rootElement.off('keyup', options.rootElementKeyupCallback);\n      }\n      if (options.clickOutsideToClose) {\n        element.off('click', options.dialogClickOutsideCallback);\n      }\n\n      applyAriaToSiblings(element, false);\n\n      document.removeEventListener('focus', trapFocus, true);\n\n      return dialogPopOut(\n        element,\n        options.parent,\n        options.popInTarget && options.popInTarget.length && options.popInTarget\n      ).then(function() {\n        element.remove();\n        options.popInTarget && options.popInTarget.focus();\n      });\n\n    }\n\n    /**\n     * Inject ARIA-specific attributes appropriate for Dialogs\n     */\n    function configureAria(element, role, options) {\n\n      element.attr({\n        'role': role,\n        'tabIndex': '-1'\n      });\n\n      var dialogContent = element.find('md-dialog-content');\n      if (dialogContent.length === 0){\n        dialogContent = element;\n      }\n\n      var dialogId = element.attr('id') || ('dialog_' + $mdUtil.nextUid());\n      dialogContent.attr('id', dialogId);\n      element.attr('aria-describedby', dialogId);\n\n      if (options.ariaLabel) {\n        $mdAria.expect(element, 'aria-label', options.ariaLabel);\n      }\n      else {\n        $mdAria.expectAsync(element, 'aria-label', function() {\n          var words = dialogContent.text().split(/\\s+/);\n          if (words.length > 3) words = words.slice(0,3).concat('...');\n          return words.join(' ');\n        });\n      }\n    }\n    /**\n     * Utility function to filter out raw DOM nodes\n     */\n    function isNodeOneOf(elem, nodeTypeArray) {\n      if (nodeTypeArray.indexOf(elem.nodeName) !== -1) {\n        return true;\n      }\n    }\n    /**\n     * Walk DOM to apply or remove aria-hidden on sibling nodes\n     * and parent sibling nodes\n     *\n     * Prevents screen reader interaction behind modal window\n     * on swipe interfaces\n     */\n    function applyAriaToSiblings(element, value) {\n      var attribute = 'aria-hidden';\n\n      // get raw DOM node\n      element = element[0];\n\n      function walkDOM(element) {\n        while (element.parentNode) {\n          if (element === document.body) {\n            return;\n          }\n          var children = element.parentNode.children;\n          for (var i = 0; i < children.length; i++) {\n            // skip over child if it is an ascendant of the dialog\n            // or a script or style tag\n            if (element !== children[i] && !isNodeOneOf(children[i], ['SCRIPT', 'STYLE'])) {\n              children[i].setAttribute(attribute, value);\n            }\n          }\n\n          walkDOM(element = element.parentNode);\n        }\n      }\n      walkDOM(element);\n    }\n\n    function dialogPopIn(container, parentElement, clickElement) {\n      var dialogEl = container.find('md-dialog');\n\n      parentElement.append(container);\n      transformToClickElement(dialogEl, clickElement);\n\n      $$rAF(function() {\n        dialogEl.addClass('transition-in')\n          .css($mdConstant.CSS.TRANSFORM, '');\n      });\n\n      return $mdUtil.transitionEndPromise(dialogEl);\n    }\n\n    function dialogPopOut(container, parentElement, clickElement) {\n      var dialogEl = container.find('md-dialog');\n\n      dialogEl.addClass('transition-out').removeClass('transition-in');\n      transformToClickElement(dialogEl, clickElement);\n\n      return $mdUtil.transitionEndPromise(dialogEl);\n    }\n\n    function transformToClickElement(dialogEl, clickElement) {\n      if (clickElement) {\n        var clickRect = clickElement[0].getBoundingClientRect();\n        var dialogRect = dialogEl[0].getBoundingClientRect();\n\n        var scaleX = Math.min(0.5, clickRect.width / dialogRect.width);\n        var scaleY = Math.min(0.5, clickRect.height / dialogRect.height);\n\n        dialogEl.css($mdConstant.CSS.TRANSFORM, 'translate3d(' +\n          (-dialogRect.left + clickRect.left + clickRect.width/2 - dialogRect.width/2) + 'px,' +\n          (-dialogRect.top + clickRect.top + clickRect.height/2 - dialogRect.height/2) + 'px,' +\n          '0) scale(' + scaleX + ',' + scaleY + ')'\n        );\n      }\n    }\n\n    function dialogTransitionEnd(dialogEl) {\n      var deferred = $q.defer();\n      dialogEl.on($mdConstant.CSS.TRANSITIONEND, finished);\n      function finished(ev) {\n        //Make sure this transitionend didn't bubble up from a child\n        if (ev.target === dialogEl[0]) {\n          dialogEl.off($mdConstant.CSS.TRANSITIONEND, finished);\n          deferred.resolve();\n        }\n      }\n      return deferred.promise;\n    }\n\n  }\n}\nMdDialogProvider.$inject = [\"$$interimElementProvider\"];\n\n})();\n(function(){\n\"use strict\";\n\n/**\n * @ngdoc module\n * @name material.components.divider\n * @description Divider module!\n */\nangular.module('material.components.divider', [\n  'material.core'\n])\n  .directive('mdDivider', MdDividerDirective);\n\n/**\n * @ngdoc directive\n * @name mdDivider\n * @module material.components.divider\n * @restrict E\n *\n * @description\n * Dividers group and separate content within lists and page layouts using strong visual and spatial distinctions. This divider is a thin rule, lightweight enough to not distract the user from content.\n *\n * @param {boolean=} md-inset Add this attribute to activate the inset divider style.\n * @usage\n * <hljs lang=\"html\">\n * <md-divider></md-divider>\n *\n * <md-divider md-inset></md-divider>\n * </hljs>\n *\n */\nfunction MdDividerDirective($mdTheming) {\n  return {\n    restrict: 'E',\n    link: $mdTheming\n  };\n}\nMdDividerDirective.$inject = [\"$mdTheming\"];\n\n})();\n(function(){\n\"use strict\";\n\n/**\n * @ngdoc module\n * @name material.components.gridList\n */\nangular.module('material.components.gridList', ['material.core'])\n       .directive('mdGridList', GridListDirective)\n       .directive('mdGridTile', GridTileDirective)\n       .directive('mdGridTileFooter', GridTileCaptionDirective)\n       .directive('mdGridTileHeader', GridTileCaptionDirective)\n       .factory('$mdGridLayout', GridLayoutFactory);\n\n/**\n * @ngdoc directive\n * @name mdGridList\n * @module material.components.gridList\n * @restrict E\n * @description\n * Grid lists are an alternative to standard list views. Grid lists are distinct\n * from grids used for layouts and other visual presentations.\n *\n * A grid list is best suited to presenting a homogenous data type, typically\n * images, and is optimized for visual comprehension and differentiating between\n * like data types.\n *\n * A grid list is a continuous element consisting of tessellated, regular\n * subdivisions called cells that contain tiles (`md-grid-tile`).\n *\n * <img src=\"//material-design.storage.googleapis.com/publish/v_2/material_ext_publish/0Bx4BSt6jniD7OVlEaXZ5YmU1Xzg/components_grids_usage2.png\"\n *    style=\"width: 300px; height: auto; margin-right: 16px;\" alt=\"Concept of grid explained visually\">\n * <img src=\"//material-design.storage.googleapis.com/publish/v_2/material_ext_publish/0Bx4BSt6jniD7VGhsOE5idWlJWXM/components_grids_usage3.png\"\n *    style=\"width: 300px; height: auto;\" alt=\"Grid concepts legend\">\n *\n * Cells are arrayed vertically and horizontally within the grid.\n *\n * Tiles hold content and can span one or more cells vertically or horizontally.\n *\n * ### Responsive Attributes\n *\n * The `md-grid-list` directive supports \"responsive\" attributes, which allow\n * different `md-cols`, `md-gutter` and `md-row-height` values depending on the\n * currently matching media query (as defined in `$mdConstant.MEDIA`).\n *\n * In order to set a responsive attribute, first define the fallback value with\n * the standard attribute name, then add additional attributes with the\n * following convention: `{base-attribute-name}-{media-query-name}=\"{value}\"`\n * (ie. `md-cols-lg=\"8\"`)\n *\n * @param {number} md-cols Number of columns in the grid.\n * @param {string} md-row-height One of\n * <ul>\n *   <li>CSS length - Fixed height rows (eg. `8px` or `1rem`)</li>\n *   <li>`{width}:{height}` - Ratio of width to height (eg.\n *   `md-row-height=\"16:9\"`)</li>\n *   <li>`\"fit\"` - Height will be determined by subdividing the available\n *   height by the number of rows</li>\n * </ul>\n * @param {string=} md-gutter The amount of space between tiles in CSS units\n *     (default 1px)\n * @param {expression=} md-on-layout Expression to evaluate after layout. Event\n *     object is available as `$event`, and contains performance information.\n *\n * @usage\n * Basic:\n * <hljs lang=\"html\">\n * <md-grid-list md-cols=\"5\" md-gutter=\"1em\" md-row-height=\"4:3\">\n *   <md-grid-tile></md-grid-tile>\n * </md-grid-list>\n * </hljs>\n *\n * Fixed-height rows:\n * <hljs lang=\"html\">\n * <md-grid-list md-cols=\"4\" md-row-height=\"200px\" ...>\n *   <md-grid-tile></md-grid-tile>\n * </md-grid-list>\n * </hljs>\n *\n * Fit rows:\n * <hljs lang=\"html\">\n * <md-grid-list md-cols=\"4\" md-row-height=\"fit\" style=\"height: 400px;\" ...>\n *   <md-grid-tile></md-grid-tile>\n * </md-grid-list>\n * </hljs>\n *\n * Using responsive attributes:\n * <hljs lang=\"html\">\n * <md-grid-list\n *     md-cols-sm=\"2\"\n *     md-cols-md=\"4\"\n *     md-cols-lg=\"8\"\n *     md-cols-gt-lg=\"12\"\n *     ...>\n *   <md-grid-tile></md-grid-tile>\n * </md-grid-list>\n * </hljs>\n */\nfunction GridListDirective($interpolate, $mdConstant, $mdGridLayout, $mdMedia) {\n  return {\n    restrict: 'E',\n    controller: GridListController,\n    scope: {\n      mdOnLayout: '&'\n    },\n    link: postLink\n  };\n\n  function postLink(scope, element, attrs, ctrl) {\n    // Apply semantics\n    element.attr('role', 'list');\n\n    // Provide the controller with a way to trigger layouts.\n    ctrl.layoutDelegate = layoutDelegate;\n\n    var invalidateLayout = angular.bind(ctrl, ctrl.invalidateLayout),\n        unwatchAttrs = watchMedia();\n      scope.$on('$destroy', unwatchMedia);\n\n    /**\n     * Watches for changes in media, invalidating layout as necessary.\n     */\n    function watchMedia() {\n      for (var mediaName in $mdConstant.MEDIA) {\n        $mdMedia(mediaName); // initialize\n        $mdMedia.getQuery($mdConstant.MEDIA[mediaName])\n            .addListener(invalidateLayout);\n      }\n      return $mdMedia.watchResponsiveAttributes(\n          ['md-cols', 'md-row-height'], attrs, layoutIfMediaMatch);\n    }\n\n    function unwatchMedia() {\n      ctrl.layoutDelegate = angular.noop;\n\n      unwatchAttrs();\n      for (var mediaName in $mdConstant.MEDIA) {\n        $mdMedia.getQuery($mdConstant.MEDIA[mediaName])\n            .removeListener(invalidateLayout);\n      }\n    }\n\n    /**\n     * Performs grid layout if the provided mediaName matches the currently\n     * active media type.\n     */\n    function layoutIfMediaMatch(mediaName) {\n      if (mediaName == null) {\n        // TODO(shyndman): It would be nice to only layout if we have\n        // instances of attributes using this media type\n        ctrl.invalidateLayout();\n      } else if ($mdMedia(mediaName)) {\n        ctrl.invalidateLayout();\n      }\n    }\n\n    var lastLayoutProps;\n\n    /**\n     * Invokes the layout engine, and uses its results to lay out our\n     * tile elements.\n     *\n     * @param {boolean} tilesInvalidated Whether tiles have been\n     *    added/removed/moved since the last layout. This is to avoid situations\n     *    where tiles are replaced with properties identical to their removed\n     *    counterparts.\n     */\n    function layoutDelegate(tilesInvalidated) {\n      var tiles = getTileElements();\n      var props = {\n        tileSpans: getTileSpans(tiles),\n        colCount: getColumnCount(),\n        rowMode: getRowMode(),\n        rowHeight: getRowHeight(),\n        gutter: getGutter()\n      };\n\n      if (!tilesInvalidated && angular.equals(props, lastLayoutProps)) {\n        return;\n      }\n\n      var performance =\n        $mdGridLayout(props.colCount, props.tileSpans, tiles)\n          .map(function(tilePositions, rowCount) {\n            return {\n              grid: {\n                element: element,\n                style: getGridStyle(props.colCount, rowCount,\n                    props.gutter, props.rowMode, props.rowHeight)\n              },\n              tiles: tilePositions.map(function(ps, i) {\n                return {\n                  element: angular.element(tiles[i]),\n                  style: getTileStyle(ps.position, ps.spans,\n                      props.colCount, props.rowCount,\n                      props.gutter, props.rowMode, props.rowHeight)\n                }\n              })\n            }\n          })\n          .reflow()\n          .performance();\n\n      // Report layout\n      scope.mdOnLayout({\n        $event: {\n          performance: performance\n        }\n      });\n\n      lastLayoutProps = props;\n    }\n\n    // Use $interpolate to do some simple string interpolation as a convenience.\n\n    var startSymbol = $interpolate.startSymbol();\n    var endSymbol = $interpolate.endSymbol();\n\n    // Returns an expression wrapped in the interpolator's start and end symbols.\n    function expr(exprStr) {\n      return startSymbol + exprStr + endSymbol;\n    }\n\n    // The amount of space a single 1x1 tile would take up (either width or height), used as\n    // a basis for other calculations. This consists of taking the base size percent (as would be\n    // if evenly dividing the size between cells), and then subtracting the size of one gutter.\n    // However, since there are no gutters on the edges, each tile only uses a fration\n    // (gutterShare = numGutters / numCells) of the gutter size. (Imagine having one gutter per\n    // tile, and then breaking up the extra gutter on the edge evenly among the cells).\n    var UNIT = $interpolate(expr('share') + '% - (' + expr('gutter') + ' * ' + expr('gutterShare') + ')');\n\n    // The horizontal or vertical position of a tile, e.g., the 'top' or 'left' property value.\n    // The position comes the size of a 1x1 tile plus gutter for each previous tile in the\n    // row/column (offset).\n    var POSITION  = $interpolate('calc((' + expr('unit') + ' + ' + expr('gutter') + ') * ' + expr('offset') + ')');\n\n    // The actual size of a tile, e.g., width or height, taking rowSpan or colSpan into account.\n    // This is computed by multiplying the base unit by the rowSpan/colSpan, and then adding back\n    // in the space that the gutter would normally have used (which was already accounted for in\n    // the base unit calculation).\n    var DIMENSION = $interpolate('calc((' + expr('unit') + ') * ' + expr('span') + ' + (' + expr('span') + ' - 1) * ' + expr('gutter') + ')');\n\n    /**\n     * Gets the styles applied to a tile element described by the given parameters.\n     * @param {{row: number, col: number}} position The row and column indices of the tile.\n     * @param {{row: number, col: number}} spans The rowSpan and colSpan of the tile.\n     * @param {number} colCount The number of columns.\n     * @param {number} rowCount The number of rows.\n     * @param {string} gutter The amount of space between tiles. This will be something like\n     *     '5px' or '2em'.\n     * @param {string} rowMode The row height mode. Can be one of:\n     *     'fixed': all rows have a fixed size, given by rowHeight,\n     *     'ratio': row height defined as a ratio to width, or\n     *     'fit': fit to the grid-list element height, divinding evenly among rows.\n     * @param {string|number} rowHeight The height of a row. This is only used for 'fixed' mode and\n     *     for 'ratio' mode. For 'ratio' mode, this is the *ratio* of width-to-height (e.g., 0.75).\n     * @returns {Object} Map of CSS properties to be applied to the style element. Will define\n     *     values for top, left, width, height, marginTop, and paddingTop.\n     */\n    function getTileStyle(position, spans, colCount, rowCount, gutter, rowMode, rowHeight) {\n      // TODO(shyndman): There are style caching opportunities here.\n\n      // Percent of the available horizontal space that one column takes up.\n      var hShare = (1 / colCount) * 100;\n\n      // Fraction of the gutter size that each column takes up.\n      var hGutterShare = (colCount - 1) / colCount;\n\n      // Base horizontal size of a column.\n      var hUnit = UNIT({share: hShare, gutterShare: hGutterShare, gutter: gutter});\n\n      // The width and horizontal position of each tile is always calculated the same way, but the\n      // height and vertical position depends on the rowMode.\n      var style = {\n        left: POSITION({ unit: hUnit, offset: position.col, gutter: gutter }),\n        width: DIMENSION({ unit: hUnit, span: spans.col, gutter: gutter }),\n        // resets\n        paddingTop: '',\n        marginTop: '',\n        top: '',\n        height: ''\n      };\n\n      switch (rowMode) {\n        case 'fixed':\n          // In fixed mode, simply use the given rowHeight.\n          style.top = POSITION({ unit: rowHeight, offset: position.row, gutter: gutter });\n          style.height = DIMENSION({ unit: rowHeight, span: spans.row, gutter: gutter });\n          break;\n\n        case 'ratio':\n          // Percent of the available vertical space that one row takes up. Here, rowHeight holds\n          // the ratio value. For example, if the width:height ratio is 4:3, rowHeight = 1.333.\n          var vShare = hShare / rowHeight;\n\n          // Base veritcal size of a row.\n          var vUnit = UNIT({ share: vShare, gutterShare: hGutterShare, gutter: gutter });\n\n          // padidngTop and marginTop are used to maintain the given aspect ratio, as\n          // a percentage-based value for these properties is applied to the *width* of the\n          // containing block. See http://www.w3.org/TR/CSS2/box.html#margin-properties\n          style.paddingTop = DIMENSION({ unit: vUnit, span: spans.row, gutter: gutter});\n          style.marginTop = POSITION({ unit: vUnit, offset: position.row, gutter: gutter });\n          break;\n\n        case 'fit':\n          // Fraction of the gutter size that each column takes up.\n          var vGutterShare = (rowCount - 1) / rowCount;\n\n          // Percent of the available vertical space that one row takes up.\n          var vShare = (1 / rowCount) * 100;\n\n          // Base vertical size of a row.\n          var vUnit = UNIT({share: vShare, gutterShare: vGutterShare, gutter: gutter});\n\n          style.top = POSITION({unit: vUnit, offset: position.row, gutter: gutter});\n          style.height = DIMENSION({unit: vUnit, span: spans.row, gutter: gutter});\n          break;\n      }\n\n      return style;\n    }\n\n    function getGridStyle(colCount, rowCount, gutter, rowMode, rowHeight) {\n      var style = {\n        height: '',\n        paddingBottom: ''\n      };\n\n      switch(rowMode) {\n        case 'fixed':\n          style.height = DIMENSION({ unit: rowHeight, span: rowCount, gutter: gutter });\n          break;\n\n        case 'ratio':\n          // rowHeight is width / height\n          var hGutterShare = colCount === 1 ? 0 : (colCount - 1) / colCount,\n              hShare = (1 / colCount) * 100,\n              vShare = hShare * (1 / rowHeight),\n              vUnit = UNIT({ share: vShare, gutterShare: hGutterShare, gutter: gutter });\n\n          style.paddingBottom = DIMENSION({ unit: vUnit, span: rowCount, gutter: gutter});\n          break;\n\n        case 'fit':\n          // noop, as the height is user set\n          break;\n      }\n\n      return style;\n    }\n\n    function getTileElements() {\n      return [].filter.call(element.children(), function(ele) {\n        return ele.tagName == 'MD-GRID-TILE';\n      });\n    }\n\n    /**\n     * Gets an array of objects containing the rowspan and colspan for each tile.\n     * @returns {Array<{row: number, col: number}>}\n     */\n    function getTileSpans(tileElements) {\n      return [].map.call(tileElements, function(ele) {\n        var ctrl = angular.element(ele).controller('mdGridTile');\n        return {\n          row: parseInt(\n              $mdMedia.getResponsiveAttribute(ctrl.$attrs, 'md-rowspan'), 10) || 1,\n          col: parseInt(\n              $mdMedia.getResponsiveAttribute(ctrl.$attrs, 'md-colspan'), 10) || 1\n        };\n      });\n    }\n\n    function getColumnCount() {\n      var colCount = parseInt($mdMedia.getResponsiveAttribute(attrs, 'md-cols'), 10);\n      if (isNaN(colCount)) {\n        throw 'md-grid-list: md-cols attribute was not found, or contained a non-numeric value';\n      }\n      return colCount;\n    }\n\n    function getGutter() {\n      return applyDefaultUnit($mdMedia.getResponsiveAttribute(attrs, 'md-gutter') || 1);\n    }\n\n    function getRowHeight() {\n      var rowHeight = $mdMedia.getResponsiveAttribute(attrs, 'md-row-height');\n      switch (getRowMode()) {\n        case 'fixed':\n          return applyDefaultUnit(rowHeight);\n        case 'ratio':\n          var whRatio = rowHeight.split(':');\n          return parseFloat(whRatio[0]) / parseFloat(whRatio[1]);\n        case 'fit':\n          return 0; // N/A\n      }\n    }\n\n    function getRowMode() {\n      var rowHeight = $mdMedia.getResponsiveAttribute(attrs, 'md-row-height');\n      if (rowHeight == 'fit') {\n        return 'fit';\n      } else if (rowHeight.indexOf(':') !== -1) {\n        return 'ratio';\n      } else {\n        return 'fixed';\n      }\n    }\n\n    function applyDefaultUnit(val) {\n      return /\\D$/.test(val) ? val : val + 'px';\n    }\n  }\n}\nGridListDirective.$inject = [\"$interpolate\", \"$mdConstant\", \"$mdGridLayout\", \"$mdMedia\"];\n\n/* @ngInject */\nfunction GridListController($timeout) {\n  this.layoutInvalidated = false;\n  this.tilesInvalidated = false;\n  this.$timeout_ = $timeout;\n  this.layoutDelegate = angular.noop;\n}\nGridListController.$inject = [\"$timeout\"];\n\nGridListController.prototype = {\n  invalidateTiles: function() {\n    this.tilesInvalidated = true;\n    this.invalidateLayout();\n  },\n\n  invalidateLayout: function() {\n    if (this.layoutInvalidated) {\n      return;\n    }\n    this.layoutInvalidated = true;\n    this.$timeout_(angular.bind(this, this.layout));\n  },\n\n  layout: function() {\n    try {\n      this.layoutDelegate(this.tilesInvalidated);\n    } finally {\n      this.layoutInvalidated = false;\n      this.tilesInvalidated = false;\n    }\n  }\n};\n\n\n/* @ngInject */\nfunction GridLayoutFactory($mdUtil) {\n  var defaultAnimator = GridTileAnimator;\n\n  /**\n   * Set the reflow animator callback\n   */\n  GridLayout.animateWith = function(customAnimator) {\n    defaultAnimator = !angular.isFunction(customAnimator) ? GridTileAnimator : customAnimator;\n  };\n\n  return GridLayout;\n\n  /**\n   * Publish layout function\n   */\n  function GridLayout(colCount, tileSpans) {\n      var self, layoutInfo, gridStyles, layoutTime, mapTime, reflowTime;\n\n      layoutTime = $mdUtil.time(function() {\n        layoutInfo = calculateGridFor(colCount, tileSpans);\n      });\n\n      return self = {\n\n        /**\n         * An array of objects describing each tile's position in the grid.\n         */\n        layoutInfo: function() {\n          return layoutInfo;\n        },\n\n        /**\n         * Maps grid positioning to an element and a set of styles using the\n         * provided updateFn.\n         */\n        map: function(updateFn) {\n          mapTime = $mdUtil.time(function() {\n            var info = self.layoutInfo();\n            gridStyles = updateFn(info.positioning, info.rowCount);\n          });\n          return self;\n        },\n\n        /**\n         * Default animator simply sets the element.css( <styles> ). An alternate\n         * animator can be provided as an argument. The function has the following\n         * signature:\n         *\n         *    function({grid: {element: JQLite, style: Object}, tiles: Array<{element: JQLite, style: Object}>)\n         */\n        reflow: function(animatorFn) {\n          reflowTime = $mdUtil.time(function() {\n            var animator = animatorFn || defaultAnimator;\n            animator(gridStyles.grid, gridStyles.tiles);\n          });\n          return self;\n        },\n\n        /**\n         * Timing for the most recent layout run.\n         */\n        performance: function() {\n          return {\n            tileCount: tileSpans.length,\n            layoutTime: layoutTime,\n            mapTime: mapTime,\n            reflowTime: reflowTime,\n            totalTime: layoutTime + mapTime + reflowTime\n          };\n        }\n      };\n    }\n\n  /**\n   * Default Gridlist animator simple sets the css for each element;\n   * NOTE: any transitions effects must be manually set in the CSS.\n   * e.g.\n   *\n   *  md-grid-tile {\n   *    transition: all 700ms ease-out 50ms;\n   *  }\n   *\n   */\n  function GridTileAnimator(grid, tiles) {\n    grid.element.css(grid.style);\n    tiles.forEach(function(t) {\n      t.element.css(t.style);\n    })\n  }\n\n  /**\n   * Calculates the positions of tiles.\n   *\n   * The algorithm works as follows:\n   *    An Array<Number> with length colCount (spaceTracker) keeps track of\n   *    available tiling positions, where elements of value 0 represents an\n   *    empty position. Space for a tile is reserved by finding a sequence of\n   *    0s with length <= than the tile's colspan. When such a space has been\n   *    found, the occupied tile positions are incremented by the tile's\n   *    rowspan value, as these positions have become unavailable for that\n   *    many rows.\n   *\n   *    If the end of a row has been reached without finding space for the\n   *    tile, spaceTracker's elements are each decremented by 1 to a minimum\n   *    of 0. Rows are searched in this fashion until space is found.\n   */\n  function calculateGridFor(colCount, tileSpans) {\n    var curCol = 0,\n        curRow = 0,\n        spaceTracker = newSpaceTracker();\n\n    return {\n      positioning: tileSpans.map(function(spans, i) {\n        return {\n          spans: spans,\n          position: reserveSpace(spans, i)\n        };\n      }),\n      rowCount: curRow + Math.max.apply(Math, spaceTracker)\n    };\n\n    function reserveSpace(spans, i) {\n      if (spans.col > colCount) {\n        throw 'md-grid-list: Tile at position ' + i + ' has a colspan ' +\n            '(' + spans.col + ') that exceeds the column count ' +\n            '(' + colCount + ')';\n      }\n\n      var start = 0,\n          end = 0;\n\n      // TODO(shyndman): This loop isn't strictly necessary if you can\n      // determine the minimum number of rows before a space opens up. To do\n      // this, recognize that you've iterated across an entire row looking for\n      // space, and if so fast-forward by the minimum rowSpan count. Repeat\n      // until the required space opens up.\n      while (end - start < spans.col) {\n        if (curCol >= colCount) {\n          nextRow();\n          continue;\n        }\n\n        start = spaceTracker.indexOf(0, curCol);\n        if (start === -1 || (end = findEnd(start + 1)) === -1) {\n          start = end = 0;\n          nextRow();\n          continue;\n        }\n\n        curCol = end + 1;\n      }\n\n      adjustRow(start, spans.col, spans.row);\n      curCol = start + spans.col;\n\n      return {\n        col: start,\n        row: curRow\n      };\n    }\n\n    function nextRow() {\n      curCol = 0;\n      curRow++;\n      adjustRow(0, colCount, -1); // Decrement row spans by one\n    }\n\n    function adjustRow(from, cols, by) {\n      for (var i = from; i < from + cols; i++) {\n        spaceTracker[i] = Math.max(spaceTracker[i] + by, 0);\n      }\n    }\n\n    function findEnd(start) {\n      var i;\n      for (i = start; i < spaceTracker.length; i++) {\n        if (spaceTracker[i] !== 0) {\n          return i;\n        }\n      }\n\n      if (i === spaceTracker.length) {\n        return i;\n      }\n    }\n\n    function newSpaceTracker() {\n      var tracker = [];\n      for (var i = 0; i < colCount; i++) {\n        tracker.push(0);\n      }\n      return tracker;\n    }\n  }\n}\nGridLayoutFactory.$inject = [\"$mdUtil\"];\n\n/**\n * @ngdoc directive\n * @name mdGridTile\n * @module material.components.gridList\n * @restrict E\n * @description\n * Tiles contain the content of an `md-grid-list`. They span one or more grid\n * cells vertically or horizontally, and use `md-grid-tile-{footer,header}` to\n * display secondary content.\n *\n * ### Responsive Attributes\n *\n * The `md-grid-tile` directive supports \"responsive\" attributes, which allow\n * different `md-rowspan` and `md-colspan` values depending on the currently\n * matching media query (as defined in `$mdConstant.MEDIA`).\n *\n * In order to set a responsive attribute, first define the fallback value with\n * the standard attribute name, then add additional attributes with the\n * following convention: `{base-attribute-name}-{media-query-name}=\"{value}\"`\n * (ie. `md-colspan-sm=\"4\"`)\n *\n * @param {number=} md-colspan The number of columns to span (default 1). Cannot\n *    exceed the number of columns in the grid. Supports interpolation.\n * @param {number=} md-rowspan The number of rows to span (default 1). Supports\n *     interpolation.\n *\n * @usage\n * With header:\n * <hljs lang=\"html\">\n * <md-grid-tile>\n *   <md-grid-tile-header>\n *     <h3>This is a header</h3>\n *   </md-grid-tile-header>\n * </md-grid-tile>\n * </hljs>\n *\n * With footer:\n * <hljs lang=\"html\">\n * <md-grid-tile>\n *   <md-grid-tile-footer>\n *     <h3>This is a footer</h3>\n *   </md-grid-tile-footer>\n * </md-grid-tile>\n * </hljs>\n *\n * Spanning multiple rows/columns:\n * <hljs lang=\"html\">\n * <md-grid-tile md-colspan=\"2\" md-rowspan=\"3\">\n * </md-grid-tile>\n * </hljs>\n *\n * Responsive attributes:\n * <hljs lang=\"html\">\n * <md-grid-tile md-colspan=\"1\" md-colspan-sm=\"3\" md-colspan-md=\"5\">\n * </md-grid-tile>\n * </hljs>\n */\nfunction GridTileDirective($mdMedia) {\n  return {\n    restrict: 'E',\n    require: '^mdGridList',\n    template: '<figure ng-transclude></figure>',\n    transclude: true,\n    scope: {},\n    // Simple controller that exposes attributes to the grid directive\n    controller: [\"$attrs\", function($attrs) {\n      this.$attrs = $attrs;\n    }],\n    link: postLink\n  };\n\n  function postLink(scope, element, attrs, gridCtrl) {\n    // Apply semantics\n    element.attr('role', 'listitem');\n\n    // If our colspan or rowspan changes, trigger a layout\n    var unwatchAttrs = $mdMedia.watchResponsiveAttributes(['md-colspan', 'md-rowspan'],\n        attrs, angular.bind(gridCtrl, gridCtrl.invalidateLayout));\n\n    // Tile registration/deregistration\n    gridCtrl.invalidateTiles();\n    scope.$on('$destroy', function() {\n      unwatchAttrs();\n      gridCtrl.invalidateLayout();\n    });\n\n    if (angular.isDefined(scope.$parent.$index)) {\n      scope.$watch(function() { return scope.$parent.$index; },\n        function indexChanged(newIdx, oldIdx) {\n          if (newIdx === oldIdx) {\n            return;\n          }\n          gridCtrl.invalidateTiles();\n        });\n    }\n  }\n}\nGridTileDirective.$inject = [\"$mdMedia\"];\n\n\nfunction GridTileCaptionDirective() {\n  return {\n    template: '<figcaption ng-transclude></figcaption>',\n    transclude: true\n  };\n}\n\n})();\n(function(){\n\"use strict\";\n\n/**\n * @ngdoc module\n * @name material.components.icon\n * @description\n * Icon\n */\nangular.module('material.components.icon', [\n    'material.core'\n  ])\n  .directive('mdIcon', mdIconDirective);\n\n/**\n * @ngdoc directive\n * @name mdIcon\n * @module material.components.icon\n *\n * @restrict E\n *\n * @description\n * The `<md-icon />` directive is an markup element useful for showing an icon based on a font-icon\n * or a SVG. Icons are view-only elements that should not be used directly as buttons; instead nest a `<md-icon />`\n * inside a `md-button` to add hover and click features.\n *\n * When using SVGs, both external SVGs (via URLs) or sets of SVGs [from icon sets] can be\n * easily loaded and used.When use font-icons, developers must following three (3) simple steps:\n *\n * <ol>\n * <li>Load the font library. e.g.<br/>\n *    &lt;link href=\"https://fonts.googleapis.com/icon?family=Material+Icons\"\n *    rel=\"stylesheet\"&gt;\n * </li>\n * <li> Use either (a) font-icon class names or (b) font ligatures to render the font glyph by using its textual name</li>\n * <li> Use &lt;md-icon md-font-icon=\"classname\" /&gt; or <br/>\n *     use &lt;md-icon md-font-library=\"library_style_name\"&gt; textual_name &lt;/md-icon&gt; or <br/>\n *     use &lt;md-icon md-font-library=\"library_style_name\"&gt; numerical_character_reference &lt;/md-icon&gt;\n * </li>\n * </ol>\n *\n * Full details for these steps can be found:\n *\n * <ul>\n * <li>http://google.github.io/material-design-icons/</li>\n * <li>http://google.github.io/material-design-icons/#icon-font-for-the-web</li>\n * </ul>\n *\n * The Material Design icon style <code>.material-icons</code> and the icon font references are published in\n * Material Design Icons:\n *\n * <ul>\n * <li>http://www.google.com/design/icons/</li>\n * <li>https://www.google.com/design/icons/#ic_accessibility</li>\n * </ul>\n *\n * <h2 id=\"material_design_icons\">Material Design Icons</h2>\n * Using the Material Design Icon-Selector, developers can easily and quickly search for a Material Design font-icon and\n * determine its textual name and character reference code. Click on any icon to see the slide-up information\n * panel with details regarding a SVG download or information on the font-icon usage.\n *\n * <a href=\"https://www.google.com/design/icons/#ic_accessibility\" target=\"_blank\" style=\"border-bottom:none;\">\n * <img src=\"https://cloud.githubusercontent.com/assets/210413/7902490/fe8dd14c-0780-11e5-98fb-c821cc6475e6.png\"\n *      alt=\"Material Design Icon-Selector\" style=\"max-width:75%;padding-left:10%\">\n * </a>\n *\n * <span class=\"image_caption\">\n *  Click on the image above to link to the\n *  <a href=\"https://www.google.com/design/icons/#ic_accessibility\" target=\"_blank\">Material Design Icon-Selector</a>.\n * </span>\n *\n * @param {string} md-font-icon String name of CSS icon associated with the font-face will be used\n * to render the icon. Requires the fonts and the named CSS styles to be preloaded.\n * @param {string} md-font-library String name of CSS icon associated with the font-face will be used\n * to render the icon. Requires the fonts and the named CSS styles to be preloaded.\n * @param {string} md-svg-src String URL [or expression ] used to load, cache, and display an external SVG.\n * @param {string} md-svg-icon String name used for lookup of the icon from the internal cache; interpolated strings or\n * expressions may also be used. Specific set names can be used with the syntax `<set name>:<icon name>`.<br/><br/>\n * To use icon sets, developers are required to pre-register the sets using the `$mdIconProvider` service.\n * @param {string=} alt Labels icon for accessibility. If an empty string is provided, icon\n * will be hidden from accessibility layer with `aria-hidden=\"true\"`. If there's no alt on the icon\n * nor a label on the parent element, a warning will be logged to the console.\n *\n * @usage\n * When using SVGs:\n * <hljs lang=\"html\">\n *\n *  <!-- Icon ID; may contain optional icon set prefix; icons must registered using $mdIconProvider -->\n *  <md-icon md-svg-icon=\"social:android\"    alt=\"android \" ></md-icon>\n *\n *  <!-- Icon urls; may be preloaded in templateCache -->\n *  <md-icon md-svg-src=\"/android.svg\"       alt=\"android \" ></md-icon>\n *  <md-icon md-svg-src=\"{{ getAndroid() }}\" alt=\"android \" ></md-icon>\n *\n * </hljs>\n *\n * Use the <code>$mdIconProvider</code> to configure your application with\n * svg iconsets.\n *\n * <hljs lang=\"js\">\n *  angular.module('appSvgIconSets', ['ngMaterial'])\n *    .controller('DemoCtrl', function($scope) {})\n *    .config(function($mdIconProvider) {\n *      $mdIconProvider\n *         .iconSet('social', 'img/icons/sets/social-icons.svg', 24)\n *         .defaultIconSet('img/icons/sets/core-icons.svg', 24);\n *     });\n * </hljs>\n *\n *\n * When using Font Icons with classnames:\n * <hljs lang=\"html\">\n *\n *  <md-icon md-font-icon=\"android\" alt=\"android\" ></md-icon>\n *  <md-icon md-font-icon=\"fa-magic\" class=\"fa\" alt=\"magic wand\"></md-icon>\n *\n * </hljs>\n *\n * When using Font Icons with ligatures:\n * <hljs lang=\"html\">\n *\n *  <md-icon md-font-library=\"material-icons\">face</md-icon>\n *  <md-icon md-font-library=\"material-icons\">#xE87C;</md-icon>\n *  <md-icon md-font-library=\"material-icons\" class=\"md-light md-48\">face</md-icon>\n *\n * </hljs>\n *\n *\n */\nfunction mdIconDirective($mdIcon, $mdTheming, $mdAria, $interpolate ) {\n\n  return {\n    scope: {\n      fontLib: '@mdFontLibrary',\n      fontIcon: '@mdFontIcon',\n      svgIcon: '@mdSvgIcon',\n      svgSrc: '@mdSvgSrc'\n    },\n    restrict: 'E',\n    transclude:true,\n    template: getTemplate,\n    link: postLink\n  };\n\n  function getTemplate(element, attr) {\n    var hasAttrValue = function(key) { return attr[key] && attr[key].length      };\n    var attrValue    = function(key) { return hasAttrValue(key) ? attr[key] : '' };\n\n    // If using font-icons, transclude the ligature or NRCs\n    var tmpl = hasAttrValue('mdFontIcon')    ? '<span class=\"md-font {{classNames}}\" ng-class=\"fontIcon\"></span>' :\n               hasAttrValue('mdFontLibrary') ? '<span ng-transclude></span>' : '';\n\n    // Transpose the mdFontLibrary name to the list of classnames\n    // For example, Material Icons expects classnames like `.material-icons.md-48` instead of `.material-icons .md-48`\n\n    var names = (attrValue('mdFontLibrary')  + ' ' +  attrValue('class')).trim();\n    element.attr('class',names);\n\n    return $interpolate( tmpl )({ classNames: names });\n  }\n\n\n  /**\n   * Directive postLink\n   * Supports embedded SVGs, font-icons, & external SVGs\n   */\n  function postLink(scope, element, attr) {\n    $mdTheming(element);\n\n    // If using a font-icon, then the textual name of the icon itself\n    // provides the aria-label.\n\n    var ariaLabel = attr.alt || scope.fontIcon || scope.svgIcon;\n    var attrName = attr.$normalize(attr.$attr.mdSvgIcon || attr.$attr.mdSvgSrc || '');\n\n    if ( !attr.mdFontLibrary ) {\n      if (attr.alt != '' && !parentsHaveText() ) {\n        $mdAria.expect(element, 'aria-label', ariaLabel);\n        $mdAria.expect(element, 'role', 'img');\n      } else {\n        // Hide from the accessibility layer.\n        $mdAria.expect(element, 'aria-hidden', 'true');\n      }\n    }\n\n    if (attrName) {\n      // Use either pre-configured SVG or URL source, respectively.\n      attr.$observe(attrName, function(attrVal) {\n\n        element.empty();\n        if (attrVal) {\n          $mdIcon(attrVal).then(function(svg) {\n            element.append(svg);\n          });\n        }\n\n      });\n    }\n    function parentsHaveText() {\n      var parent = element.parent();\n      if (parent.attr('aria-label') || parent.text()) {\n        return true;\n      }\n      else if(parent.parent().attr('aria-label') || parent.parent().text()) {\n        return true;\n      }\n      return false;\n    }\n  }\n}\nmdIconDirective.$inject = [\"$mdIcon\", \"$mdTheming\", \"$mdAria\", \"$interpolate\"];\n\n})();\n(function(){\n\"use strict\";\n\n  angular\n    .module('material.components.icon' )\n    .provider('$mdIcon', MdIconProvider);\n\n  /**\n    * @ngdoc service\n    * @name $mdIconProvider\n    * @module material.components.icon\n    *\n    * @description\n    * `$mdIconProvider` is used only to register icon IDs with URLs. These configuration features allow\n    * icons and icon sets to be pre-registered and associated with source URLs **before** the `<md-icon />`\n    * directives are compiled.\n    *\n    * Loading of the actual svg files are deferred to on-demand requests and are loaded\n    * internally by the `$mdIcon` service using the `$http` service. When an SVG is requested by name/ID,\n    * the `$mdIcon` service searches its registry for the associated source URL;\n    * that URL is used to on-demand load and parse the SVG dynamically.\n    *\n    * @usage\n    * <hljs lang=\"js\">\n    *   app.config(function($mdIconProvider) {\n    *\n    *     // Configure URLs for icons specified by [set:]id.\n    *\n    *     $mdIconProvider\n    *          .defaultIconSet('my/app/icons.svg')       // Register a default set of SVG icons\n    *          .iconSet('social', 'my/app/social.svg')   // Register a named icon set of SVGs\n    *          .icon('android', 'my/app/android.svg')    // Register a specific icon (by name)\n    *          .icon('work:chair', 'my/app/chair.svg');  // Register icon in a specific set\n    *   });\n    * </hljs>\n    *\n    * SVG icons and icon sets can be easily pre-loaded and cached using either (a) a build process or (b) a runtime\n    * **startup** process (shown below):\n    *\n    * <hljs lang=\"js\">\n    *   app.config(function($mdIconProvider) {\n    *\n    *     // Register a default set of SVG icon definitions\n    *     $mdIconProvider.defaultIconSet('my/app/icons.svg')\n    *\n    *   })\n    *   .run(function($http, $templateCache){\n    *\n    *     // Pre-fetch icons sources by URL and cache in the $templateCache...\n    *     // subsequent $http calls will look there first.\n    *\n    *     var urls = [ 'imy/app/icons.svg', 'img/icons/android.svg'];\n    *\n    *     angular.forEach(urls, function(url) {\n    *       $http.get(url, {cache: $templateCache});\n    *     });\n    *\n    *   });\n    *\n    * </hljs>\n    *\n    * NOTE: the loaded SVG data is subsequently cached internally for future requests.\n    *\n    */\n\n   /**\n    * @ngdoc method\n    * @name $mdIconProvider#icon\n    *\n    * @description\n    * Register a source URL for a specific icon name; the name may include optional 'icon set' name prefix.\n    * These icons  will later be retrieved from the cache using `$mdIcon( <icon name> )`\n    *\n    * @param {string} id Icon name/id used to register the icon\n    * @param {string} url specifies the external location for the data file. Used internally by `$http` to load the\n    * data or as part of the lookup in `$templateCache` if pre-loading was configured.\n    * @param {string=} iconSize Number indicating the width and height of the icons in the set. All icons\n    * in the icon set must be the same size. Default size is 24.\n    *\n    * @returns {obj} an `$mdIconProvider` reference; used to support method call chains for the API\n    *\n    * @usage\n    * <hljs lang=\"js\">\n    *   app.config(function($mdIconProvider) {\n    *\n    *     // Configure URLs for icons specified by [set:]id.\n    *\n    *     $mdIconProvider\n    *          .icon('android', 'my/app/android.svg')    // Register a specific icon (by name)\n    *          .icon('work:chair', 'my/app/chair.svg');  // Register icon in a specific set\n    *   });\n    * </hljs>\n    *\n    */\n   /**\n    * @ngdoc method\n    * @name $mdIconProvider#iconSet\n    *\n    * @description\n    * Register a source URL for a 'named' set of icons; group of SVG definitions where each definition\n    * has an icon id. Individual icons can be subsequently retrieved from this cached set using\n    * `$mdIcon(<icon set name>:<icon name>)`\n    *\n    * @param {string} id Icon name/id used to register the iconset\n    * @param {string} url specifies the external location for the data file. Used internally by `$http` to load the\n    * data or as part of the lookup in `$templateCache` if pre-loading was configured.\n    * @param {string=} iconSize Number indicating the width and height of the icons in the set. All icons\n    * in the icon set must be the same size. Default size is 24.\n    *\n    * @returns {obj} an `$mdIconProvider` reference; used to support method call chains for the API\n    *\n    *\n    * @usage\n    * <hljs lang=\"js\">\n    *   app.config(function($mdIconProvider) {\n    *\n    *     // Configure URLs for icons specified by [set:]id.\n    *\n    *     $mdIconProvider\n    *          .iconSet('social', 'my/app/social.svg')   // Register a named icon set\n    *   });\n    * </hljs>\n    *\n    */\n   /**\n    * @ngdoc method\n    * @name $mdIconProvider#defaultIconSet\n    *\n    * @description\n    * Register a source URL for the default 'named' set of icons. Unless explicitly registered,\n    * subsequent lookups of icons will failover to search this 'default' icon set.\n    * Icon can be retrieved from this cached, default set using `$mdIcon(<name>)`\n    *\n    * @param {string} url specifies the external location for the data file. Used internally by `$http` to load the\n    * data or as part of the lookup in `$templateCache` if pre-loading was configured.\n    * @param {string=} iconSize Number indicating the width and height of the icons in the set. All icons\n    * in the icon set must be the same size. Default size is 24.\n    *\n    * @returns {obj} an `$mdIconProvider` reference; used to support method call chains for the API\n    *\n    * @usage\n    * <hljs lang=\"js\">\n    *   app.config(function($mdIconProvider) {\n    *\n    *     // Configure URLs for icons specified by [set:]id.\n    *\n    *     $mdIconProvider\n    *          .defaultIconSet( 'my/app/social.svg' )   // Register a default icon set\n    *   });\n    * </hljs>\n    *\n    */\n   /**\n    * @ngdoc method\n    * @name $mdIconProvider#defaultIconSize\n    *\n    * @description\n    * While `<md-icon />` markup can also be style with sizing CSS, this method configures\n    * the default width **and** height used for all icons; unless overridden by specific CSS.\n    * The default sizing is (24px, 24px).\n    *\n    * @param {string} iconSize Number indicating the width and height of the icons in the set. All icons\n    * in the icon set must be the same size. Default size is 24.\n    *\n    * @returns {obj} an `$mdIconProvider` reference; used to support method call chains for the API\n    *\n    * @usage\n    * <hljs lang=\"js\">\n    *   app.config(function($mdIconProvider) {\n    *\n    *     // Configure URLs for icons specified by [set:]id.\n    *\n    *     $mdIconProvider\n    *          .defaultIconSize(36)   // Register a default icon size (width == height)\n    *   });\n    * </hljs>\n    *\n    */\n\n var config = {\n   defaultIconSize: 24\n };\n\n function MdIconProvider() { }\n\n MdIconProvider.prototype = {\n   icon : function icon(id, url, iconSize) {\n     if ( id.indexOf(':') == -1 ) id = '$default:' + id;\n\n     config[id] = new ConfigurationItem(url, iconSize );\n     return this;\n   },\n\n   iconSet : function iconSet(id, url, iconSize) {\n     config[id] = new ConfigurationItem(url, iconSize );\n     return this;\n   },\n\n   defaultIconSet : function defaultIconSet(url, iconSize) {\n     var setName = '$default';\n\n     if ( !config[setName] ) {\n       config[setName] = new ConfigurationItem(url, iconSize );\n     }\n\n     config[setName].iconSize = iconSize || config.defaultIconSize;\n\n     return this;\n   },\n\n   defaultIconSize : function defaultIconSize(iconSize) {\n     config.defaultIconSize = iconSize;\n     return this;\n   },\n\n   preloadIcons: function ($templateCache) {\n     var iconProvider = this;\n     var svgRegistry = [\n       {\n         id : 'md-tabs-arrow',\n         url: 'md-tabs-arrow.svg',\n         svg: '<svg version=\"1.1\" x=\"0px\" y=\"0px\" viewBox=\"0 0 24 24\"><g><polygon points=\"15.4,7.4 14,6 8,12 14,18 15.4,16.6 10.8,12 \"/></g></svg>'\n       },\n       {\n         id : 'md-close',\n         url: 'md-close.svg',\n         svg: '<svg version=\"1.1\" x=\"0px\" y=\"0px\" viewBox=\"0 0 24 24\"><g><path d=\"M19 6.41l-1.41-1.41-5.59 5.59-5.59-5.59-1.41 1.41 5.59 5.59-5.59 5.59 1.41 1.41 5.59-5.59 5.59 5.59 1.41-1.41-5.59-5.59z\"/></g></svg>'\n       },\n       {\n         id:  'md-cancel',\n         url: 'md-cancel.svg',\n         svg: '<svg version=\"1.1\" x=\"0px\" y=\"0px\" viewBox=\"0 0 24 24\"><g><path d=\"M12 2c-5.53 0-10 4.47-10 10s4.47 10 10 10 10-4.47 10-10-4.47-10-10-10zm5 13.59l-1.41 1.41-3.59-3.59-3.59 3.59-1.41-1.41 3.59-3.59-3.59-3.59 1.41-1.41 3.59 3.59 3.59-3.59 1.41 1.41-3.59 3.59 3.59 3.59z\"/></g></svg>'\n       },\n       {\n         id:  'md-menu',\n         url: 'md-menu.svg',\n         svg: '<svg version=\"1.1\" x=\"0px\" y=\"0px\" viewBox=\"0 0 100 100\"><path d=\"M 50 0 L 100 14 L 92 80 L 50 100 L 8 80 L 0 14 Z\" fill=\"#b2b2b2\"></path><path d=\"M 50 5 L 6 18 L 13.5 77 L 50 94 Z\" fill=\"#E42939\"></path><path d=\"M 50 5 L 94 18 L 86.5 77 L 50 94 Z\" fill=\"#B72833\"></path><path d=\"M 50 7 L 83 75 L 72 75 L 65 59 L 50 59 L 50 50 L 61 50 L 50 26 Z\" fill=\"#b2b2b2\"></path><path d=\"M 50 7 L 17 75 L 28 75 L 35 59 L 50 59 L 50 50 L 39 50 L 50 26 Z\" fill=\"#fff\"></path></svg>'\n       },\n       {\n         id:  'md-toggle-arrow',\n         url: 'md-toggle-arrow-svg',\n         svg: '<svg version=\"1.1\" x=\"0px\" y=\"0px\" viewBox=\"0 0 48 48\"><path d=\"M24 16l-12 12 2.83 2.83 9.17-9.17 9.17 9.17 2.83-2.83z\"/><path d=\"M0 0h48v48h-48z\" fill=\"none\"/></svg>'\n       }\n     ];\n\n     svgRegistry.forEach(function(asset){\n       iconProvider.icon(asset.id,  asset.url);\n       $templateCache.put(asset.url, asset.svg);\n     });\n\n   },\n\n   $get : ['$http', '$q', '$log', '$templateCache', function($http, $q, $log, $templateCache) {\n     this.preloadIcons($templateCache);\n     return new MdIconService(config, $http, $q, $log, $templateCache);\n   }]\n };\n\n   /**\n    *  Configuration item stored in the Icon registry; used for lookups\n    *  to load if not already cached in the `loaded` cache\n    */\n   function ConfigurationItem(url, iconSize) {\n     this.url = url;\n     this.iconSize = iconSize || config.defaultIconSize;\n   }\n\n /**\n  * @ngdoc service\n  * @name $mdIcon\n  * @module material.components.icon\n  *\n  * @description\n  * The `$mdIcon` service is a function used to lookup SVG icons.\n  *\n  * @param {string} id Query value for a unique Id or URL. If the argument is a URL, then the service will retrieve the icon element\n  * from its internal cache or load the icon and cache it first. If the value is not a URL-type string, then an ID lookup is\n  * performed. The Id may be a unique icon ID or may include an iconSet ID prefix.\n  *\n  * For the **id** query to work properly, this means that all id-to-URL mappings must have been previously configured\n  * using the `$mdIconProvider`.\n  *\n  * @returns {obj} Clone of the initial SVG DOM element; which was created from the SVG markup in the SVG data file.\n  *\n  * @usage\n  * <hljs lang=\"js\">\n  * function SomeDirective($mdIcon) {\n  *\n  *   // See if the icon has already been loaded, if not\n  *   // then lookup the icon from the registry cache, load and cache\n  *   // it for future requests.\n  *   // NOTE: ID queries require configuration with $mdIconProvider\n  *\n  *   $mdIcon('android').then(function(iconEl)    { element.append(iconEl); });\n  *   $mdIcon('work:chair').then(function(iconEl) { element.append(iconEl); });\n  *\n  *   // Load and cache the external SVG using a URL\n  *\n  *   $mdIcon('img/icons/android.svg').then(function(iconEl) {\n  *     element.append(iconEl);\n  *   });\n  * };\n  * </hljs>\n  *\n  * NOTE: The `<md-icon />  ` directive internally uses the `$mdIcon` service to query, loaded, and instantiate\n  * SVG DOM elements.\n  */\n function MdIconService(config, $http, $q, $log, $templateCache) {\n   var iconCache = {};\n   var urlRegex = /[-a-zA-Z0-9@:%_\\+.~#?&//=]{2,256}\\.[a-z]{2,4}\\b(\\/[-a-zA-Z0-9@:%_\\+.~#?&//=]*)?/i;\n\n   Icon.prototype = { clone : cloneSVG, prepare: prepareAndStyle };\n\n   return function getIcon(id) {\n     id = id || '';\n\n     // If already loaded and cached, use a clone of the cached icon.\n     // Otherwise either load by URL, or lookup in the registry and then load by URL, and cache.\n\n     if ( iconCache[id]         ) return $q.when( iconCache[id].clone() );\n     if ( urlRegex.test(id)     ) return loadByURL(id).then( cacheIcon(id) );\n     if ( id.indexOf(':') == -1 ) id = '$default:' + id;\n\n     return loadByID(id)\n         .catch(loadFromIconSet)\n         .catch(announceIdNotFound)\n         .catch(announceNotFound)\n         .then( cacheIcon(id) );\n   };\n\n   /**\n    * Prepare and cache the loaded icon for the specified `id`\n    */\n   function cacheIcon( id ) {\n\n     return function updateCache( icon ) {\n       iconCache[id] = isIcon(icon) ? icon : new Icon(icon, config[id]);\n\n       return iconCache[id].clone();\n     };\n   }\n\n   /**\n    * Lookup the configuration in the registry, if !registered throw an error\n    * otherwise load the icon [on-demand] using the registered URL.\n    *\n    */\n   function loadByID(id) {\n     var iconConfig = config[id];\n\n     return !iconConfig ? $q.reject(id) : loadByURL(iconConfig.url).then(function(icon) {\n       return new Icon(icon, iconConfig);\n     });\n   }\n\n   /**\n    *    Loads the file as XML and uses querySelector( <id> ) to find\n    *    the desired node...\n    */\n   function loadFromIconSet(id) {\n     var setName = id.substring(0, id.lastIndexOf(':')) || '$default';\n     var iconSetConfig = config[setName];\n\n     return !iconSetConfig ? $q.reject(id) : loadByURL(iconSetConfig.url).then(extractFromSet);\n\n     function extractFromSet(set) {\n       var iconName = id.slice(id.lastIndexOf(':') + 1);\n       var icon = set.querySelector('#' + iconName);\n       return !icon ? $q.reject(id) : new Icon(icon, iconSetConfig);\n     }\n   }\n\n   /**\n    * Load the icon by URL (may use the $templateCache).\n    * Extract the data for later conversion to Icon\n    */\n   function loadByURL(url) {\n     return $http\n       .get(url, { cache: $templateCache })\n       .then(function(response) {\n         return angular.element('<div>').append(response.data).find('svg')[0];\n       });\n   }\n\n   /**\n    * User did not specify a URL and the ID has not been registered with the $mdIcon\n    * registry\n    */\n   function announceIdNotFound(id) {\n     var msg;\n\n     if (angular.isString(id)) {\n       msg = 'icon ' + id + ' not found';\n       $log.warn(msg);\n     }\n\n     return $q.reject(msg || id);\n   }\n\n   /**\n    * Catch HTTP or generic errors not related to incorrect icon IDs.\n    */\n   function announceNotFound(err) {\n     var msg = angular.isString(err) ? err : (err.message || err.data || err.statusText);\n     $log.warn(msg);\n\n     return $q.reject(msg);\n   }\n\n   /**\n    * Check target signature to see if it is an Icon instance.\n    */\n   function isIcon(target) {\n     return angular.isDefined(target.element) && angular.isDefined(target.config);\n   }\n\n   /**\n    *  Define the Icon class\n    */\n   function Icon(el, config) {\n     if (el.tagName != 'svg') {\n       el = angular.element('<svg xmlns=\"http://www.w3.org/2000/svg\">').append(el)[0];\n     }\n\n     // Inject the namespace if not available...\n     if ( !el.getAttribute('xmlns') ) {\n       el.setAttribute('xmlns', \"http://www.w3.org/2000/svg\");\n     }\n\n     this.element = el;\n     this.config = config;\n     this.prepare();\n   }\n\n   /**\n    *  Prepare the DOM element that will be cached in the\n    *  loaded iconCache store.\n    */\n   function prepareAndStyle() {\n     var iconSize = this.config ? this.config.iconSize : config.defaultIconSize;\n         angular.forEach({\n           'fit'   : '',\n           'height': '100%',\n           'width' : '100%',\n           'preserveAspectRatio': 'xMidYMid meet',\n           'viewBox' : this.element.getAttribute('viewBox') || ('0 0 ' + iconSize + ' ' + iconSize)\n         }, function(val, attr) {\n           this.element.setAttribute(attr, val);\n         }, this);\n\n         angular.forEach({\n           'pointer-events' : 'none',\n           'display' : 'block'\n         }, function(val, style) {\n           this.element.style[style] = val;\n         }, this);\n   }\n\n   /**\n    * Clone the Icon DOM element.\n    */\n   function cloneSVG(){\n     return this.element.cloneNode(true);\n   }\n\n }\n\n})();\n(function(){\n\"use strict\";\n\n/**\n * @ngdoc module\n * @name material.components.input\n */\n\nangular.module('material.components.input', [\n  'material.core'\n])\n  .directive('mdInputContainer', mdInputContainerDirective)\n  .directive('label', labelDirective)\n  .directive('input', inputTextareaDirective)\n  .directive('textarea', inputTextareaDirective)\n  .directive('mdMaxlength', mdMaxlengthDirective)\n  .directive('placeholder', placeholderDirective);\n\n/**\n * @ngdoc directive\n * @name mdInputContainer\n * @module material.components.input\n *\n * @restrict E\n *\n * @description\n * `<md-input-container>` is the parent of any input or textarea element.\n *\n * Input and textarea elements will not behave properly unless the md-input-container\n * parent is provided.\n *\n * @param md-is-error {expression=} When the given expression evaluates to true, the input container will go into error state. Defaults to erroring if the input has been touched and is invalid.\n * @param md-no-float {boolean=} When present, placeholders will not be converted to floating labels\n *\n * @usage\n * <hljs lang=\"html\">\n *\n * <md-input-container>\n *   <label>Username</label>\n *   <input type=\"text\" ng-model=\"user.name\">\n * </md-input-container>\n *\n * <md-input-container>\n *   <label>Description</label>\n *   <textarea ng-model=\"user.description\"></textarea>\n * </md-input-container>\n *\n * </hljs>\n */\nfunction mdInputContainerDirective($mdTheming, $parse) {\n  ContainerCtrl.$inject = [\"$scope\", \"$element\", \"$attrs\"];\n  return {\n    restrict: 'E',\n    link: postLink,\n    controller: ContainerCtrl\n  };\n\n  function postLink(scope, element, attr) {\n    $mdTheming(element);\n  }\n  function ContainerCtrl($scope, $element, $attrs) {\n    var self = this;\n\n    self.isErrorGetter = $attrs.mdIsError && $parse($attrs.mdIsError);\n\n    self.delegateClick = function() {\n      self.input.focus();\n    };\n    self.element = $element;\n    self.setFocused = function(isFocused) {\n      $element.toggleClass('md-input-focused', !!isFocused);\n    };\n    self.setHasValue = function(hasValue) {\n      $element.toggleClass('md-input-has-value', !!hasValue);\n    };\n    self.setInvalid = function(isInvalid) {\n      $element.toggleClass('md-input-invalid', !!isInvalid);\n    };\n    $scope.$watch(function() {\n      return self.label && self.input;\n    }, function(hasLabelAndInput) {\n      if (hasLabelAndInput && !self.label.attr('for')) {\n        self.label.attr('for', self.input.attr('id'));\n      }\n    });\n  }\n}\nmdInputContainerDirective.$inject = [\"$mdTheming\", \"$parse\"];\n\nfunction labelDirective() {\n  return {\n    restrict: 'E',\n    require: '^?mdInputContainer',\n    link: function(scope, element, attr, containerCtrl) {\n      if (!containerCtrl || attr.mdNoFloat) return;\n\n      containerCtrl.label = element;\n      scope.$on('$destroy', function() {\n        containerCtrl.label = null;\n      });\n    }\n  };\n}\n\n/**\n * @ngdoc directive\n * @name mdInput\n * @restrict E\n * @module material.components.input\n *\n * @description\n * Use the `<input>` or the  `<textarea>` as a child of an `<md-input-container>`.\n *\n * @param {number=} md-maxlength The maximum number of characters allowed in this input. If this is specified, a character counter will be shown underneath the input.<br/><br/>\n * The purpose of **`md-maxlength`** is exactly to show the max length counter text. If you don't want the counter text and only need \"plain\" validation, you can use the \"simple\" `ng-maxlength` or maxlength attributes.\n * @param {string=} aria-label Aria-label is required when no label is present.  A warning message will be logged in the console if not present.\n * @param {string=} placeholder An alternative approach to using aria-label when the label is not present.  The placeholder text is copied to the aria-label attribute.\n *\n * @usage\n * <hljs lang=\"html\">\n * <md-input-container>\n *   <label>Color</label>\n *   <input type=\"text\" ng-model=\"color\" required md-maxlength=\"10\">\n * </md-input-container>\n * </hljs>\n * <h3>With Errors (uses [ngMessages](https://docs.angularjs.org/api/ngMessages))</h3>\n * <hljs lang=\"html\">\n * <form name=\"userForm\">\n *   <md-input-container>\n *     <label>Last Name</label>\n *     <input name=\"lastName\" ng-model=\"lastName\" required md-maxlength=\"10\" minlength=\"4\">\n *     <div ng-messages=\"userForm.lastName.$error\" ng-show=\"userForm.lastName.$dirty\">\n *       <div ng-message=\"required\">This is required!</div>\n *       <div ng-message=\"md-maxlength\">That's too long!</div>\n *       <div ng-message=\"minlength\">That's too short!</div>\n *     </div>\n *   </md-input-container>\n *   <md-input-container>\n *     <label>Biography</label>\n *     <textarea name=\"bio\" ng-model=\"biography\" required md-maxlength=\"150\"></textarea>\n *     <div ng-messages=\"userForm.bio.$error\" ng-show=\"userForm.bio.$dirty\">\n *       <div ng-message=\"required\">This is required!</div>\n *       <div ng-message=\"md-maxlength\">That's too long!</div>\n *     </div>\n *   </md-input-container>\n *   <md-input-container>\n *     <input aria-label='title' ng-model='title'>\n *   </md-input-container>\n *   <md-input-container>\n *     <input placeholder='title' ng-model='title'>\n *   </md-input-container>\n * </form>\n * </hljs>\n *\n * Behaves like the [AngularJS input directive](https://docs.angularjs.org/api/ng/directive/input).\n *\n */\n\nfunction inputTextareaDirective($mdUtil, $window, $mdAria) {\n  return {\n    restrict: 'E',\n    require: ['^?mdInputContainer', '?ngModel'],\n    link: postLink\n  };\n\n  function postLink(scope, element, attr, ctrls) {\n\n    var containerCtrl = ctrls[0];\n    var ngModelCtrl = ctrls[1] || $mdUtil.fakeNgModel();\n    var isReadonly = angular.isDefined(attr.readonly);\n\n    if ( !containerCtrl ) return;\n    if (containerCtrl.input) {\n      throw new Error(\"<md-input-container> can only have *one* <input> or <textarea> child element!\");\n    }\n    containerCtrl.input = element;\n\n    if(!containerCtrl.label) {\n      $mdAria.expect(element, 'aria-label', element.attr('placeholder'));\n    }\n\n    element.addClass('md-input');\n    if (!element.attr('id')) {\n      element.attr('id', 'input_' + $mdUtil.nextUid());\n    }\n\n    if (element[0].tagName.toLowerCase() === 'textarea') {\n      setupTextarea();\n    }\n\n    var isErrorGetter = containerCtrl.isErrorGetter || function() {\n      return ngModelCtrl.$invalid && ngModelCtrl.$touched;\n    };\n    scope.$watch(isErrorGetter, containerCtrl.setInvalid);\n\n    ngModelCtrl.$parsers.push(ngModelPipelineCheckValue);\n    ngModelCtrl.$formatters.push(ngModelPipelineCheckValue);\n\n    element.on('input', inputCheckValue);\n\n    if (!isReadonly) {\n      element\n        .on('focus', function(ev) {\n          containerCtrl.setFocused(true);\n        })\n        .on('blur', function(ev) {\n          containerCtrl.setFocused(false);\n          inputCheckValue();\n        });\n\n    }\n\n    //ngModelCtrl.$setTouched();\n    //if( ngModelCtrl.$invalid ) containerCtrl.setInvalid();\n\n    scope.$on('$destroy', function() {\n      containerCtrl.setFocused(false);\n      containerCtrl.setHasValue(false);\n      containerCtrl.input = null;\n    });\n\n    /**\n     *\n     */\n    function ngModelPipelineCheckValue(arg) {\n      containerCtrl.setHasValue(!ngModelCtrl.$isEmpty(arg));\n      return arg;\n    }\n    function inputCheckValue() {\n      // An input's value counts if its length > 0,\n      // or if the input's validity state says it has bad input (eg string in a number input)\n      containerCtrl.setHasValue(element.val().length > 0 || (element[0].validity||{}).badInput);\n    }\n\n    function setupTextarea() {\n      var node = element[0];\n      var onChangeTextarea = $mdUtil.debounce(growTextarea, 1);\n\n      function pipelineListener(value) {\n        onChangeTextarea();\n        return value;\n      }\n\n      if (ngModelCtrl) {\n        ngModelCtrl.$formatters.push(pipelineListener);\n        ngModelCtrl.$viewChangeListeners.push(pipelineListener);\n      } else {\n        onChangeTextarea();\n      }\n      element.on('keydown input', onChangeTextarea);\n      element.on('scroll', onScroll);\n      angular.element($window).on('resize', onChangeTextarea);\n\n      scope.$on('$destroy', function() {\n        angular.element($window).off('resize', onChangeTextarea);\n      });\n\n      function growTextarea() {\n        node.style.height = \"auto\";\n        node.scrollTop = 0;\n        var height = getHeight();\n        if (height) node.style.height = height + 'px';\n      }\n\n      function getHeight () {\n        var line = node.scrollHeight - node.offsetHeight;\n        return node.offsetHeight + (line > 0 ? line : 0);\n      }\n\n      function onScroll(e) {\n        node.scrollTop = 0;\n        // for smooth new line adding\n        var line = node.scrollHeight - node.offsetHeight;\n        var height = node.offsetHeight + line;\n        node.style.height = height + 'px';\n      }\n    }\n  }\n}\ninputTextareaDirective.$inject = [\"$mdUtil\", \"$window\", \"$mdAria\"];\n\nfunction mdMaxlengthDirective($animate) {\n  return {\n    restrict: 'A',\n    require: ['ngModel', '^mdInputContainer'],\n    link: postLink\n  };\n\n  function postLink(scope, element, attr, ctrls) {\n    var maxlength;\n    var ngModelCtrl = ctrls[0];\n    var containerCtrl = ctrls[1];\n    var charCountEl = angular.element('<div class=\"md-char-counter\">');\n\n    // Stop model from trimming. This makes it so whitespace\n    // over the maxlength still counts as invalid.\n    attr.$set('ngTrim', 'false');\n    containerCtrl.element.append(charCountEl);\n\n    ngModelCtrl.$formatters.push(renderCharCount);\n    ngModelCtrl.$viewChangeListeners.push(renderCharCount);\n    element.on('input keydown', function() {\n      renderCharCount(); //make sure it's called with no args\n    });\n\n    scope.$watch(attr.mdMaxlength, function(value) {\n      maxlength = value;\n      if (angular.isNumber(value) && value > 0) {\n        if (!charCountEl.parent().length) {\n          $animate.enter(charCountEl, containerCtrl.element,\n                         angular.element(containerCtrl.element[0].lastElementChild));\n        }\n        renderCharCount();\n      } else {\n        $animate.leave(charCountEl);\n      }\n    });\n\n    ngModelCtrl.$validators['md-maxlength'] = function(modelValue, viewValue) {\n      if (!angular.isNumber(maxlength) || maxlength < 0) {\n        return true;\n      }\n      return ( modelValue || element.val() || viewValue || '' ).length <= maxlength;\n    };\n\n    function renderCharCount(value) {\n      charCountEl.text( ( element.val() || value || '' ).length + '/' + maxlength );\n      return value;\n    }\n  }\n}\nmdMaxlengthDirective.$inject = [\"$animate\"];\n\nfunction placeholderDirective($log) {\n  var blackListElements = ['MD-SELECT'];\n  return {\n    restrict: 'A',\n    require: '^^?mdInputContainer',\n    priority: 200,\n    link: postLink\n  };\n\n  function postLink(scope, element, attr, inputContainer) {\n    if (!inputContainer) return;\n    if (blackListElements.indexOf(element[0].nodeName) != -1) return;\n    if (angular.isDefined(inputContainer.element.attr('md-no-float'))) return;\n\n    var placeholderText = attr.placeholder;\n    element.removeAttr('placeholder');\n\n    if ( inputContainer.element.find('label').length == 0 ) {\n      var placeholder = '<label ng-click=\"delegateClick()\">' + placeholderText + '</label>';\n\n      inputContainer.element.addClass('md-icon-float');\n      inputContainer.element.prepend(placeholder);\n    } else {\n      $log.warn(\"The placeholder='\" + placeholderText + \"' will be ignored since this md-input-container has a child label element.\");\n    }\n\n  }\n}\nplaceholderDirective.$inject = [\"$log\"];\n\n})();\n(function(){\n\"use strict\";\n\n/**\n * @ngdoc module\n * @name material.components.list\n * @description\n * List module\n */\nangular.module('material.components.list', [\n  'material.core'\n])\n  .controller('MdListController', MdListController)\n  .directive('mdList', mdListDirective)\n  .directive('mdListItem', mdListItemDirective);\n\n/**\n * @ngdoc directive\n * @name mdList\n * @module material.components.list\n *\n * @restrict E\n *\n * @description\n * The `<md-list>` directive is a list container for 1..n `<md-list-item>` tags.\n *\n * @usage\n * <hljs lang=\"html\">\n * <md-list>\n *   <md-list-item class=\"md-2-line\" ng-repeat=\"item in todos\">\n *     <md-checkbox ng-model=\"item.done\"></md-checkbox>\n *     <div class=\"md-list-item-text\">\n *       <h3>{{item.title}}</h3>\n *       <p>{{item.description}}</p>\n *     </div>\n *   </md-list-item>\n * </md-list>\n * </hljs>\n */\n\nfunction mdListDirective($mdTheming) {\n  return {\n    restrict: 'E',\n    compile: function(tEl) {\n      tEl[0].setAttribute('role', 'list');\n      return $mdTheming;\n    }\n  };\n}\nmdListDirective.$inject = [\"$mdTheming\"];\n/**\n * @ngdoc directive\n * @name mdListItem\n * @module material.components.list\n *\n * @restrict E\n *\n * @description\n * The `<md-list-item>` directive is a container intended for row items in a `<md-list>` container.\n *\n * @usage\n * <hljs lang=\"html\">\n *  <md-list>\n *    <md-list-item>\n *            Item content in list\n *    </md-list-item>\n *  </md-list>\n * </hljs>\n *\n */\nfunction mdListItemDirective($mdAria, $mdConstant, $timeout) {\n  var proxiedTypes = ['md-checkbox', 'md-switch'];\n  return {\n    restrict: 'E',\n    controller: 'MdListController',\n    compile: function(tEl, tAttrs) {\n      // Check for proxy controls (no ng-click on parent, and a control inside)\n      var secondaryItem = tEl[0].querySelector('.md-secondary');\n      var hasProxiedElement;\n      var proxyElement;\n\n      tEl[0].setAttribute('role', 'listitem');\n\n      if (!tAttrs.ngClick) {\n        for (var i = 0, type; type = proxiedTypes[i]; ++i) {\n          if (proxyElement = tEl[0].querySelector(type)) {\n            hasProxiedElement = true;\n            break;\n          }\n        }\n        if (hasProxiedElement) {\n          wrapIn('div');\n        } else if (!tEl[0].querySelector('md-button')) {\n          tEl.addClass('md-no-proxy');\n        }\n      } else {\n        wrapIn('button');\n      }\n      setupToggleAria();\n\n\n      function setupToggleAria() {\n        var toggleTypes = ['md-switch', 'md-checkbox'];\n        var toggle;\n\n        for (var i = 0, toggleType; toggleType = toggleTypes[i]; ++i) {\n          if (toggle = tEl.find(toggleType)[0]) {\n            if (!toggle.hasAttribute('aria-label')) {\n              var p = tEl.find('p')[0];\n              if (!p) return;\n              toggle.setAttribute('aria-label', 'Toggle ' + p.textContent);\n            }\n          }\n        }\n      }\n\n      function wrapIn(type) {\n        var container;\n        if (type == 'div') {\n          container = angular.element('<div class=\"md-no-style md-list-item-inner\">');\n          container.append(tEl.contents());\n          tEl.addClass('md-proxy-focus');\n        } else {\n          container = angular.element('<md-button class=\"md-no-style\"><div class=\"md-list-item-inner\"></div></md-button>');\n          var copiedAttrs = ['ng-click', 'aria-label', 'ng-disabled'];\n          angular.forEach(copiedAttrs, function(attr) {\n            if (tEl[0].hasAttribute(attr)) {\n              container[0].setAttribute(attr, tEl[0].getAttribute(attr));\n              tEl[0].removeAttribute(attr);\n            }\n          });\n          container.children().eq(0).append(tEl.contents());\n        }\n\n        tEl[0].setAttribute('tabindex', '-1');\n        tEl.append(container);\n\n        if (secondaryItem && secondaryItem.hasAttribute('ng-click')) {\n          $mdAria.expect(secondaryItem, 'aria-label');\n          var buttonWrapper = angular.element('<md-button class=\"md-secondary-container md-icon-button\">');\n          buttonWrapper.attr('ng-click', secondaryItem.getAttribute('ng-click'));\n          secondaryItem.removeAttribute('ng-click');\n          secondaryItem.setAttribute('tabindex', '-1');\n          secondaryItem.classList.remove('md-secondary');\n          buttonWrapper.append(secondaryItem);\n          secondaryItem = buttonWrapper[0];\n        }\n\n        // Check for a secondary item and move it outside\n        if ( secondaryItem && (\n          secondaryItem.hasAttribute('ng-click') ||\n            ( tAttrs.ngClick &&\n             isProxiedElement(secondaryItem) )\n        )) {\n          tEl.addClass('md-with-secondary');\n          tEl.append(secondaryItem);\n        }\n      }\n\n      function isProxiedElement(el) {\n        return proxiedTypes.indexOf(el.nodeName.toLowerCase()) != -1;\n      }\n\n      return postLink;\n\n      function postLink($scope, $element, $attr, ctrl) {\n\n        var proxies    = [],\n            firstChild = $element[0].firstElementChild,\n            hasClick   = firstChild && firstChild.hasAttribute('ng-click');\n\n        computeProxies();\n        computeClickable();\n\n        if ($element.hasClass('md-proxy-focus') && proxies.length) {\n          angular.forEach(proxies, function(proxy) {\n            proxy = angular.element(proxy);\n\n            $scope.mouseActive = false;\n            proxy.on('mousedown', function() {\n              $scope.mouseActive = true;\n              $timeout(function(){\n                $scope.mouseActive = false;\n              }, 100);\n            })\n            .on('focus', function() {\n              if ($scope.mouseActive === false) { $element.addClass('md-focused'); }\n              proxy.on('blur', function proxyOnBlur() {\n                $element.removeClass('md-focused');\n                proxy.off('blur', proxyOnBlur);\n              });\n            });\n          });\n        }\n\n        function computeProxies() {\n          var children = $element.children();\n          if (children.length && !children[0].hasAttribute('ng-click')) {\n            angular.forEach(proxiedTypes, function(type) {\n              angular.forEach(firstChild.querySelectorAll(type), function(child) {\n                proxies.push(child);\n              });\n            });\n          }\n        }\n        function computeClickable() {\n          if (proxies.length || hasClick) {\n            $element.addClass('md-clickable');\n\n            ctrl.attachRipple($scope, angular.element($element[0].querySelector('.md-no-style')));\n          }\n        }\n\n        if (!hasClick && !proxies.length) {\n          firstChild.addEventListener('keypress', function(e) {\n            if (e.target.nodeName != 'INPUT' && e.target.nodeName != 'TEXTAREA') {\n              var keyCode = e.which || e.keyCode;\n              if (keyCode == $mdConstant.KEY_CODE.SPACE) {\n                firstChild.click();\n                e.preventDefault();\n                e.stopPropagation();\n              }\n            }\n          });\n        }\n\n        $element.off('click');\n        $element.off('keypress');\n\n        if (proxies.length && firstChild) {\n          $element.children().eq(0).on('click', function(e) {\n            if (firstChild.contains(e.target)) {\n              angular.forEach(proxies, function(proxy) {\n                if (e.target !== proxy && !proxy.contains(e.target)) {\n                  angular.element(proxy).triggerHandler('click');\n                }\n              });\n            }\n          });\n        }\n      }\n    }\n  };\n}\nmdListItemDirective.$inject = [\"$mdAria\", \"$mdConstant\", \"$timeout\"];\n\n/*\n * @private\n * @ngdoc controller\n * @name MdListController\n * @module material.components.list\n *\n */\nfunction MdListController($scope, $element, $mdListInkRipple) {\n  var ctrl = this;\n  ctrl.attachRipple = attachRipple;\n\n  function attachRipple (scope, element) {\n    var options = {};\n    $mdListInkRipple.attach(scope, element, options);\n  }\n}\nMdListController.$inject = [\"$scope\", \"$element\", \"$mdListInkRipple\"];\n\n})();\n(function(){\n\"use strict\";\n\n/**\n * @ngdoc module\n * @name material.components.progressCircular\n * @description Circular Progress module!\n */\nangular.module('material.components.progressCircular', [\n  'material.core'\n])\n  .directive('mdProgressCircular', MdProgressCircularDirective);\n\n/**\n * @ngdoc directive\n * @name mdProgressCircular\n * @module material.components.progressCircular\n * @restrict E\n *\n* @description\n * The circular progress directive is used to make loading content in your app as delightful and\n * painless as possible by minimizing the amount of visual change a user sees before they can view\n * and interact with content.\n *\n * For operations where the percentage of the operation completed can be determined, use a\n * determinate indicator. They give users a quick sense of how long an operation will take.\n *\n * For operations where the user is asked to wait a moment while something finishes up, and it’s\n * not necessary to expose what's happening behind the scenes and how long it will take, use an\n * indeterminate indicator.\n *\n * @param {string} md-mode Select from one of two modes: determinate and indeterminate.\n * @param {number=} value In determinate mode, this number represents the percentage of the\n *     circular progress. Default: 0\n * @param {number=} md-diameter This specifies the diamter of the circular progress. Default: 48\n *\n * @usage\n * <hljs lang=\"html\">\n * <md-progress-circular md-mode=\"determinate\" value=\"...\"></md-progress-circular>\n *\n * <md-progress-circular md-mode=\"determinate\" ng-value=\"...\"></md-progress-circular>\n *\n * <md-progress-circular md-mode=\"determinate\" value=\"...\" md-diameter=\"100\"></md-progress-circular>\n *\n * <md-progress-circular md-mode=\"indeterminate\"></md-progress-circular>\n * </hljs>\n */\nfunction MdProgressCircularDirective($mdConstant, $mdTheming) {\n  return {\n    restrict: 'E',\n    template:\n        // The progress 'circle' is composed of two half-circles: the left side and the right\n        // side. Each side has CSS applied to 'fill-in' the half-circle to the appropriate progress.\n        '<div class=\"md-spinner-wrapper\">' +\n          '<div class=\"md-inner\">' +\n            '<div class=\"md-gap\"></div>' +\n            '<div class=\"md-left\">' +\n              '<div class=\"md-half-circle\"></div>' +\n            '</div>' +\n            '<div class=\"md-right\">' +\n              '<div class=\"md-half-circle\"></div>' +\n            '</div>' +\n          '</div>' +\n        '</div>',\n    compile: compile\n  };\n\n  function compile(tElement) {\n    // The javascript in this file is mainly responsible for setting the correct aria attributes.\n    // The animation of the progress spinner is done entirely with just CSS.\n    tElement.attr('aria-valuemin', 0);\n    tElement.attr('aria-valuemax', 100);\n    tElement.attr('role', 'progressbar');\n\n    return postLink;\n  }\n\n  function postLink(scope, element, attr) {\n    $mdTheming(element);\n    var circle = element[0];\n\n    // Scale the progress circle based on the default diameter.\n    var diameter = attr.mdDiameter || 48;\n    var scale = diameter / 48;\n    circle.style[$mdConstant.CSS.TRANSFORM] = 'scale(' + scale + ')';\n\n    attr.$observe('value', function(value) {\n      var percentValue = clamp(value);\n      element.attr('aria-valuenow', percentValue);\n    });\n  }\n\n  /**\n   * Clamps the value to be between 0 and 100.\n   * @param {number} value The value to clamp.\n   * @returns {number}\n   */\n  function clamp(value) {\n    return Math.max(0, Math.min(value || 0, 100));\n  }\n}\nMdProgressCircularDirective.$inject = [\"$mdConstant\", \"$mdTheming\"];\n\n})();\n(function(){\n\"use strict\";\n\n/**\n * @ngdoc module\n * @name material.components.progressLinear\n * @description Linear Progress module!\n */\nangular.module('material.components.progressLinear', [\n  'material.core'\n])\n  .directive('mdProgressLinear', MdProgressLinearDirective);\n\n/**\n * @ngdoc directive\n * @name mdProgressLinear\n * @module material.components.progressLinear\n * @restrict E\n *\n * @description\n * The linear progress directive is used to make loading content in your app as delightful and painless as possible by minimizing the amount of visual change a user sees before they can view and interact with content. Each operation should only be represented by one activity indicator—for example, one refresh operation should not display both a refresh bar and an activity circle.\n *\n * For operations where the percentage of the operation completed can be determined, use a determinate indicator. They give users a quick sense of how long an operation will take.\n *\n * For operations where the user is asked to wait a moment while something finishes up, and it’s not necessary to expose what's happening behind the scenes and how long it will take, use an indeterminate indicator.\n *\n * @param {string} md-mode Select from one of four modes: determinate, indeterminate, buffer or query.\n * @param {number=} value In determinate and buffer modes, this number represents the percentage of the primary progress bar. Default: 0\n * @param {number=} md-buffer-value In the buffer mode, this number represents the precentage of the secondary progress bar. Default: 0\n *\n * @usage\n * <hljs lang=\"html\">\n * <md-progress-linear md-mode=\"determinate\" value=\"...\"></md-progress-linear>\n *\n * <md-progress-linear md-mode=\"determinate\" ng-value=\"...\"></md-progress-linear>\n *\n * <md-progress-linear md-mode=\"indeterminate\"></md-progress-linear>\n *\n * <md-progress-linear md-mode=\"buffer\" value=\"...\" md-buffer-value=\"...\"></md-progress-linear>\n *\n * <md-progress-linear md-mode=\"query\"></md-progress-linear>\n * </hljs>\n */\nfunction MdProgressLinearDirective($$rAF, $mdConstant, $mdTheming) {\n\n  return {\n    restrict: 'E',\n    template: '<div class=\"md-container\">' +\n      '<div class=\"md-dashed\"></div>' +\n      '<div class=\"md-bar md-bar1\"></div>' +\n      '<div class=\"md-bar md-bar2\"></div>' +\n      '</div>',\n    compile: compile\n  };\n  \n  function compile(tElement, tAttrs, transclude) {\n    tElement.attr('aria-valuemin', 0);\n    tElement.attr('aria-valuemax', 100);\n    tElement.attr('role', 'progressbar');\n\n    return postLink;\n  }\n  function postLink(scope, element, attr) {\n    $mdTheming(element);\n    var bar1Style = element[0].querySelector('.md-bar1').style,\n      bar2Style = element[0].querySelector('.md-bar2').style,\n      container = angular.element(element[0].querySelector('.md-container'));\n\n    attr.$observe('value', function(value) {\n      if (attr.mdMode == 'query') {\n        return;\n      }\n\n      var clamped = clamp(value);\n      element.attr('aria-valuenow', clamped);\n      bar2Style[$mdConstant.CSS.TRANSFORM] = transforms[clamped];\n    });\n\n    attr.$observe('mdBufferValue', function(value) {\n      bar1Style[$mdConstant.CSS.TRANSFORM] = transforms[clamp(value)];\n    });\n\n    $$rAF(function() {\n      container.addClass('md-ready');\n    });\n  }\n\n  function clamp(value) {\n    if (value > 100) {\n      return 100;\n    }\n\n    if (value < 0) {\n      return 0;\n    }\n\n    return Math.ceil(value || 0);\n  }\n}\nMdProgressLinearDirective.$inject = [\"$$rAF\", \"$mdConstant\", \"$mdTheming\"];\n\n\n// **********************************************************\n// Private Methods\n// **********************************************************\nvar transforms = (function() {\n  var values = new Array(101);\n  for(var i = 0; i < 101; i++){\n    values[i] = makeTransform(i);\n  }\n\n  return values;\n\n  function makeTransform(value){\n    var scale = value/100;\n    var translateX = (value-100)/2;\n    return 'translateX(' + translateX.toString() + '%) scale(' + scale.toString() + ', 1)';\n  }\n})();\n\n})();\n(function(){\n\"use strict\";\n\n/**\n * @ngdoc module\n * @name material.components.radioButton\n * @description radioButton module!\n */\nangular.module('material.components.radioButton', [\n  'material.core'\n])\n  .directive('mdRadioGroup', mdRadioGroupDirective)\n  .directive('mdRadioButton', mdRadioButtonDirective);\n\n/**\n * @ngdoc directive\n * @module material.components.radioButton\n * @name mdRadioGroup\n *\n * @restrict E\n *\n * @description\n * The `<md-radio-group>` directive identifies a grouping\n * container for the 1..n grouped radio buttons; specified using nested\n * `<md-radio-button>` tags.\n *\n * As per the [material design spec](http://www.google.com/design/spec/style/color.html#color-ui-color-application)\n * the radio button is in the accent color by default. The primary color palette may be used with\n * the `md-primary` class.\n *\n * Note: `<md-radio-group>` and `<md-radio-button>` handle tabindex differently\n * than the native `<input type='radio'>` controls. Whereas the native controls\n * force the user to tab through all the radio buttons, `<md-radio-group>`\n * is focusable, and by default the `<md-radio-button>`s are not.\n *\n * @param {string} ng-model Assignable angular expression to data-bind to.\n * @param {boolean=} md-no-ink Use of attribute indicates flag to disable ink ripple effects.\n *\n * @usage\n * <hljs lang=\"html\">\n * <md-radio-group ng-model=\"selected\">\n *\n *   <md-radio-button\n *        ng-repeat=\"d in colorOptions\"\n *        ng-value=\"d.value\" aria-label=\"{{ d.label }}\">\n *\n *          {{ d.label }}\n *\n *   </md-radio-button>\n *\n * </md-radio-group>\n * </hljs>\n *\n */\nfunction mdRadioGroupDirective($mdUtil, $mdConstant, $mdTheming, $timeout) {\n  RadioGroupController.prototype = createRadioGroupControllerProto();\n\n  return {\n    restrict: 'E',\n    controller: ['$element', RadioGroupController],\n    require: ['mdRadioGroup', '?ngModel'],\n    link: { pre: linkRadioGroup }\n  };\n\n  function linkRadioGroup(scope, element, attr, ctrls) {\n    $mdTheming(element);\n    var rgCtrl = ctrls[0];\n    var ngModelCtrl = ctrls[1] || $mdUtil.fakeNgModel();\n\n    function setFocus() {\n      if (!element.hasClass('md-focused')) { element.addClass('md-focused'); }\n    }\n\n    function keydownListener(ev) {\n      var keyCode = ev.which || ev.keyCode;\n      switch(keyCode) {\n        case $mdConstant.KEY_CODE.LEFT_ARROW:\n        case $mdConstant.KEY_CODE.UP_ARROW:\n          ev.preventDefault();\n          rgCtrl.selectPrevious();\n          setFocus();\n          break;\n\n        case $mdConstant.KEY_CODE.RIGHT_ARROW:\n        case $mdConstant.KEY_CODE.DOWN_ARROW:\n          ev.preventDefault();\n          rgCtrl.selectNext();\n          setFocus();\n          break;\n\n        case $mdConstant.KEY_CODE.ENTER:\n          var form = angular.element($mdUtil.getClosest(element[0], 'form'));\n          if (form.length > 0) {\n            form.triggerHandler('submit');\n          }\n          break;\n      }\n    }\n\n    rgCtrl.init(ngModelCtrl);\n\n    scope.mouseActive = false;\n    element.attr({\n              'role': 'radiogroup',\n              'tabIndex': element.attr('tabindex') || '0'\n            })\n            .on('keydown', keydownListener)\n            .on('mousedown', function(event) {\n              scope.mouseActive = true;\n              $timeout(function() {\n                scope.mouseActive = false;\n              }, 100);\n            })\n            .on('focus', function() {\n              if(scope.mouseActive === false) { rgCtrl.$element.addClass('md-focused'); }\n            })\n            .on('blur', function() { rgCtrl.$element.removeClass('md-focused'); });\n  }\n\n  function RadioGroupController($element) {\n    this._radioButtonRenderFns = [];\n    this.$element = $element;\n  }\n\n  function createRadioGroupControllerProto() {\n    return {\n      init: function(ngModelCtrl) {\n        this._ngModelCtrl = ngModelCtrl;\n        this._ngModelCtrl.$render = angular.bind(this, this.render);\n      },\n      add: function(rbRender) {\n        this._radioButtonRenderFns.push(rbRender);\n      },\n      remove: function(rbRender) {\n        var index = this._radioButtonRenderFns.indexOf(rbRender);\n        if (index !== -1) {\n          this._radioButtonRenderFns.splice(index, 1);\n        }\n      },\n      render: function() {\n        this._radioButtonRenderFns.forEach(function(rbRender) {\n          rbRender();\n        });\n      },\n      setViewValue: function(value, eventType) {\n        this._ngModelCtrl.$setViewValue(value, eventType);\n        // update the other radio buttons as well\n        this.render();\n      },\n      getViewValue: function() {\n        return this._ngModelCtrl.$viewValue;\n      },\n      selectNext: function() {\n        return changeSelectedButton(this.$element, 1);\n      },\n      selectPrevious: function() {\n        return changeSelectedButton(this.$element, -1);\n      },\n      setActiveDescendant: function (radioId) {\n        this.$element.attr('aria-activedescendant', radioId);\n      }\n    };\n  }\n  /**\n   * Change the radio group's selected button by a given increment.\n   * If no button is selected, select the first button.\n   */\n  function changeSelectedButton(parent, increment) {\n    // Coerce all child radio buttons into an array, then wrap then in an iterator\n    var buttons = $mdUtil.iterator(parent[0].querySelectorAll('md-radio-button'), true);\n\n    if (buttons.count()) {\n      var validate = function (button) {\n        // If disabled, then NOT valid\n        return !angular.element(button).attr(\"disabled\");\n      };\n      var selected = parent[0].querySelector('md-radio-button.md-checked');\n      var target = buttons[increment < 0 ? 'previous' : 'next'](selected, validate) || buttons.first();\n      // Activate radioButton's click listener (triggerHandler won't create a real click event)\n      angular.element(target).triggerHandler('click');\n\n\n    }\n  }\n\n}\nmdRadioGroupDirective.$inject = [\"$mdUtil\", \"$mdConstant\", \"$mdTheming\", \"$timeout\"];\n\n/**\n * @ngdoc directive\n * @module material.components.radioButton\n * @name mdRadioButton\n *\n * @restrict E\n *\n * @description\n * The `<md-radio-button>`directive is the child directive required to be used within `<md-radio-group>` elements.\n *\n * While similar to the `<input type=\"radio\" ng-model=\"\" value=\"\">` directive,\n * the `<md-radio-button>` directive provides ink effects, ARIA support, and\n * supports use within named radio groups.\n *\n * @param {string} ngModel Assignable angular expression to data-bind to.\n * @param {string=} ngChange Angular expression to be executed when input changes due to user\n *    interaction with the input element.\n * @param {string} ngValue Angular expression which sets the value to which the expression should\n *    be set when selected.*\n * @param {string} value The value to which the expression should be set when selected.\n * @param {string=} name Property name of the form under which the control is published.\n * @param {string=} aria-label Adds label to radio button for accessibility.\n * Defaults to radio button's text. If no text content is available, a warning will be logged.\n *\n * @usage\n * <hljs lang=\"html\">\n *\n * <md-radio-button value=\"1\" aria-label=\"Label 1\">\n *   Label 1\n * </md-radio-button>\n *\n * <md-radio-button ng-model=\"color\" ng-value=\"specialValue\" aria-label=\"Green\">\n *   Green\n * </md-radio-button>\n *\n * </hljs>\n *\n */\nfunction mdRadioButtonDirective($mdAria, $mdUtil, $mdTheming) {\n\n  var CHECKED_CSS = 'md-checked';\n\n  return {\n    restrict: 'E',\n    require: '^mdRadioGroup',\n    transclude: true,\n    template: '<div class=\"md-container\" md-ink-ripple md-ink-ripple-checkbox>' +\n                '<div class=\"md-off\"></div>' +\n                '<div class=\"md-on\"></div>' +\n              '</div>' +\n              '<div ng-transclude class=\"md-label\"></div>',\n    link: link\n  };\n\n  function link(scope, element, attr, rgCtrl) {\n    var lastChecked;\n\n    $mdTheming(element);\n    configureAria(element, scope);\n\n    rgCtrl.add(render);\n    attr.$observe('value', render);\n\n    element\n      .on('click', listener)\n      .on('$destroy', function() {\n        rgCtrl.remove(render);\n      });\n\n    function listener(ev) {\n      if (element[0].hasAttribute('disabled')) return;\n\n      scope.$apply(function() {\n        rgCtrl.setViewValue(attr.value, ev && ev.type);\n      });\n    }\n\n    function render() {\n      var checked = (rgCtrl.getViewValue() == attr.value);\n      if (checked === lastChecked) {\n        return;\n      }\n      lastChecked = checked;\n      element.attr('aria-checked', checked);\n      if (checked) {\n        element.addClass(CHECKED_CSS);\n        rgCtrl.setActiveDescendant(element.attr('id'));\n      } else {\n        element.removeClass(CHECKED_CSS);\n      }\n    }\n    /**\n     * Inject ARIA-specific attributes appropriate for each radio button\n     */\n    function configureAria( element, scope ){\n      scope.ariaId = buildAriaID();\n\n      element.attr({\n        'id' :  scope.ariaId,\n        'role' : 'radio',\n        'aria-checked' : 'false'\n      });\n\n      $mdAria.expectWithText(element, 'aria-label');\n\n      /**\n       * Build a unique ID for each radio button that will be used with aria-activedescendant.\n       * Preserve existing ID if already specified.\n       * @returns {*|string}\n       */\n      function buildAriaID() {\n        return attr.id || ( 'radio' + \"_\" + $mdUtil.nextUid() );\n      }\n    }\n  }\n}\nmdRadioButtonDirective.$inject = [\"$mdAria\", \"$mdUtil\", \"$mdTheming\"];\n\n})();\n(function(){\n\"use strict\";\n\n/**\n * @ngdoc module\n * @name material.components.select\n */\n\n/***************************************************\n\n### TODO ###\n**DOCUMENTATION AND DEMOS**\n\n- [ ] ng-model with child mdOptions (basic)\n- [ ] ng-model=\"foo\" ng-model-options=\"{ trackBy: '$value.id' }\" for objects\n- [ ] mdOption with value\n- [ ] Usage with input inside\n\n### TODO - POST RC1 ###\n- [ ] Abstract placement logic in $mdSelect service to $mdMenu service\n\n***************************************************/\n\nvar SELECT_EDGE_MARGIN = 8;\nvar selectNextId = 0;\n\nangular.module('material.components.select', [\n  'material.core',\n  'material.components.backdrop'\n])\n.directive('mdSelect', SelectDirective)\n.directive('mdSelectMenu', SelectMenuDirective)\n.directive('mdOption', OptionDirective)\n.directive('mdOptgroup', OptgroupDirective)\n.provider('$mdSelect', SelectProvider);\n\n\n/**\n * @ngdoc directive\n * @name mdSelect\n * @restrict E\n * @module material.components.select\n *\n * @description Displays a select box, bound to an ng-model.\n *\n * @param {expression} ng-model The model!\n * @param {boolean=} multiple Whether it's multiple.\n * @param {string=} placeholder Placeholder hint text.\n * @param {string=} aria-label Optional label for accessibility. Only necessary if no placeholder or\n * explicit label is present.\n *\n * @usage\n * With a placeholder (label and aria-label are added dynamically)\n * <hljs lang=\"html\">\n *   <md-select\n *     ng-model=\"someModel\"\n *     placeholder=\"Select a state\">\n *     <md-option ng-value=\"opt\" ng-repeat=\"opt in neighborhoods2\">{{ opt }}</md-option>\n *   </md-select>\n * </hljs>\n *\n * With an explicit label\n * <hljs lang=\"html\">\n *   <md-select\n *     ng-model=\"someModel\">\n *     <md-select-label>Select a state</md-select-label>\n *     <md-option ng-value=\"opt\" ng-repeat=\"opt in neighborhoods2\">{{ opt }}</md-option>\n *   </md-select>\n * </hljs>\n */\nfunction SelectDirective($mdSelect, $mdUtil, $mdTheming, $mdAria, $interpolate, $compile, $parse) {\n  return {\n    restrict: 'E',\n    require: ['mdSelect', 'ngModel', '?^form'],\n    compile: compile,\n    controller: function() { } // empty placeholder controller to be initialized in link\n  };\n\n  function compile(element, attr) {\n    // The user is allowed to provide a label for the select as md-select-label child\n    var labelEl = element.find('md-select-label').remove();\n\n    // If not provided, we automatically make one\n    if (!labelEl.length) {\n      labelEl = angular.element('<md-select-label><span></span></md-select-label>');\n    } else {\n      if (!labelEl[0].firstElementChild) {\n        var spanWrapper = angular.element('<span>');\n        spanWrapper.append(labelEl.contents());\n        labelEl.append(spanWrapper);\n      }\n    }\n    labelEl.append('<span class=\"md-select-icon\" aria-hidden=\"true\"></span>');\n    labelEl.addClass('md-select-label');\n    if (!labelEl[0].hasAttribute('id')) {\n      labelEl.attr('id', 'select_label_' + $mdUtil.nextUid());\n    }\n\n    // There's got to be an md-content inside. If there's not one, let's add it.\n    if (!element.find('md-content').length) {\n      element.append( angular.element('<md-content>').append(element.contents()) );\n    }\n\n    // Add progress spinner for md-options-loading\n    if (attr.mdOnOpen) {\n      element.find('md-content').prepend(\n        angular.element('<md-progress-circular>')\n               .attr('md-mode', 'indeterminate')\n               .attr('ng-hide', '$$loadingAsyncDone')\n               .wrap('<div>')\n               .parent()\n      );\n    }\n\n    if (attr.name) {\n      var autofillClone = angular.element('<select class=\"md-visually-hidden\">');\n      autofillClone.attr({\n        'name': '.' + attr.name,\n        'ng-model': attr.ngModel,\n        'aria-hidden': 'true',\n        'tabindex': '-1'\n      });\n      var opts = element.find('md-option');\n      angular.forEach(opts, function(el) {\n        var newEl = angular.element('<option>' + el.innerHTML + '</option>');\n        if (el.hasAttribute('ng-value')) newEl.attr('ng-value', el.getAttribute('ng-value'));\n        else if (el.hasAttribute('value')) newEl.attr('value', el.getAttribute('value'));\n        autofillClone.append(newEl);\n      });\n\n      element.parent().append(autofillClone);\n    }\n\n    // Use everything that's left inside element.contents() as the contents of the menu\n    var selectTemplate = '<div class=\"md-select-menu-container\">' +\n        '<md-select-menu ' +\n        (angular.isDefined(attr.multiple) ? 'multiple' : '') + '>' +\n          element.html() +\n        '</md-select-menu></div>';\n\n    element.empty().append(labelEl);\n\n    attr.tabindex = attr.tabindex || '0';\n\n    return function postLink(scope, element, attr, ctrls) {\n      var isOpen;\n      var isDisabled;\n\n      var mdSelectCtrl = ctrls[0];\n      var ngModel = ctrls[1];\n      var formCtrl = ctrls[2];\n\n      var labelEl = element.find('md-select-label');\n      var customLabel = labelEl.text().length !== 0;\n      var selectContainer, selectScope, selectMenuCtrl;\n      createSelect();\n\n      $mdTheming(element);\n\n      if (attr.name && formCtrl) {\n        var selectEl = element.parent()[0].querySelector('select[name=\".' + attr.name + '\"]')\n        formCtrl.$removeControl(angular.element(selectEl).controller());\n      }\n\n      var originalRender = ngModel.$render;\n      ngModel.$render = function() {\n        originalRender();\n        syncLabelText();\n      };\n\n      mdSelectCtrl.setLabelText = function(text) {\n        if (customLabel) return; // Assume that user is handling it on their own\n        mdSelectCtrl.setIsPlaceholder(!text);\n        text = text || attr.placeholder || '';\n        var target = customLabel ? labelEl : labelEl.children().eq(0);\n        target.text(text);\n      };\n\n      mdSelectCtrl.setIsPlaceholder = function(val) {\n        val ? labelEl.addClass('md-placeholder') : labelEl.removeClass('md-placeholder');\n      };\n\n      scope.$$postDigest(function() {\n        setAriaLabel();\n        syncLabelText();\n      });\n\n      function setAriaLabel() {\n        var labelText = element.attr('placeholder');\n        if (!labelText) {\n          labelText = element.find('md-select-label').text();\n        }\n        $mdAria.expect(element, 'aria-label', labelText);\n      }\n\n      function syncLabelText() {\n        if (selectContainer) {\n          selectMenuCtrl = selectMenuCtrl || selectContainer.find('md-select-menu').controller('mdSelectMenu');\n          mdSelectCtrl.setLabelText(selectMenuCtrl.selectedLabels());\n        }\n      }\n\n      var deregisterWatcher;\n      attr.$observe('ngMultiple', function(val) {\n        if (deregisterWatcher) deregisterWatcher();\n        var parser = $parse(val);\n        deregisterWatcher = scope.$watch(function() { return parser(scope); }, function(multiple, prevVal) {\n          if (multiple === undefined && prevVal === undefined) return; // assume compiler did a good job\n          if (multiple) {\n            element.attr('multiple', 'multiple');\n          } else {\n            element.removeAttr('multiple');\n          }\n          if (selectContainer) {\n            selectMenuCtrl.setMultiple(multiple);\n            originalRender = ngModel.$render;\n            ngModel.$render = function() {\n              originalRender();\n              syncLabelText();\n            };\n            selectMenuCtrl.refreshViewValue();\n            ngModel.$render();\n          }\n        });\n      });\n\n      attr.$observe('disabled', function(disabled) {\n        if (typeof disabled == \"string\") {\n          disabled = true;\n        }\n        // Prevent click event being registered twice\n        if (isDisabled !== undefined && isDisabled === disabled) {\n          return;\n        }\n        isDisabled = disabled;\n        if (disabled) {\n          element.attr({'tabindex': -1, 'aria-disabled': 'true'});\n          element.off('click', openSelect);\n          element.off('keydown', handleKeypress);\n        } else {\n          element.attr({'tabindex': attr.tabindex, 'aria-disabled': 'false'});\n          element.on('click', openSelect);\n          element.on('keydown', handleKeypress);\n        }\n      });\n      if (!attr.disabled && !attr.ngDisabled) {\n        element.attr({'tabindex': attr.tabindex, 'aria-disabled': 'false'});\n        element.on('click', openSelect);\n        element.on('keydown', handleKeypress);\n      }\n\n      var ariaAttrs = {\n        role: 'combobox',\n        'aria-expanded': 'false'\n      };\n      if (!element[0].hasAttribute('id')) {\n        ariaAttrs.id = 'select_' + $mdUtil.nextUid();\n      }\n      element.attr(ariaAttrs);\n\n      scope.$on('$destroy', function() {\n        if (isOpen) {\n          $mdSelect.cancel().then(function() {\n            selectContainer.remove();\n          });\n        } else {\n          selectContainer.remove();\n        }\n      });\n\n\n      // Create a fake select to find out the label value\n      function createSelect() {\n        selectContainer = angular.element(selectTemplate);\n        var selectEl = selectContainer.find('md-select-menu');\n        selectEl.data('$ngModelController', ngModel);\n        selectEl.data('$mdSelectController', mdSelectCtrl);\n        selectScope = scope.$new();\n        selectContainer = $compile(selectContainer)(selectScope);\n        selectMenuCtrl = selectContainer.find('md-select-menu').controller('mdSelectMenu');\n      }\n\n      function handleKeypress(e) {\n        var allowedCodes = [32, 13, 38, 40];\n        if (allowedCodes.indexOf(e.keyCode) != -1 ) {\n          // prevent page scrolling on interaction\n          e.preventDefault();\n          openSelect(e);\n        } else {\n          if (e.keyCode <= 90 && e.keyCode >= 31) {\n            e.preventDefault();\n            var node = selectMenuCtrl.optNodeForKeyboardSearch(e);\n            if (!node) return;\n            var optionCtrl = angular.element(node).controller('mdOption');\n            if (!selectMenuCtrl.isMultiple) {\n              selectMenuCtrl.deselect( Object.keys(selectMenuCtrl.selected)[0] );\n            }\n            selectMenuCtrl.select(optionCtrl.hashKey, optionCtrl.value);\n            selectMenuCtrl.refreshViewValue();\n            ngModel.$render();\n          }\n        }\n      }\n\n      function openSelect() {\n        scope.$evalAsync(function() {\n          isOpen = true;\n          $mdSelect.show({\n            scope: selectScope,\n            preserveScope: true,\n            skipCompile: true,\n            element: selectContainer,\n            target: element[0],\n            hasBackdrop: true,\n            loadingAsync: attr.mdOnOpen ? scope.$eval(attr.mdOnOpen) || true : false,\n          }).then(function(selectedText) {\n            isOpen = false;\n          });\n        });\n      }\n    };\n  }\n}\nSelectDirective.$inject = [\"$mdSelect\", \"$mdUtil\", \"$mdTheming\", \"$mdAria\", \"$interpolate\", \"$compile\", \"$parse\"];\n\nfunction SelectMenuDirective($parse, $mdUtil, $mdTheming) {\n\n  SelectMenuController.$inject = [\"$scope\", \"$attrs\", \"$element\"];\n  return {\n    restrict: 'E',\n    require: ['mdSelectMenu', '?ngModel'],\n    controller: SelectMenuController,\n    link: { pre: preLink }\n  };\n\n  // We use preLink instead of postLink to ensure that the select is initialized before\n  // its child options run postLink.\n  function preLink(scope, element, attr, ctrls) {\n    var selectCtrl = ctrls[0];\n    var ngModel = ctrls[1];\n\n    $mdTheming(element);\n    element.on('click', clickListener);\n    element.on('keypress', keyListener);\n    if (ngModel) selectCtrl.init(ngModel);\n    configureAria();\n\n    function configureAria() {\n      element.attr({\n        'id': 'select_menu_' + $mdUtil.nextUid(),\n        'role': 'listbox',\n        'aria-multiselectable': (selectCtrl.isMultiple ? 'true' : 'false')\n      });\n    }\n\n    function keyListener(e) {\n      if (e.keyCode == 13 || e.keyCode == 32) {\n        clickListener(e);\n      }\n    }\n\n    function clickListener(ev) {\n      var option = $mdUtil.getClosest(ev.target, 'md-option');\n      var optionCtrl = option && angular.element(option).data('$mdOptionController');\n      if (!option || !optionCtrl) return;\n\n      var optionHashKey = selectCtrl.hashGetter(optionCtrl.value);\n      var isSelected = angular.isDefined(selectCtrl.selected[optionHashKey]);\n\n      scope.$apply(function() {\n        if (selectCtrl.isMultiple) {\n          if (isSelected) {\n            selectCtrl.deselect(optionHashKey);\n          } else {\n            selectCtrl.select(optionHashKey, optionCtrl.value);\n          }\n        } else {\n          if (!isSelected) {\n            selectCtrl.deselect( Object.keys(selectCtrl.selected)[0] );\n            selectCtrl.select( optionHashKey, optionCtrl.value );\n          }\n        }\n        selectCtrl.refreshViewValue();\n      });\n    }\n  }\n\n\n\n  function SelectMenuController($scope, $attrs, $element) {\n    var self = this;\n    self.isMultiple = angular.isDefined($attrs.multiple);\n    // selected is an object with keys matching all of the selected options' hashed values\n    self.selected = {};\n    // options is an object with keys matching every option's hash value,\n    // and values matching every option's controller.\n    self.options = {};\n\n    $scope.$watch(function() { return self.options; }, function() {\n      self.ngModel.$render();\n    }, true);\n\n    var deregisterCollectionWatch;\n    self.setMultiple = function(isMultiple) {\n      var ngModel = self.ngModel;\n      self.isMultiple = isMultiple;\n      if (deregisterCollectionWatch) deregisterCollectionWatch();\n\n      if (self.isMultiple) {\n        ngModel.$validators['md-multiple'] = validateArray;\n        ngModel.$render = renderMultiple;\n\n        // watchCollection on the model because by default ngModel only watches the model's\n        // reference. This allowed the developer to also push and pop from their array.\n        $scope.$watchCollection($attrs.ngModel, function(value) {\n          if (validateArray(value)) renderMultiple(value);\n        });\n      } else {\n        delete ngModel.$validators['md-multiple'];\n        ngModel.$render = renderSingular;\n      }\n\n      function validateArray(modelValue, viewValue) {\n        // If a value is truthy but not an array, reject it.\n        // If value is undefined/falsy, accept that it's an empty array.\n        return angular.isArray(modelValue || viewValue || []);\n      }\n    };\n\n    var searchStr = '';\n    var clearSearchTimeout, optNodes, optText;\n    var CLEAR_SEARCH_AFTER = 300;\n    self.optNodeForKeyboardSearch = function(e) {\n      clearSearchTimeout && clearTimeout(clearSearchTimeout);\n      clearSearchTimeout = setTimeout(function() {\n        clearSearchTimeout = undefined;\n        searchStr = '';\n        optText = undefined;\n        optNodes = undefined;\n      }, CLEAR_SEARCH_AFTER);\n      searchStr += String.fromCharCode(e.keyCode);\n      var search = new RegExp('^' + searchStr, 'i');\n      if (!optNodes) {\n        optNodes = $element.find('md-option');\n        optText = new Array(optNodes.length);\n        angular.forEach(optNodes, function(el, i) {\n          optText[i] = el.textContent.trim();\n        });\n      }\n      for (var i = 0; i < optText.length; ++i) {\n        if (search.test(optText[i])) {\n          return optNodes[i];\n        }\n      }\n    };\n\n\n    self.init = function(ngModel) {\n      self.ngModel = ngModel;\n\n      // Allow users to provide `ng-model=\"foo\" ng-model-options=\"{trackBy: 'foo.id'}\"` so\n      // that we can properly compare objects set on the model to the available options\n      if (ngModel.$options && ngModel.$options.trackBy) {\n        var trackByLocals = {};\n        var trackByParsed = $parse(ngModel.$options.trackBy);\n        self.hashGetter = function(value, valueScope) {\n          trackByLocals.$value = value;\n          return trackByParsed(valueScope || $scope, trackByLocals);\n        };\n      // If the user doesn't provide a trackBy, we automatically generate an id for every\n      // value passed in\n      } else {\n        self.hashGetter = function getHashValue(value) {\n          if (angular.isObject(value)) {\n            return 'object_' + (value.$$mdSelectId || (value.$$mdSelectId = ++selectNextId));\n          }\n          return value;\n        };\n      }\n      self.setMultiple(self.isMultiple);\n    };\n\n    self.selectedLabels = function() {\n      var selectedOptionEls = nodesToArray($element[0].querySelectorAll('md-option[selected]'));\n      if (selectedOptionEls.length) {\n        return selectedOptionEls.map(function(el) { return el.textContent; }).join(', ');\n      } else {\n        return '';\n      }\n    };\n\n    self.select = function(hashKey, hashedValue) {\n      var option = self.options[hashKey];\n      option && option.setSelected(true);\n      self.selected[hashKey] = hashedValue;\n    };\n    self.deselect = function(hashKey) {\n      var option = self.options[hashKey];\n      option && option.setSelected(false);\n      delete self.selected[hashKey];\n    };\n\n    self.addOption = function(hashKey, optionCtrl) {\n      if (angular.isDefined(self.options[hashKey])) {\n        throw new Error('Duplicate md-option values are not allowed in a select. ' +\n                        'Duplicate value \"' + optionCtrl.value + '\" found.');\n      }\n      self.options[hashKey] = optionCtrl;\n\n      // If this option's value was already in our ngModel, go ahead and select it.\n      if (angular.isDefined(self.selected[hashKey])) {\n        self.select(hashKey, optionCtrl.value);\n        self.refreshViewValue();\n      }\n    };\n    self.removeOption = function(hashKey) {\n      delete self.options[hashKey];\n      // Don't deselect an option when it's removed - the user's ngModel should be allowed\n      // to have values that do not match a currently available option.\n    };\n\n    self.refreshViewValue = function() {\n      var values = [];\n      var option;\n      for (var hashKey in self.selected) {\n         // If this hashKey has an associated option, push that option's value to the model.\n         if ((option = self.options[hashKey])) {\n           values.push(option.value);\n         } else {\n           // Otherwise, the given hashKey has no associated option, and we got it\n           // from an ngModel value at an earlier time. Push the unhashed value of\n           // this hashKey to the model.\n           // This allows the developer to put a value in the model that doesn't yet have\n           // an associated option.\n           values.push(self.selected[hashKey]);\n         }\n      }\n      self.ngModel.$setViewValue(self.isMultiple ? values : values[0]);\n    };\n\n    function renderMultiple() {\n      var newSelectedValues = self.ngModel.$modelValue || self.ngModel.$viewValue;\n      if (!angular.isArray(newSelectedValues)) return;\n\n      var oldSelected = Object.keys(self.selected);\n\n      var newSelectedHashes = newSelectedValues.map(self.hashGetter);\n      var deselected = oldSelected.filter(function(hash) {\n        return newSelectedHashes.indexOf(hash) === -1;\n      });\n\n      deselected.forEach(self.deselect);\n      newSelectedHashes.forEach(function(hashKey, i) {\n        self.select(hashKey, newSelectedValues[i]);\n      });\n    }\n    function renderSingular() {\n      var value = self.ngModel.$viewValue || self.ngModel.$modelValue;\n      Object.keys(self.selected).forEach(self.deselect);\n      self.select( self.hashGetter(value), value );\n    }\n  }\n\n}\nSelectMenuDirective.$inject = [\"$parse\", \"$mdUtil\", \"$mdTheming\"];\n\nfunction OptionDirective($mdButtonInkRipple, $mdUtil) {\n\n  OptionController.$inject = [\"$element\"];\n  return {\n    restrict: 'E',\n    require: ['mdOption', '^^mdSelectMenu'],\n    controller: OptionController,\n    compile: compile\n  };\n\n  function compile(element, attr) {\n    // Manual transclusion to avoid the extra inner <span> that ng-transclude generates\n    element.append( angular.element('<div class=\"md-text\">').append(element.contents()) );\n\n    element.attr('tabindex', attr.tabindex || '0');\n    return postLink;\n  }\n\n  function postLink(scope, element, attr, ctrls) {\n    var optionCtrl = ctrls[0];\n    var selectCtrl = ctrls[1];\n\n    if (angular.isDefined(attr.ngValue)) {\n      scope.$watch(attr.ngValue, setOptionValue);\n    } else if (angular.isDefined(attr.value)) {\n      setOptionValue(attr.value);\n    } else {\n      scope.$watch(function() { return element.text(); }, setOptionValue);\n    }\n\n    scope.$$postDigest(function() {\n      attr.$observe('selected', function(selected) {\n        if (!angular.isDefined(selected)) return;\n        if (selected) {\n          if (!selectCtrl.isMultiple) {\n            selectCtrl.deselect( Object.keys(selectCtrl.selected)[0] );\n          }\n          selectCtrl.select(optionCtrl.hashKey, optionCtrl.value);\n        } else {\n          selectCtrl.deselect(optionCtrl.hashKey);\n        }\n        selectCtrl.refreshViewValue();\n        selectCtrl.ngModel.$render();\n      });\n    });\n\n    $mdButtonInkRipple.attach(scope, element);\n    configureAria();\n\n    function setOptionValue(newValue, oldValue) {\n      var oldHashKey = selectCtrl.hashGetter(oldValue, scope);\n      var newHashKey = selectCtrl.hashGetter(newValue, scope);\n\n      optionCtrl.hashKey = newHashKey;\n      optionCtrl.value = newValue;\n\n      selectCtrl.removeOption(oldHashKey, optionCtrl);\n      selectCtrl.addOption(newHashKey, optionCtrl);\n    }\n\n    scope.$on('$destroy', function() {\n      selectCtrl.removeOption(optionCtrl.hashKey, optionCtrl);\n    });\n\n    function configureAria() {\n      var ariaAttrs = {\n        'role': 'option',\n        'aria-selected': 'false'\n      };\n\n      if (!element[0].hasAttribute('id')) {\n        ariaAttrs.id = 'select_option_' + $mdUtil.nextUid();\n      }\n      element.attr(ariaAttrs);\n    }\n  }\n\n  function OptionController($element) {\n    this.selected = false;\n    this.setSelected = function(isSelected) {\n      if (isSelected && !this.selected) {\n        $element.attr({\n          'selected': 'selected',\n          'aria-selected': 'true'\n        });\n      } else if (!isSelected && this.selected) {\n        $element.removeAttr('selected');\n        $element.attr('aria-selected', 'false');\n      }\n      this.selected = isSelected;\n    };\n  }\n\n}\nOptionDirective.$inject = [\"$mdButtonInkRipple\", \"$mdUtil\"];\n\nfunction OptgroupDirective() {\n  return {\n    restrict: 'E',\n    compile: compile\n  };\n  function compile(el, attrs) {\n    var labelElement = el.find('label');\n    if (!labelElement.length) {\n      labelElement = angular.element('<label>');\n      el.prepend(labelElement);\n    }\n    if (attrs.label) labelElement.text(attrs.label);\n  }\n}\n\nfunction SelectProvider($$interimElementProvider) {\n  selectDefaultOptions.$inject = [\"$mdSelect\", \"$mdConstant\", \"$$rAF\", \"$mdUtil\", \"$mdTheming\", \"$timeout\", \"$window\"];\n  return $$interimElementProvider('$mdSelect')\n    .setDefaults({\n      methods: ['target'],\n      options: selectDefaultOptions\n    });\n\n  /* @ngInject */\n  function selectDefaultOptions($mdSelect, $mdConstant, $$rAF, $mdUtil, $mdTheming, $timeout, $window ) {\n    return {\n      parent: 'body',\n      onShow: onShow,\n      onRemove: onRemove,\n      hasBackdrop: true,\n      disableParentScroll: true,\n      themable: true\n    };\n\n    function onShow(scope, element, opts) {\n      if (!opts.target) {\n        throw new Error('$mdSelect.show() expected a target element in options.target but got ' +\n                        '\"' + opts.target + '\"!');\n      }\n\n      angular.extend(opts, {\n        isRemoved: false,\n        target: angular.element(opts.target), //make sure it's not a naked dom node\n        parent: angular.element(opts.parent),\n        selectEl: element.find('md-select-menu'),\n        contentEl: element.find('md-content'),\n        backdrop: opts.hasBackdrop && angular.element('<md-backdrop class=\"md-select-backdrop md-click-catcher\">')\n      });\n\n      opts.resizeFn = function() {\n        $$rAF(function() {\n          $$rAF(function() {\n            animateSelect(scope, element, opts);\n          });\n        });\n      };\n\n      angular.element($window).on('resize', opts.resizeFn);\n      angular.element($window).on('orientationchange', opts.resizeFn);\n\n\n      configureAria();\n\n      element.removeClass('md-leave');\n\n      var optionNodes = opts.selectEl[0].getElementsByTagName('md-option');\n\n      if (opts.loadingAsync && opts.loadingAsync.then) {\n        opts.loadingAsync.then(function() {\n          scope.$$loadingAsyncDone = true;\n          // Give ourselves two frames for the progress loader to clear out.\n          $$rAF(function() {\n            $$rAF(function() {\n              // Don't go forward if the select has been removed in this time...\n              if (opts.isRemoved) return;\n              animateSelect(scope, element, opts);\n            });\n          });\n        });\n      } else if (opts.loadingAsync) {\n        scope.$$loadingAsyncDone = true;\n      }\n\n      if (opts.disableParentScroll && !$mdUtil.getClosest(opts.target, 'MD-DIALOG')) {\n        opts.restoreScroll = $mdUtil.disableScrollAround(opts.target);\n      } else {\n        opts.disableParentScroll = false;\n      }\n      // Only activate click listeners after a short time to stop accidental double taps/clicks\n      // from clicking the wrong item\n      $timeout(activateInteraction, 75, false);\n\n      if (opts.backdrop) {\n        $mdTheming.inherit(opts.backdrop, opts.parent);\n        opts.parent.append(opts.backdrop);\n      }\n      opts.parent.append(element);\n\n      // Give the select a frame to 'initialize' in the DOM,\n      // so we can read its height/width/position\n      $$rAF(function() {\n        $$rAF(function() {\n          if (opts.isRemoved) return;\n          animateSelect(scope, element, opts);\n        });\n      });\n\n      return $mdUtil.transitionEndPromise(opts.selectEl, {timeout: 350});\n\n      function configureAria() {\n        opts.target.attr('aria-expanded', 'true');\n      }\n\n      function activateInteraction() {\n        if (opts.isRemoved) return;\n        var selectCtrl = opts.selectEl.controller('mdSelectMenu') || {};\n        element.addClass('md-clickable');\n\n        opts.backdrop && opts.backdrop.on('click', function(e) {\n          e.preventDefault();\n          e.stopPropagation();\n          opts.restoreFocus = false;\n          scope.$apply($mdSelect.cancel);\n        });\n\n        // Escape to close\n        opts.selectEl.on('keydown', function(ev) {\n          switch (ev.keyCode) {\n            case $mdConstant.KEY_CODE.SPACE:\n            case $mdConstant.KEY_CODE.ENTER:\n              var option = $mdUtil.getClosest(ev.target, 'md-option');\n              if (option) {\n                opts.selectEl.triggerHandler({\n                  type: 'click',\n                  target: option\n                });\n                ev.preventDefault();\n              }\n              break;\n            case $mdConstant.KEY_CODE.TAB:\n            case $mdConstant.KEY_CODE.ESCAPE:\n              ev.preventDefault();\n              opts.restoreFocus = true;\n              scope.$apply($mdSelect.cancel);\n          }\n        });\n\n        // Cycling of options, and closing on enter\n        opts.selectEl.on('keydown', function(ev) {\n          switch (ev.keyCode) {\n            case $mdConstant.KEY_CODE.UP_ARROW: return focusPrevOption();\n            case $mdConstant.KEY_CODE.DOWN_ARROW: return focusNextOption();\n            default:\n              if (ev.keyCode >= 31 && ev.keyCode <= 90) {\n                var optNode = opts.selectEl.controller('mdSelectMenu').optNodeForKeyboardSearch(ev);\n                optNode && optNode.focus();\n              }\n          }\n        });\n\n\n        function focusOption(direction) {\n          var optionsArray = nodesToArray(optionNodes);\n          var index = optionsArray.indexOf(opts.focusedNode);\n          if (index === -1) {\n            // We lost the previously focused element, reset to first option\n            index = 0;\n          } else if (direction === 'next' && index < optionsArray.length - 1) {\n            index++;\n          } else if (direction === 'prev' && index > 0) {\n            index--;\n          }\n          var newOption = opts.focusedNode = optionsArray[index];\n          newOption && newOption.focus();\n        }\n        function focusNextOption() {\n          focusOption('next');\n        }\n        function focusPrevOption() {\n          focusOption('prev');\n        }\n\n        opts.selectEl.on('click', checkCloseMenu);\n        opts.selectEl.on('keydown', function(e) {\n          if (e.keyCode == 32 || e.keyCode == 13) {\n            checkCloseMenu();\n          }\n        });\n\n        function checkCloseMenu() {\n          if (!selectCtrl.isMultiple) {\n            opts.restoreFocus = true;\n            scope.$evalAsync(function() {\n              $mdSelect.hide(selectCtrl.ngModel.$viewValue);\n            });\n          }\n        }\n      }\n\n    }\n\n    function onRemove(scope, element, opts) {\n      opts.isRemoved = true;\n      element.addClass('md-leave')\n        .removeClass('md-clickable');\n      opts.target.attr('aria-expanded', 'false');\n\n\n      angular.element($window).off('resize', opts.resizeFn);\n      angular.element($window).off('orientationchange', opts.resizefn);\n      opts.resizeFn = undefined;\n\n      var mdSelect = opts.selectEl.controller('mdSelect');\n      if (mdSelect) {\n        mdSelect.setLabelText(opts.selectEl.controller('mdSelectMenu').selectedLabels());\n      }\n\n      return $mdUtil.transitionEndPromise(element, { timeout: 350 }).then(function() {\n        element.removeClass('md-active');\n        opts.backdrop && opts.backdrop.remove();\n        if (element[0].parentNode === opts.parent[0]) {\n          opts.parent[0].removeChild(element[0]); // use browser to avoid $destroy event\n        }\n        if (opts.disableParentScroll) {\n          opts.restoreScroll();\n        }\n        if (opts.restoreFocus) opts.target.focus();\n      });\n    }\n\n    function animateSelect(scope, element, opts) {\n      var containerNode = element[0],\n          targetNode = opts.target[0].firstElementChild.firstElementChild, // target the first span, functioning as the label\n          parentNode = opts.parent[0],\n          selectNode = opts.selectEl[0],\n          contentNode = opts.contentEl[0],\n          parentRect = parentNode.getBoundingClientRect(),\n          targetRect = targetNode.getBoundingClientRect(),\n          shouldOpenAroundTarget = false,\n          bounds = {\n            left: parentRect.left + SELECT_EDGE_MARGIN,\n            top: SELECT_EDGE_MARGIN,\n            bottom: parentRect.height - SELECT_EDGE_MARGIN,\n            right: parentRect.width - SELECT_EDGE_MARGIN - ($mdUtil.floatingScrollbars() ? 16 : 0)\n          },\n          spaceAvailable = {\n            top: targetRect.top - bounds.top,\n            left: targetRect.left - bounds.left,\n            right: bounds.right - (targetRect.left + targetRect.width),\n            bottom: bounds.bottom - (targetRect.top + targetRect.height)\n          },\n          maxWidth = parentRect.width - SELECT_EDGE_MARGIN * 2,\n          isScrollable = contentNode.scrollHeight > contentNode.offsetHeight,\n          selectedNode = selectNode.querySelector('md-option[selected]'),\n          optionNodes = selectNode.getElementsByTagName('md-option'),\n          optgroupNodes = selectNode.getElementsByTagName('md-optgroup');\n\n\n      var centeredNode;\n      // If a selected node, center around that\n      if (selectedNode) {\n        centeredNode = selectedNode;\n      // If there are option groups, center around the first option group\n      } else if (optgroupNodes.length) {\n        centeredNode = optgroupNodes[0];\n      // Otherwise, center around the first optionNode\n      } else if (optionNodes.length){\n        centeredNode = optionNodes[0];\n      // In case there are no options, center on whatever's in there... (eg progress indicator)\n      } else {\n        centeredNode = contentNode.firstElementChild || contentNode;\n      }\n\n      if (contentNode.offsetWidth > maxWidth) {\n        contentNode.style['max-width'] = maxWidth + 'px';\n      }\n      if (shouldOpenAroundTarget) {\n        contentNode.style['min-width'] = targetRect.width + 'px';\n      }\n\n      // Remove padding before we compute the position of the menu\n      if (isScrollable) {\n        selectNode.classList.add('md-overflow');\n      }\n\n      // Get the selectMenuRect *after* max-width is possibly set above\n      var selectMenuRect = selectNode.getBoundingClientRect();\n      var centeredRect = getOffsetRect(centeredNode);\n\n      if (centeredNode) {\n        var centeredStyle = $window.getComputedStyle(centeredNode);\n        centeredRect.paddingLeft = parseInt(centeredStyle.paddingLeft, 10) || 0;\n        centeredRect.paddingRight = parseInt(centeredStyle.paddingRight, 10) || 0;\n      }\n\n      var focusedNode = centeredNode;\n      if ((focusedNode.tagName || '').toUpperCase() === 'MD-OPTGROUP') {\n        focusedNode = optionNodes[0] || contentNode.firstElementChild || contentNode;\n      }\n\n      if (isScrollable) {\n        var scrollBuffer = contentNode.offsetHeight / 2;\n        contentNode.scrollTop = centeredRect.top + centeredRect.height / 2 - scrollBuffer;\n\n        if (spaceAvailable.top < scrollBuffer) {\n          contentNode.scrollTop = Math.min(\n            centeredRect.top,\n            contentNode.scrollTop + scrollBuffer - spaceAvailable.top\n          );\n        } else if (spaceAvailable.bottom < scrollBuffer) {\n          contentNode.scrollTop = Math.max(\n            centeredRect.top + centeredRect.height - selectMenuRect.height,\n            contentNode.scrollTop - scrollBuffer + spaceAvailable.bottom\n          );\n        }\n      }\n\n      var left, top, transformOrigin;\n      if (shouldOpenAroundTarget) {\n        left = targetRect.left;\n        top = targetRect.top + targetRect.height;\n        transformOrigin = '50% 0';\n        if (top + selectMenuRect.height > bounds.bottom) {\n          top = targetRect.top - selectMenuRect.height;\n          transformOrigin = '50% 100%';\n        }\n      } else {\n        left = targetRect.left + centeredRect.left - centeredRect.paddingLeft;\n        top = Math.floor(targetRect.top + targetRect.height / 2 - centeredRect.height / 2 -\n          centeredRect.top + contentNode.scrollTop);\n\n\n        transformOrigin = (centeredRect.left + targetRect.width / 2) + 'px ' +\n        (centeredRect.top + centeredRect.height / 2 - contentNode.scrollTop) + 'px 0px';\n\n        containerNode.style.minWidth = targetRect.width + centeredRect.paddingLeft +\n          centeredRect.paddingRight + 'px';\n      }\n\n      // Keep left and top within the window\n      var containerRect = containerNode.getBoundingClientRect();\n      containerNode.style.left = clamp(bounds.left, left, bounds.right - containerRect.width) + 'px';\n      containerNode.style.top = clamp(bounds.top, top, bounds.bottom - containerRect.height) + 'px';\n      selectNode.style[$mdConstant.CSS.TRANSFORM_ORIGIN] = transformOrigin;\n\n      selectNode.style[$mdConstant.CSS.TRANSFORM] = 'scale(' +\n        Math.min(targetRect.width / selectMenuRect.width, 1.0) + ',' +\n        Math.min(targetRect.height / selectMenuRect.height, 1.0) +\n      ')';\n\n\n      $$rAF(function() {\n        element.addClass('md-active');\n        selectNode.style[$mdConstant.CSS.TRANSFORM] = '';\n        if (focusedNode) {\n          opts.focusedNode = focusedNode;\n          focusedNode.focus();\n        }\n      });\n    }\n\n  }\n\n  function clamp(min, n, max) {\n    return Math.max(min, Math.min(n, max));\n  }\n\n  function getOffsetRect(node) {\n    return node ? {\n      left: node.offsetLeft,\n      top: node.offsetTop,\n      width: node.offsetWidth,\n      height: node.offsetHeight\n    } : { left: 0, top: 0, width: 0, height: 0 };\n  }\n}\nSelectProvider.$inject = [\"$$interimElementProvider\"];\n\n// Annoying method to copy nodes to an array, thanks to IE\nfunction nodesToArray(nodes) {\n  var results = [];\n  for (var i = 0; i < nodes.length; ++i) {\n    results.push(nodes.item(i));\n  }\n  return results;\n}\n\n})();\n(function(){\n\"use strict\";\n\n/**\n * @ngdoc module\n * @name material.components.sidenav\n *\n * @description\n * A Sidenav QP component.\n */\nangular.module('material.components.sidenav', [\n    'material.core',\n    'material.components.backdrop'\n  ])\n  .factory('$mdSidenav', SidenavService )\n  .directive('mdSidenav', SidenavDirective)\n  .directive('mdSidenavFocus', SidenavFocusDirective)\n  .controller('$mdSidenavController', SidenavController);\n\n\n/**\n * @private\n * @ngdoc service\n * @name $mdSidenav\n * @module material.components.sidenav\n *\n * @description\n * `$mdSidenav` makes it easy to interact with multiple sidenavs\n * in an app.\n *\n * @usage\n * <hljs lang=\"js\">\n * // Async lookup for sidenav instance; will resolve when the instance is available\n * $mdSidenav(componentId).then(function(instance) {\n *   $log.debug( componentId + \"is now ready\" );\n * });\n * // Async toggle the given sidenav;\n * // when instance is known ready and lazy lookup is not needed.\n * $mdSidenav(componentId)\n *    .toggle()\n *    .then(function(){\n *      $log.debug('toggled');\n *    });\n * // Async open the given sidenav\n * $mdSidenav(componentId)\n *    .open()\n *    .then(function(){\n *      $log.debug('opened');\n *    });\n * // Async close the given sidenav\n * $mdSidenav(componentId)\n *    .close()\n *    .then(function(){\n *      $log.debug('closed');\n *    });\n * // Sync check to see if the specified sidenav is set to be open\n * $mdSidenav(componentId).isOpen();\n * // Sync check to whether given sidenav is locked open\n * // If this is true, the sidenav will be open regardless of close()\n * $mdSidenav(componentId).isLockedOpen();\n * </hljs>\n */\nfunction SidenavService($mdComponentRegistry, $q) {\n  return function(handle) {\n\n    // Lookup the controller instance for the specified sidNav instance\n    var self;\n    var errorMsg = \"SideNav '\" + handle + \"' is not available!\";\n    var instance = $mdComponentRegistry.get(handle);\n\n    if(!instance) {\n      $mdComponentRegistry.notFoundError(handle);\n    }\n\n    return self = {\n      // -----------------\n      // Sync methods\n      // -----------------\n      isOpen: function() {\n        return instance && instance.isOpen();\n      },\n      isLockedOpen: function() {\n        return instance && instance.isLockedOpen();\n      },\n      // -----------------\n      // Async methods\n      // -----------------\n      toggle: function() {\n        return instance ? instance.toggle() : $q.reject(errorMsg);\n      },\n      open: function() {\n        return instance ? instance.open() : $q.reject(errorMsg);\n      },\n      close: function() {\n        return instance ? instance.close() : $q.reject(errorMsg);\n      },\n      then : function( callbackFn ) {\n        var promise = instance ? $q.when(instance) : waitForInstance();\n        return promise.then( callbackFn || angular.noop );\n      }\n    };\n\n    /**\n     * Deferred lookup of component instance using $component registry\n     */\n    function waitForInstance() {\n      return $mdComponentRegistry\n                .when(handle)\n                .then(function( it ){\n                  instance = it;\n                  return it;\n                });\n    }\n  };\n}\nSidenavService.$inject = [\"$mdComponentRegistry\", \"$q\"];\n/**\n * @ngdoc directive\n * @name mdSidenavFocus\n * @module material.components.sidenav\n *\n * @restrict A\n *\n * @description\n * `$mdSidenavFocus` provides a way to specify the focused element when a sidenav opens.\n * This is completely optional, as the sidenav itself is focused by default.\n *\n * @usage\n * <hljs lang=\"html\">\n * <md-sidenav>\n *   <form>\n *     <md-input-container>\n *       <label for=\"testInput\">Label</label>\n *       <input id=\"testInput\" type=\"text\" md-sidenav-focus>\n *     </md-input-container>\n *   </form>\n * </md-sidenav>\n * </hljs>\n **/\nfunction SidenavFocusDirective() {\n  return {\n    restrict: 'A',\n    require: '^mdSidenav',\n    link: function(scope, element, attr, sidenavCtrl) {\n      sidenavCtrl.focusElement(element);\n    }\n  };\n}\n/**\n * @ngdoc directive\n * @name mdSidenav\n * @module material.components.sidenav\n * @restrict E\n *\n * @description\n *\n * A Sidenav component that can be opened and closed programatically.\n *\n * By default, upon opening it will slide out on top of the main content area.\n *\n * For keyboard and screen reader accessibility, focus is sent to the sidenav wrapper by default.\n * It can be overridden with the `md-sidenav-focus` directive on the child element you want focused.\n *\n * @usage\n * <hljs lang=\"html\">\n * <div layout=\"row\" ng-controller=\"MyController\">\n *   <md-sidenav md-component-id=\"left\" class=\"md-sidenav-left\">\n *     Left Nav!\n *   </md-sidenav>\n *\n *   <md-content>\n *     Center Content\n *     <md-button ng-click=\"openLeftMenu()\">\n *       Open Left Menu\n *     </md-button>\n *   </md-content>\n *\n *   <md-sidenav md-component-id=\"right\"\n *     md-is-locked-open=\"$mdMedia('min-width: 333px')\"\n *     class=\"md-sidenav-right\">\n *     <form>\n *       <md-input-container>\n *         <label for=\"testInput\">Test input</label>\n *         <input id=\"testInput\" type=\"text\"\n *                ng-model=\"data\" md-sidenav-focus>\n *       </md-input-container>\n *     </form>\n *   </md-sidenav>\n * </div>\n * </hljs>\n *\n * <hljs lang=\"js\">\n * var app = angular.module('myApp', ['ngMaterial']);\n * app.controller('MyController', function($scope, $mdSidenav) {\n *   $scope.openLeftMenu = function() {\n *     $mdSidenav('left').toggle();\n *   };\n * });\n * </hljs>\n *\n * @param {expression=} md-is-open A model bound to whether the sidenav is opened.\n * @param {string=} md-component-id componentId to use with $mdSidenav service.\n * @param {expression=} md-is-locked-open When this expression evalutes to true,\n * the sidenav 'locks open': it falls into the content's flow instead\n * of appearing over it. This overrides the `is-open` attribute.\n *\n * The $mdMedia() service is exposed to the is-locked-open attribute, which\n * can be given a media query or one of the `sm`, `gt-sm`, `md`, `gt-md`, `lg` or `gt-lg` presets.\n * Examples:\n *\n *   - `<md-sidenav md-is-locked-open=\"shouldLockOpen\"></md-sidenav>`\n *   - `<md-sidenav md-is-locked-open=\"$mdMedia('min-width: 1000px')\"></md-sidenav>`\n *   - `<md-sidenav md-is-locked-open=\"$mdMedia('sm')\"></md-sidenav>` (locks open on small screens)\n */\nfunction SidenavDirective($timeout, $animate, $parse, $log, $mdMedia, $mdConstant, $compile, $mdTheming, $q, $document) {\n  return {\n    restrict: 'E',\n    scope: {\n      isOpen: '=?mdIsOpen'\n    },\n    controller: '$mdSidenavController',\n    compile: function(element) {\n      element.addClass('md-closed');\n      element.attr('tabIndex', '-1');\n      return postLink;\n    }\n  };\n\n  /**\n   * Directive Post Link function...\n   */\n  function postLink(scope, element, attr, sidenavCtrl) {\n    var lastParentOverFlow;\n    var triggeringElement = null;\n    var promise = $q.when(true);\n\n    var isLockedOpenParsed = $parse(attr.mdIsLockedOpen);\n    var isLocked = function() {\n      return isLockedOpenParsed(scope.$parent, {\n        $media: function(arg) {\n          $log.warn(\"$media is deprecated for is-locked-open. Use $mdMedia instead.\");\n          return $mdMedia(arg);\n        },\n        $mdMedia: $mdMedia\n      });\n    };\n    var backdrop = $compile(\n      '<md-backdrop class=\"md-sidenav-backdrop md-opaque ng-enter\">'\n    )(scope);\n\n    element.on('$destroy', sidenavCtrl.destroy);\n    $mdTheming.inherit(backdrop, element);\n\n    scope.$watch(isLocked, updateIsLocked);\n    scope.$watch('isOpen', updateIsOpen);\n\n\n    // Publish special accessor for the Controller instance\n    sidenavCtrl.$toggleOpen = toggleOpen;\n    sidenavCtrl.focusElement( sidenavCtrl.focusElement() || element );\n\n    /**\n     * Toggle the DOM classes to indicate `locked`\n     * @param isLocked\n     */\n    function updateIsLocked(isLocked, oldValue) {\n      scope.isLockedOpen = isLocked;\n      if (isLocked === oldValue) {\n        element.toggleClass('md-locked-open', !!isLocked);\n      } else {\n        $animate[isLocked ? 'addClass' : 'removeClass'](element, 'md-locked-open');\n      }\n      backdrop.toggleClass('md-locked-open', !!isLocked);\n    }\n\n    /**\n     * Toggle the SideNav view and attach/detach listeners\n     * @param isOpen\n     */\n    function updateIsOpen(isOpen) {\n      var parent = element.parent();\n\n      parent[isOpen ? 'on' : 'off']('keydown', onKeyDown);\n      backdrop[isOpen ? 'on' : 'off']('click', close);\n\n      if ( isOpen ) {\n        // Capture upon opening..\n        triggeringElement = $document[0].activeElement;\n      }\n      var focusEl = sidenavCtrl.focusElement();\n\n      disableParentScroll(isOpen);\n\n      return promise = $q.all([\n                isOpen ? $animate.enter(backdrop, parent) : $animate.leave(backdrop),\n                $animate[isOpen ? 'removeClass' : 'addClass'](element, 'md-closed')\n              ])\n              .then(function() {\n                // Perform focus when animations are ALL done...\n                if (scope.isOpen) {\n                  focusEl && focusEl.focus();\n                }\n              });\n    }\n\n    /**\n     * Prevent parent scrolling (when the SideNav is open)\n     */\n    function disableParentScroll(disabled) {\n      var parent = element.parent();\n      if ( disabled ) {\n        lastParentOverFlow = parent.css('overflow');\n        parent.css('overflow', 'hidden');\n      } else if (angular.isDefined(lastParentOverFlow)) {\n        parent.css('overflow', lastParentOverFlow);\n        lastParentOverFlow = undefined;\n      }\n    }\n\n    /**\n     * Toggle the sideNav view and publish a promise to be resolved when\n     * the view animation finishes.\n     *\n     * @param isOpen\n     * @returns {*}\n     */\n    function toggleOpen( isOpen ) {\n      if (scope.isOpen == isOpen ) {\n\n        return $q.when(true);\n\n      } else {\n        var deferred = $q.defer();\n\n        // Toggle value to force an async `updateIsOpen()` to run\n        scope.isOpen = isOpen;\n\n        $timeout(function() {\n\n          // When the current `updateIsOpen()` animation finishes\n          promise.then(function(result) {\n\n            if ( !scope.isOpen ) {\n              // reset focus to originating element (if available) upon close\n              triggeringElement && triggeringElement.focus();\n              triggeringElement = null;\n            }\n\n            deferred.resolve(result);\n          });\n\n        },0,false);\n\n        return deferred.promise;\n      }\n    }\n\n    /**\n     * Auto-close sideNav when the `escape` key is pressed.\n     * @param evt\n     */\n    function onKeyDown(ev) {\n      var isEscape = (ev.keyCode === $mdConstant.KEY_CODE.ESCAPE);\n      return isEscape ? close(ev) : $q.when(true);\n    }\n\n    /**\n     * With backdrop `clicks` or `escape` key-press, immediately\n     * apply the CSS close transition... Then notify the controller\n     * to close() and perform its own actions.\n     */\n    function close(ev) {\n      ev.preventDefault();\n      ev.stopPropagation();\n\n      return sidenavCtrl.close();\n    }\n\n  }\n}\nSidenavDirective.$inject = [\"$timeout\", \"$animate\", \"$parse\", \"$log\", \"$mdMedia\", \"$mdConstant\", \"$compile\", \"$mdTheming\", \"$q\", \"$document\"];\n\n/*\n * @private\n * @ngdoc controller\n * @name SidenavController\n * @module material.components.sidenav\n *\n */\nfunction SidenavController($scope, $element, $attrs, $mdComponentRegistry, $q) {\n\n  var self = this,\n      focusElement;\n\n  // Use Default internal method until overridden by directive postLink\n\n  // Synchronous getters\n  self.isOpen = function() { return !!$scope.isOpen; };\n  self.isLockedOpen = function() { return !!$scope.isLockedOpen; };\n\n  // Async actions\n  self.open   = function() { return self.$toggleOpen( true );  };\n  self.close  = function() { return self.$toggleOpen( false ); };\n  self.toggle = function() { return self.$toggleOpen( !$scope.isOpen );  };\n  self.focusElement = function(el) {\n    if ( angular.isDefined(el) ) {\n      focusElement = el;\n    }\n    return focusElement;\n  };\n\n  self.$toggleOpen = function() { return $q.when($scope.isOpen); };\n\n  self.destroy = $mdComponentRegistry.register(self, $attrs.mdComponentId);\n}\nSidenavController.$inject = [\"$scope\", \"$element\", \"$attrs\", \"$mdComponentRegistry\", \"$q\"];\n\n})();\n(function(){\n\"use strict\";\n\n  /**\n   * @ngdoc module\n   * @name material.components.slider\n   */\n  angular.module('material.components.slider', [\n    'material.core'\n  ])\n  .directive('mdSlider', SliderDirective);\n\n/**\n * @ngdoc directive\n * @name mdSlider\n * @module material.components.slider\n * @restrict E\n * @description\n * The `<md-slider>` component allows the user to choose from a range of\n * values.\n *\n * As per the [material design spec](http://www.google.com/design/spec/style/color.html#color-ui-color-application)\n * the slider is in the accent color by default. The primary color palette may be used with\n * the `md-primary` class.\n *\n * It has two modes: 'normal' mode, where the user slides between a wide range\n * of values, and 'discrete' mode, where the user slides between only a few\n * select values.\n *\n * To enable discrete mode, add the `md-discrete` attribute to a slider,\n * and use the `step` attribute to change the distance between\n * values the user is allowed to pick.\n *\n * @usage\n * <h4>Normal Mode</h4>\n * <hljs lang=\"html\">\n * <md-slider ng-model=\"myValue\" min=\"5\" max=\"500\">\n * </md-slider>\n * </hljs>\n * <h4>Discrete Mode</h4>\n * <hljs lang=\"html\">\n * <md-slider md-discrete ng-model=\"myDiscreteValue\" step=\"10\" min=\"10\" max=\"130\">\n * </md-slider>\n * </hljs>\n *\n * @param {boolean=} md-discrete Whether to enable discrete mode.\n * @param {number=} step The distance between values the user is allowed to pick. Default 1.\n * @param {number=} min The minimum value the user is allowed to pick. Default 0.\n * @param {number=} max The maximum value the user is allowed to pick. Default 100.\n */\nfunction SliderDirective($$rAF, $window, $mdAria, $mdUtil, $mdConstant, $mdTheming, $mdGesture, $parse) {\n  return {\n    scope: {},\n    require: '?ngModel',\n    template:\n      '<div class=\"md-slider-wrapper\">\\\n        <div class=\"md-track-container\">\\\n          <div class=\"md-track\"></div>\\\n          <div class=\"md-track md-track-fill\"></div>\\\n          <div class=\"md-track-ticks\"></div>\\\n        </div>\\\n        <div class=\"md-thumb-container\">\\\n          <div class=\"md-thumb\"></div>\\\n          <div class=\"md-focus-thumb\"></div>\\\n          <div class=\"md-focus-ring\"></div>\\\n          <div class=\"md-sign\">\\\n            <span class=\"md-thumb-text\"></span>\\\n          </div>\\\n          <div class=\"md-disabled-thumb\"></div>\\\n        </div>\\\n      </div>',\n    compile: compile\n  };\n\n  // **********************************************************\n  // Private Methods\n  // **********************************************************\n\n  function compile (tElement, tAttrs) {\n    tElement.attr({\n      tabIndex: 0,\n      role: 'slider'\n    });\n\n    $mdAria.expect(tElement, 'aria-label');\n\n    return postLink;\n  }\n\n  function postLink(scope, element, attr, ngModelCtrl) {\n    $mdTheming(element);\n    ngModelCtrl = ngModelCtrl || {\n      // Mock ngModelController if it doesn't exist to give us\n      // the minimum functionality needed\n      $setViewValue: function(val) {\n        this.$viewValue = val;\n        this.$viewChangeListeners.forEach(function(cb) { cb(); });\n      },\n      $parsers: [],\n      $formatters: [],\n      $viewChangeListeners: []\n    };\n\n    var isDisabledParsed = attr.ngDisabled && $parse(attr.ngDisabled);\n    var isDisabledGetter = isDisabledParsed ?\n      function() { return isDisabledParsed(scope.$parent); } :\n      angular.noop;\n    var thumb = angular.element(element[0].querySelector('.md-thumb'));\n    var thumbText = angular.element(element[0].querySelector('.md-thumb-text'));\n    var thumbContainer = thumb.parent();\n    var trackContainer = angular.element(element[0].querySelector('.md-track-container'));\n    var activeTrack = angular.element(element[0].querySelector('.md-track-fill'));\n    var tickContainer = angular.element(element[0].querySelector('.md-track-ticks'));\n    var throttledRefreshDimensions = $mdUtil.throttle(refreshSliderDimensions, 5000);\n\n    // Default values, overridable by attrs\n    attr.min ? attr.$observe('min', updateMin) : updateMin(0);\n    attr.max ? attr.$observe('max', updateMax) : updateMax(100);\n    attr.step ? attr.$observe('step', updateStep) : updateStep(1);\n\n    // We have to manually stop the $watch on ngDisabled because it exists\n    // on the parent scope, and won't be automatically destroyed when\n    // the component is destroyed.\n    var stopDisabledWatch = angular.noop;\n    if (attr.ngDisabled) {\n      stopDisabledWatch = scope.$parent.$watch(attr.ngDisabled, updateAriaDisabled);\n    }\n\n    $mdGesture.register(element, 'drag');\n\n    element\n      .on('keydown', keydownListener)\n      .on('$md.pressdown', onPressDown)\n      .on('$md.pressup', onPressUp)\n      .on('$md.dragstart', onDragStart)\n      .on('$md.drag', onDrag)\n      .on('$md.dragend', onDragEnd);\n\n    // On resize, recalculate the slider's dimensions and re-render\n    function updateAll() {\n      refreshSliderDimensions();\n      ngModelRender();\n      redrawTicks();\n    }\n    setTimeout(updateAll);\n\n    var debouncedUpdateAll = $$rAF.throttle(updateAll);\n    angular.element($window).on('resize', debouncedUpdateAll);\n\n    scope.$on('$destroy', function() {\n      angular.element($window).off('resize', debouncedUpdateAll);\n      stopDisabledWatch();\n    });\n\n    ngModelCtrl.$render = ngModelRender;\n    ngModelCtrl.$viewChangeListeners.push(ngModelRender);\n    ngModelCtrl.$formatters.push(minMaxValidator);\n    ngModelCtrl.$formatters.push(stepValidator);\n\n    /**\n     * Attributes\n     */\n    var min;\n    var max;\n    var step;\n    function updateMin(value) {\n      min = parseFloat(value);\n      element.attr('aria-valuemin', value);\n      updateAll();\n    }\n    function updateMax(value) {\n      max = parseFloat(value);\n      element.attr('aria-valuemax', value);\n      updateAll();\n    }\n    function updateStep(value) {\n      step = parseFloat(value);\n      redrawTicks();\n    }\n    function updateAriaDisabled(isDisabled) {\n      element.attr('aria-disabled', !!isDisabled);\n    }\n\n    // Draw the ticks with canvas.\n    // The alternative to drawing ticks with canvas is to draw one element for each tick,\n    // which could quickly become a performance bottleneck.\n    var tickCanvas, tickCtx;\n    function redrawTicks() {\n      if (!angular.isDefined(attr.mdDiscrete)) return;\n\n      var numSteps = Math.floor( (max - min) / step );\n      if (!tickCanvas) {\n        var trackTicksStyle = $window.getComputedStyle(tickContainer[0]);\n        tickCanvas = angular.element('<canvas style=\"position:absolute;\">');\n        tickCtx = tickCanvas[0].getContext('2d');\n        tickCtx.fillStyle = trackTicksStyle.backgroundColor || 'black';\n        tickContainer.append(tickCanvas);\n      }\n      var dimensions = getSliderDimensions();\n      tickCanvas[0].width = dimensions.width;\n      tickCanvas[0].height = dimensions.height;\n\n      var distance;\n      for (var i = 0; i <= numSteps; i++) {\n        distance = Math.floor(dimensions.width * (i / numSteps));\n        tickCtx.fillRect(distance - 1, 0, 2, dimensions.height);\n      }\n    }\n\n\n    /**\n     * Refreshing Dimensions\n     */\n    var sliderDimensions = {};\n    refreshSliderDimensions();\n    function refreshSliderDimensions() {\n      sliderDimensions = trackContainer[0].getBoundingClientRect();\n    }\n    function getSliderDimensions() {\n      throttledRefreshDimensions();\n      return sliderDimensions;\n    }\n\n    /**\n     * left/right arrow listener\n     */\n    function keydownListener(ev) {\n      if(element[0].hasAttribute('disabled')) {\n        return;\n      }\n\n      var changeAmount;\n      if (ev.keyCode === $mdConstant.KEY_CODE.LEFT_ARROW) {\n        changeAmount = -step;\n      } else if (ev.keyCode === $mdConstant.KEY_CODE.RIGHT_ARROW) {\n        changeAmount = step;\n      }\n      if (changeAmount) {\n        if (ev.metaKey || ev.ctrlKey || ev.altKey) {\n          changeAmount *= 4;\n        }\n        ev.preventDefault();\n        ev.stopPropagation();\n        scope.$evalAsync(function() {\n          setModelValue(ngModelCtrl.$viewValue + changeAmount);\n        });\n      }\n    }\n\n    /**\n     * ngModel setters and validators\n     */\n    function setModelValue(value) {\n      ngModelCtrl.$setViewValue( minMaxValidator(stepValidator(value)) );\n    }\n    function ngModelRender() {\n      if (isNaN(ngModelCtrl.$viewValue)) {\n        ngModelCtrl.$viewValue = ngModelCtrl.$modelValue;\n      }\n\n      var percent = (ngModelCtrl.$viewValue - min) / (max - min);\n      scope.modelValue = ngModelCtrl.$viewValue;\n      element.attr('aria-valuenow', ngModelCtrl.$viewValue);\n      setSliderPercent(percent);\n      thumbText.text( ngModelCtrl.$viewValue );\n    }\n\n    function minMaxValidator(value) {\n      if (angular.isNumber(value)) {\n        return Math.max(min, Math.min(max, value));\n      }\n    }\n    function stepValidator(value) {\n      if (angular.isNumber(value)) {\n        return Math.round(value / step) * step;\n      }\n    }\n\n    /**\n     * @param percent 0-1\n     */\n    function setSliderPercent(percent) {\n      activeTrack.css('width', (percent * 100) + '%');\n      thumbContainer.css(\n        'left',\n        (percent * 100) + '%'\n      );\n      element.toggleClass('md-min', percent === 0);\n    }\n\n\n    /**\n     * Slide listeners\n     */\n    var isDragging = false;\n    var isDiscrete = angular.isDefined(attr.mdDiscrete);\n\n    function onPressDown(ev) {\n      if (isDisabledGetter()) return;\n\n      element.addClass('active');\n      element[0].focus();\n      refreshSliderDimensions();\n\n      var exactVal = percentToValue( positionToPercent( ev.pointer.x ));\n      var closestVal = minMaxValidator( stepValidator(exactVal) );\n      scope.$apply(function() {\n        setModelValue( closestVal );\n        setSliderPercent( valueToPercent(closestVal));\n      });\n    }\n    function onPressUp(ev) {\n      if (isDisabledGetter()) return;\n\n      element.removeClass('dragging active');\n\n      var exactVal = percentToValue( positionToPercent( ev.pointer.x ));\n      var closestVal = minMaxValidator( stepValidator(exactVal) );\n      scope.$apply(function() {\n        setModelValue(closestVal);\n        ngModelRender();\n      });\n    }\n    function onDragStart(ev) {\n      if (isDisabledGetter()) return;\n      isDragging = true;\n      ev.stopPropagation();\n\n      element.addClass('dragging');\n      setSliderFromEvent(ev);\n    }\n    function onDrag(ev) {\n      if (!isDragging) return;\n      ev.stopPropagation();\n      setSliderFromEvent(ev);\n    }\n    function onDragEnd(ev) {\n      if (!isDragging) return;\n      ev.stopPropagation();\n      isDragging = false;\n    }\n\n    function setSliderFromEvent(ev) {\n      // While panning discrete, update only the\n      // visual positioning but not the model value.\n      if ( isDiscrete ) adjustThumbPosition( ev.pointer.x );\n      else              doSlide( ev.pointer.x );\n    }\n\n    /**\n     * Slide the UI by changing the model value\n     * @param x\n     */\n    function doSlide( x ) {\n      scope.$evalAsync( function() {\n        setModelValue( percentToValue( positionToPercent(x) ));\n      });\n    }\n\n    /**\n     * Slide the UI without changing the model (while dragging/panning)\n     * @param x\n     */\n    function adjustThumbPosition( x ) {\n      var exactVal = percentToValue( positionToPercent( x ));\n      var closestVal = minMaxValidator( stepValidator(exactVal) );\n      setSliderPercent( positionToPercent(x) );\n      thumbText.text( closestVal );\n    }\n\n    /**\n     * Convert horizontal position on slider to percentage value of offset from beginning...\n     * @param x\n     * @returns {number}\n     */\n    function positionToPercent( x ) {\n      return Math.max(0, Math.min(1, (x - sliderDimensions.left) / (sliderDimensions.width)));\n    }\n\n    /**\n     * Convert percentage offset on slide to equivalent model value\n     * @param percent\n     * @returns {*}\n     */\n    function percentToValue( percent ) {\n      return (min + percent * (max - min));\n    }\n\n    function valueToPercent( val ) {\n      return (val - min)/(max - min);\n    }\n  }\n}\nSliderDirective.$inject = [\"$$rAF\", \"$window\", \"$mdAria\", \"$mdUtil\", \"$mdConstant\", \"$mdTheming\", \"$mdGesture\", \"$parse\"];\n\n})();\n(function(){\n\"use strict\";\n\n/*\n * @ngdoc module\n * @name material.components.sticky\n * @description\n *\n * Sticky effects for md\n */\n\nangular.module('material.components.sticky', [\n  'material.core',\n  'material.components.content'\n])\n  .factory('$mdSticky', MdSticky);\n\n/*\n * @ngdoc service\n * @name $mdSticky\n * @module material.components.sticky\n *\n * @description\n * The `$mdSticky`service provides a mixin to make elements sticky.\n *\n * @returns A `$mdSticky` function that takes three arguments:\n *   - `scope`\n *   - `element`: The element that will be 'sticky'\n *   - `elementClone`: A clone of the element, that will be shown\n *     when the user starts scrolling past the original element.\n *     If not provided, it will use the result of `element.clone()`.\n */\n\nfunction MdSticky($document, $mdConstant, $compile, $$rAF, $mdUtil) {\n\n  var browserStickySupport = checkStickySupport();\n\n  /**\n   * Registers an element as sticky, used internally by directives to register themselves\n   */\n  return function registerStickyElement(scope, element, stickyClone) {\n    var contentCtrl = element.controller('mdContent');\n    if (!contentCtrl) return;\n\n    if (browserStickySupport) {\n      element.css({\n        position: browserStickySupport,\n        top: 0,\n        'z-index': 2\n      });\n    } else {\n      var $$sticky = contentCtrl.$element.data('$$sticky');\n      if (!$$sticky) {\n        $$sticky = setupSticky(contentCtrl);\n        contentCtrl.$element.data('$$sticky', $$sticky);\n      }\n\n      var deregister = $$sticky.add(element, stickyClone || element.clone());\n      scope.$on('$destroy', deregister);\n    }\n  };\n\n  function setupSticky(contentCtrl) {\n    var contentEl = contentCtrl.$element;\n\n    // Refresh elements is very expensive, so we use the debounced\n    // version when possible.\n    var debouncedRefreshElements = $$rAF.throttle(refreshElements);\n\n    // setupAugmentedScrollEvents gives us `$scrollstart` and `$scroll`,\n    // more reliable than `scroll` on android.\n    setupAugmentedScrollEvents(contentEl);\n    contentEl.on('$scrollstart', debouncedRefreshElements);\n    contentEl.on('$scroll', onScroll);\n\n    var self;\n    var stickyBaseoffset = contentEl.prop('offsetTop');\n    return self = {\n      prev: null,\n      current: null, //the currently stickied item\n      next: null,\n      items: [],\n      add: add,\n      refreshElements: refreshElements\n    };\n\n    /***************\n     * Public\n     ***************/\n    // Add an element and its sticky clone to this content's sticky collection\n    function add(element, stickyClone) {\n      stickyClone.addClass('md-sticky-clone');\n      stickyClone.css('top', stickyBaseoffset + 'px');\n\n      var item = {\n        element: element,\n        clone: stickyClone\n      };\n      self.items.push(item);\n\n      contentEl.parent().prepend(item.clone);\n\n      debouncedRefreshElements();\n\n      return function remove() {\n        self.items.forEach(function(item, index) {\n          if (item.element[0] === element[0]) {\n            self.items.splice(index, 1);\n            item.clone.remove();\n          }\n        });\n        debouncedRefreshElements();\n      };\n    }\n\n    function refreshElements() {\n      // Sort our collection of elements by their current position in the DOM.\n      // We need to do this because our elements' order of being added may not\n      // be the same as their order of display.\n      self.items.forEach(refreshPosition);\n      self.items = self.items.sort(function(a, b) {\n        return a.top < b.top ? -1 : 1;\n      });\n\n      // Find which item in the list should be active, \n      // based upon the content's current scroll position\n      var item;\n      var currentScrollTop = contentEl.prop('scrollTop');\n      for (var i = self.items.length - 1; i >= 0; i--) {\n        if (currentScrollTop > self.items[i].top) {\n          item = self.items[i];\n          break;\n        }\n      }\n      setCurrentItem(item);\n    }\n\n\n    /***************\n     * Private\n     ***************/\n\n    // Find the `top` of an item relative to the content element,\n    // and also the height.\n    function refreshPosition(item) {\n      // Find the top of an item by adding to the offsetHeight until we reach the \n      // content element.\n      var current = item.element[0];\n      item.top = 0;\n      item.left = 0;\n      while (current && current !== contentEl[0]) {\n        item.top += current.offsetTop;\n        item.left += current.offsetLeft;\n        current = current.offsetParent;\n      }\n      item.height = item.element.prop('offsetHeight');\n      item.clone.css('margin-left', item.left + 'px');\n    }\n\n\n    // As we scroll, push in and select the correct sticky element.\n    function onScroll() {\n      var scrollTop = contentEl.prop('scrollTop');\n      var isScrollingDown = scrollTop > (onScroll.prevScrollTop || 0);\n      onScroll.prevScrollTop = scrollTop;\n\n      // At the top?\n      if (scrollTop === 0) {\n        setCurrentItem(null);\n\n      // Going to next item?\n      } else if (isScrollingDown && self.next) {\n        if (self.next.top - scrollTop <= 0) {\n          // Sticky the next item if we've scrolled past its position.\n          setCurrentItem(self.next);\n        } else if (self.current) {\n          // Push the current item up when we're almost at the next item.\n          if (self.next.top - scrollTop <= self.next.height) {\n            translate(self.current, self.next.top - self.next.height - scrollTop);\n          } else {\n            translate(self.current, null);\n          }\n        }\n        \n      // Scrolling up with a current sticky item?\n      } else if (!isScrollingDown && self.current) {\n        if (scrollTop < self.current.top) {\n          // Sticky the previous item if we've scrolled up past\n          // the original position of the currently stickied item.\n          setCurrentItem(self.prev);\n        }\n        // Scrolling up, and just bumping into the item above (just set to current)?\n        // If we have a next item bumping into the current item, translate\n        // the current item up from the top as it scrolls into view.\n        if (self.current && self.next) {\n          if (scrollTop >= self.next.top - self.current.height) {\n            translate(self.current, self.next.top - scrollTop - self.current.height);\n          } else {\n            translate(self.current, null);\n          }\n        }\n      }\n    }\n     \n   function setCurrentItem(item) {\n     if (self.current === item) return;\n     // Deactivate currently active item\n     if (self.current) {\n       translate(self.current, null);\n       setStickyState(self.current, null);\n     }\n\n     // Activate new item if given\n     if (item) {\n       setStickyState(item, 'active');\n     }\n\n     self.current = item;\n     var index = self.items.indexOf(item);\n     // If index === -1, index + 1 = 0. It works out.\n     self.next = self.items[index + 1];\n     self.prev = self.items[index - 1];\n     setStickyState(self.next, 'next');\n     setStickyState(self.prev, 'prev');\n   }\n\n   function setStickyState(item, state) {\n     if (!item || item.state === state) return;\n     if (item.state) {\n       item.clone.attr('sticky-prev-state', item.state);\n       item.element.attr('sticky-prev-state', item.state);\n     }\n     item.clone.attr('sticky-state', state);\n     item.element.attr('sticky-state', state);\n     item.state = state;\n   }\n\n   function translate(item, amount) {\n     if (!item) return;\n     if (amount === null || amount === undefined) {\n       if (item.translateY) {\n         item.translateY = null;\n         item.clone.css($mdConstant.CSS.TRANSFORM, '');\n       }\n     } else {\n       item.translateY = amount;\n       item.clone.css(\n         $mdConstant.CSS.TRANSFORM, \n         'translate3d(' + item.left + 'px,' + amount + 'px,0)'\n       );\n     }\n   }\n  }\n\n  // Function to check for browser sticky support\n  function checkStickySupport($el) {\n    var stickyProp;\n    var testEl = angular.element('<div>');\n    $document[0].body.appendChild(testEl[0]);\n\n    var stickyProps = ['sticky', '-webkit-sticky'];\n    for (var i = 0; i < stickyProps.length; ++i) {\n      testEl.css({position: stickyProps[i], top: 0, 'z-index': 2});\n      if (testEl.css('position') == stickyProps[i]) {\n        stickyProp = stickyProps[i];\n        break;\n      }\n    }\n    testEl.remove();\n    return stickyProp;\n  }\n\n  // Android 4.4 don't accurately give scroll events.\n  // To fix this problem, we setup a fake scroll event. We say:\n  // > If a scroll or touchmove event has happened in the last DELAY milliseconds, \n  //   then send a `$scroll` event every animationFrame.\n  // Additionally, we add $scrollstart and $scrollend events.\n  function setupAugmentedScrollEvents(element) {\n    var SCROLL_END_DELAY = 200;\n    var isScrolling;\n    var lastScrollTime;\n    element.on('scroll touchmove', function() {\n      if (!isScrolling) {\n        isScrolling = true;\n        $$rAF(loopScrollEvent);\n        element.triggerHandler('$scrollstart');\n      }\n      element.triggerHandler('$scroll');\n      lastScrollTime = +$mdUtil.now();\n    });\n\n    function loopScrollEvent() {\n      if (+$mdUtil.now() - lastScrollTime > SCROLL_END_DELAY) {\n        isScrolling = false;\n        element.triggerHandler('$scrollend');\n      } else {\n        element.triggerHandler('$scroll');\n        $$rAF(loopScrollEvent);\n      }\n    }\n  }\n\n}\nMdSticky.$inject = [\"$document\", \"$mdConstant\", \"$compile\", \"$$rAF\", \"$mdUtil\"];\n\n})();\n(function(){\n\"use strict\";\n\n/**\n * @ngdoc module\n * @name material.components.subheader\n * @description\n * SubHeader module\n *\n *  Subheaders are special list tiles that delineate distinct sections of a\n *  list or grid list and are typically related to the current filtering or\n *  sorting criteria. Subheader tiles are either displayed inline with tiles or\n *  can be associated with content, for example, in an adjacent column.\n *\n *  Upon scrolling, subheaders remain pinned to the top of the screen and remain\n *  pinned until pushed on or off screen by the next subheader. @see [Material\n *  Design Specifications](https://www.google.com/design/spec/components/subheaders.html)\n *\n *  > To improve the visual grouping of content, use the system color for your subheaders.\n *\n */\nangular.module('material.components.subheader', [\n  'material.core',\n  'material.components.sticky'\n])\n  .directive('mdSubheader', MdSubheaderDirective);\n\n/**\n * @ngdoc directive\n * @name mdSubheader\n * @module material.components.subheader\n *\n * @restrict E\n *\n * @description\n * The `<md-subheader>` directive is a subheader for a section. By default it is sticky.\n * You can make it not sticky by applying the `md-no-sticky` class to the subheader.\n *\n *\n * @usage\n * <hljs lang=\"html\">\n * <md-subheader>Online Friends</md-subheader>\n * </hljs>\n */\n\nfunction MdSubheaderDirective($mdSticky, $compile, $mdTheming) {\n  return {\n    restrict: 'E',\n    replace: true,\n    transclude: true,\n    template: \n      '<h2 class=\"md-subheader\">' +\n        '<div class=\"md-subheader-inner\">' +\n          '<span class=\"md-subheader-content\"></span>' +\n        '</div>' +\n      '</h2>',\n    compile: function(element, attr, transclude) {\n      return function postLink(scope, element, attr) {\n        $mdTheming(element);\n        var outerHTML = element[0].outerHTML;\n\n        function getContent(el) {\n          return angular.element(el[0].querySelector('.md-subheader-content'));\n        }\n\n        // Transclude the user-given contents of the subheader\n        // the conventional way.\n        transclude(scope, function(clone) {\n          getContent(element).append(clone);\n        });\n\n        // Create another clone, that uses the outer and inner contents\n        // of the element, that will be 'stickied' as the user scrolls.\n        if (!element.hasClass('md-no-sticky')) {\n          transclude(scope, function(clone) {\n            var stickyClone = $compile(angular.element(outerHTML))(scope);\n            getContent(stickyClone).append(clone);\n            $mdSticky(scope, element, stickyClone);\n          });\n        }\n      };\n    }\n  };\n}\nMdSubheaderDirective.$inject = [\"$mdSticky\", \"$compile\", \"$mdTheming\"];\n\n})();\n(function(){\n\"use strict\";\n\n/**\n * @ngdoc module\n * @name material.components.swipe\n * @description Swipe module!\n */\n/**\n * @ngdoc directive\n * @module material.components.swipe\n * @name mdSwipeLeft\n *\n * @restrict A\n *\n * @description\n * The md-swipe-left directives allows you to specify custom behavior when an element is swiped\n * left.\n *\n * @usage\n * <hljs lang=\"html\">\n * <div md-swipe-left=\"onSwipeLeft()\">Swipe me left!</div>\n * </hljs>\n */\n/**\n * @ngdoc directive\n * @module material.components.swipe\n * @name mdSwipeRight\n *\n * @restrict A\n *\n * @description\n * The md-swipe-right directives allows you to specify custom behavior when an element is swiped\n * right.\n *\n * @usage\n * <hljs lang=\"html\">\n * <div md-swipe-right=\"onSwipeRight()\">Swipe me right!</div>\n * </hljs>\n */\n\nangular.module('material.components.swipe', ['material.core'])\n    .directive('mdSwipeLeft', getDirective('SwipeLeft'))\n    .directive('mdSwipeRight', getDirective('SwipeRight'));\n\nfunction getDirective(name) {\n  var directiveName = 'md' + name;\n  var eventName = '$md.' + name.toLowerCase();\n\n    DirectiveFactory.$inject = [\"$parse\"];\n  return DirectiveFactory;\n\n  /* @ngInject */\n  function DirectiveFactory($parse) {\n      return { restrict: 'A', link: postLink };\n      function postLink(scope, element, attr) {\n        var fn = $parse(attr[directiveName]);\n        element.on(eventName, function(ev) {\n          scope.$apply(function() { fn(scope, { $event: ev }); });\n        });\n      }\n    }\n}\n\n\n\n})();\n(function(){\n\"use strict\";\n\n/**\n * @private\n * @ngdoc module\n * @name material.components.switch\n */\n\nangular.module('material.components.switch', [\n  'material.core',\n  'material.components.checkbox'\n])\n  .directive('mdSwitch', MdSwitch);\n\n/**\n * @private\n * @ngdoc directive\n * @module material.components.switch\n * @name mdSwitch\n * @restrict E\n *\n * The switch directive is used very much like the normal [angular checkbox](https://docs.angularjs.org/api/ng/input/input%5Bcheckbox%5D).\n *\n * As per the [material design spec](http://www.google.com/design/spec/style/color.html#color-ui-color-application)\n * the switch is in the accent color by default. The primary color palette may be used with\n * the `md-primary` class.\n *\n * @param {string} ng-model Assignable angular expression to data-bind to.\n * @param {string=} name Property name of the form under which the control is published.\n * @param {expression=} ng-true-value The value to which the expression should be set when selected.\n * @param {expression=} ng-false-value The value to which the expression should be set when not selected.\n * @param {string=} ng-change Angular expression to be executed when input changes due to user interaction with the input element.\n * @param {boolean=} md-no-ink Use of attribute indicates use of ripple ink effects.\n * @param {string=} aria-label Publish the button label used by screen-readers for accessibility. Defaults to the switch's text.\n *\n * @usage\n * <hljs lang=\"html\">\n * <md-switch ng-model=\"isActive\" aria-label=\"Finished?\">\n *   Finished ?\n * </md-switch>\n *\n * <md-switch md-no-ink ng-model=\"hasInk\" aria-label=\"No Ink Effects\">\n *   No Ink Effects\n * </md-switch>\n *\n * <md-switch ng-disabled=\"true\" ng-model=\"isDisabled\" aria-label=\"Disabled\">\n *   Disabled\n * </md-switch>\n *\n * </hljs>\n */\nfunction MdSwitch(mdCheckboxDirective, $mdTheming, $mdUtil, $document, $mdConstant, $parse, $$rAF, $mdGesture) {\n  var checkboxDirective = mdCheckboxDirective[0];\n\n  return {\n    restrict: 'E',\n    priority:210, // Run before ngAria\n    transclude: true,\n    template:\n      '<div class=\"md-container\">' +\n        '<div class=\"md-bar\"></div>' +\n        '<div class=\"md-thumb-container\">' +\n          '<div class=\"md-thumb\" md-ink-ripple md-ink-ripple-checkbox></div>' +\n        '</div>'+\n      '</div>' +\n      '<div ng-transclude class=\"md-label\">' +\n      '</div>',\n    require: '?ngModel',\n    compile: compile\n  };\n\n  function compile(element, attr) {\n    var checkboxLink = checkboxDirective.compile(element, attr);\n    // no transition on initial load\n    element.addClass('md-dragging');\n\n    return function (scope, element, attr, ngModel) {\n      ngModel = ngModel || $mdUtil.fakeNgModel();\n      var disabledGetter = $parse(attr.ngDisabled);\n      var thumbContainer = angular.element(element[0].querySelector('.md-thumb-container'));\n      var switchContainer = angular.element(element[0].querySelector('.md-container'));\n\n      // no transition on initial load\n      $$rAF(function() {\n        element.removeClass('md-dragging');\n      });\n\n      checkboxLink(scope, element, attr, ngModel);\n\n      if (angular.isDefined(attr.ngDisabled)) {\n        scope.$watch(disabledGetter, function(isDisabled) {\n          element.attr('tabindex', isDisabled ? -1 : 0);\n        });\n      }\n\n      // These events are triggered by setup drag\n      $mdGesture.register(switchContainer, 'drag');\n      switchContainer\n        .on('$md.dragstart', onDragStart)\n        .on('$md.drag', onDrag)\n        .on('$md.dragend', onDragEnd);\n\n      var drag;\n      function onDragStart(ev) {\n        // Don't go if ng-disabled===true\n        if (disabledGetter(scope)) return;\n        ev.stopPropagation();\n\n        element.addClass('md-dragging');\n        drag = {\n          width: thumbContainer.prop('offsetWidth')\n        };\n        element.removeClass('transition');\n      }\n\n      function onDrag(ev) {\n        if (!drag) return;\n        ev.stopPropagation();\n        ev.srcEvent && ev.srcEvent.preventDefault();\n\n        var percent = ev.pointer.distanceX / drag.width;\n\n        //if checked, start from right. else, start from left\n        var translate = ngModel.$viewValue ?  1 + percent : percent;\n        // Make sure the switch stays inside its bounds, 0-1%\n        translate = Math.max(0, Math.min(1, translate));\n\n        thumbContainer.css($mdConstant.CSS.TRANSFORM, 'translate3d(' + (100*translate) + '%,0,0)');\n        drag.translate = translate;\n      }\n\n      function onDragEnd(ev) {\n        if (!drag) return;\n        ev.stopPropagation();\n\n        element.removeClass('md-dragging');\n        thumbContainer.css($mdConstant.CSS.TRANSFORM, '');\n\n        // We changed if there is no distance (this is a click a click),\n        // or if the drag distance is >50% of the total.\n        var isChanged = ngModel.$viewValue ? drag.translate < 0.5 : drag.translate > 0.5;\n        if (isChanged) {\n          applyModelValue(!ngModel.$viewValue);\n        }\n        drag = null;\n      }\n\n      function applyModelValue(newValue) {\n        scope.$apply(function() {\n          ngModel.$setViewValue(newValue);\n          ngModel.$render();\n        });\n      }\n\n    };\n  }\n\n\n}\nMdSwitch.$inject = [\"mdCheckboxDirective\", \"$mdTheming\", \"$mdUtil\", \"$document\", \"$mdConstant\", \"$parse\", \"$$rAF\", \"$mdGesture\"];\n\n})();\n(function(){\n\"use strict\";\n\n/**\n * @ngdoc module\n * @name material.components.toast\n * @description\n * Toast\n */\nangular.module('material.components.toast', [\n  'material.core',\n  'material.components.button'\n])\n  .directive('mdToast', MdToastDirective)\n  .provider('$mdToast', MdToastProvider);\n\nfunction MdToastDirective() {\n  return {\n    restrict: 'E'\n  };\n}\n\n/**\n * @ngdoc service\n * @name $mdToast\n * @module material.components.toast\n *\n * @description\n * `$mdToast` is a service to build a toast notification on any position\n * on the screen with an optional duration, and provides a simple promise API.\n *\n *\n * ## Restrictions on custom toasts\n * - The toast's template must have an outer `<md-toast>` element.\n * - For a toast action, use element with class `md-action`.\n * - Add the class `md-capsule` for curved corners.\n *\n * @usage\n * <hljs lang=\"html\">\n * <div ng-controller=\"MyController\">\n *   <md-button ng-click=\"openToast()\">\n *     Open a Toast!\n *   </md-button>\n * </div>\n * </hljs>\n *\n * <hljs lang=\"js\">\n * var app = angular.module('app', ['ngMaterial']);\n * app.controller('MyController', function($scope, $mdToast) {\n *   $scope.openToast = function($event) {\n *     $mdToast.show($mdToast.simple().content('Hello!'));\n *     // Could also do $mdToast.showSimple('Hello');\n *   };\n * });\n * </hljs>\n */\n\n/**\n * @ngdoc method\n * @name $mdToast#showSimple\n * \n * @description\n * Convenience method which builds and shows a simple toast.\n *\n * @returns {promise} A promise that can be resolved with `$mdToast.hide()` or\n * rejected with `$mdToast.cancel()`.\n *\n */\n\n /**\n * @ngdoc method\n * @name $mdToast#simple\n *\n * @description\n * Builds a preconfigured toast.\n *\n * @returns {obj} a `$mdToastPreset` with the chainable configuration methods:\n *\n * - $mdToastPreset#content(string) - sets toast content to string\n * - $mdToastPreset#action(string) - adds an action button, which resolves the promise returned from `show()` if clicked.\n * - $mdToastPreset#highlightAction(boolean) - sets action button to be highlighted\n * - $mdToastPreset#capsule(boolean) - adds 'md-capsule' class to the toast (curved corners)\n * - $mdToastPreset#theme(boolean) - sets the theme on the toast to theme (default is `$mdThemingProvider`'s default theme)\n */\n\n/**\n * @ngdoc method\n * @name $mdToast#updateContent\n * \n * @description\n * Updates the content of an existing toast. Useful for updating things like counts, etc.\n *\n */\n\n /**\n * @ngdoc method\n * @name $mdToast#build\n *\n * @description\n * Creates a custom `$mdToastPreset` that you can configure.\n *\n * @returns {obj} a `$mdToastPreset` with the chainable configuration methods for shows' options (see below).\n */\n\n /**\n * @ngdoc method\n * @name $mdToast#show\n *\n * @description Shows the toast.\n *\n * @param {object} optionsOrPreset Either provide an `$mdToastPreset` returned from `simple()`\n * and `build()`, or an options object with the following properties:\n *\n *   - `templateUrl` - `{string=}`: The url of an html template file that will\n *     be used as the content of the toast. Restrictions: the template must\n *     have an outer `md-toast` element.\n *   - `template` - `{string=}`: Same as templateUrl, except this is an actual\n *     template string.\n *   - `scope` - `{object=}`: the scope to link the template / controller to. If none is specified, it will create a new child scope.\n *     This scope will be destroyed when the toast is removed unless `preserveScope` is set to true.\n *   - `preserveScope` - `{boolean=}`: whether to preserve the scope when the element is removed. Default is false\n *   - `hideDelay` - `{number=}`: How many milliseconds the toast should stay\n *     active before automatically closing.  Set to 0 or false to have the toast stay open until\n *     closed manually. Default: 3000.\n *   - `position` - `{string=}`: Where to place the toast. Available: any combination\n *     of 'bottom', 'left', 'top', 'right', 'fit'. Default: 'bottom left'.\n *   - `controller` - `{string=}`: The controller to associate with this toast.\n *     The controller will be injected the local `$hideToast`, which is a function\n *     used to hide the toast.\n *   - `locals` - `{string=}`: An object containing key/value pairs. The keys will\n *     be used as names of values to inject into the controller. For example,\n *     `locals: {three: 3}` would inject `three` into the controller with the value\n *     of 3.\n *   - `bindToController` - `bool`: bind the locals to the controller, instead of passing them in. These values will not be available until after initialization.\n *   - `resolve` - `{object=}`: Similar to locals, except it takes promises as values\n *     and the toast will not open until the promises resolve.\n *   - `controllerAs` - `{string=}`: An alias to assign the controller to on the scope.\n *   - `parent` - `{element=}`: The element to append the toast to. Defaults to appending\n *     to the root element of the application.\n *\n * @returns {promise} A promise that can be resolved with `$mdToast.hide()` or\n * rejected with `$mdToast.cancel()`.\n */\n\n/**\n * @ngdoc method\n * @name $mdToast#hide\n *\n * @description\n * Hide an existing toast and resolve the promise returned from `$mdToast.show()`.\n *\n * @param {*=} response An argument for the resolved promise.\n *\n * @returns {promise} a promise that is called when the existing element is removed from the DOM\n *\n */\n\n/**\n * @ngdoc method\n * @name $mdToast#cancel\n *\n * @description\n * Hide the existing toast and reject the promise returned from\n * `$mdToast.show()`.\n *\n * @param {*=} response An argument for the rejected promise.\n *\n * @returns {promise} a promise that is called when the existing element is removed from the DOM\n *\n */\n\nfunction MdToastProvider($$interimElementProvider) {\n  var activeToastContent;\n  var $mdToast = $$interimElementProvider('$mdToast')\n    .setDefaults({\n      methods: ['position', 'hideDelay', 'capsule' ],\n      options: toastDefaultOptions\n    })\n    .addPreset('simple', {\n      argOption: 'content',\n      methods: ['content', 'action', 'highlightAction', 'theme', 'parent'],\n      options: /* @ngInject */ [\"$mdToast\", \"$mdTheming\", function($mdToast, $mdTheming) {\n        var opts = {\n          template: [\n            '<md-toast md-theme=\"{{ toast.theme }}\" ng-class=\"{\\'md-capsule\\': toast.capsule}\">',\n              '<span flex>{{ toast.content }}</span>',\n              '<md-button class=\"md-action\" ng-if=\"toast.action\" ng-click=\"toast.resolve()\" ng-class=\"{\\'md-highlight\\': toast.highlightAction}\">',\n                '{{ toast.action }}',\n              '</md-button>',\n            '</md-toast>'\n          ].join(''),\n          controller: /* @ngInject */ [\"$scope\", function mdToastCtrl($scope) {\n            var self = this;\n            $scope.$watch(function() { return activeToastContent; }, function() {\n              self.content = activeToastContent;\n            });\n            this.resolve = function() {\n              $mdToast.hide();\n            };\n          }],\n          theme: $mdTheming.defaultTheme(),\n          controllerAs: 'toast',\n          bindToController: true\n        };\n        return opts;\n      }]\n    })\n    .addMethod('updateContent', function(newContent) {\n      activeToastContent = newContent;\n    });\n\n  toastDefaultOptions.$inject = [\"$timeout\", \"$animate\", \"$mdToast\", \"$mdUtil\"];\n    return $mdToast;\n\n  /* @ngInject */\n  function toastDefaultOptions($timeout, $animate, $mdToast, $mdUtil) {\n    return {\n      onShow: onShow,\n      onRemove: onRemove,\n      position: 'bottom left',\n      themable: true,\n      hideDelay: 3000\n    };\n\n    function onShow(scope, element, options) {\n      element = $mdUtil.extractElementByName(element, 'md-toast');\n\n      // 'top left' -> 'md-top md-left'\n      activeToastContent = options.content;\n      element.addClass(options.position.split(' ').map(function(pos) {\n        return 'md-' + pos;\n      }).join(' '));\n      options.parent.addClass(toastOpenClass(options.position));\n\n      options.onSwipe = function(ev, gesture) {\n        //Add swipeleft/swiperight class to element so it can animate correctly\n        element.addClass('md-' + ev.type.replace('$md.',''));\n        $timeout($mdToast.cancel);\n      };\n      element.on('$md.swipeleft $md.swiperight', options.onSwipe);\n      return $animate.enter(element, options.parent);\n    }\n\n    function onRemove(scope, element, options) {\n      element.off('$md.swipeleft $md.swiperight', options.onSwipe);\n      options.parent.removeClass(toastOpenClass(options.position));\n      return $animate.leave(element);\n    }\n\n    function toastOpenClass(position) {\n      return 'md-toast-open-' +\n        (position.indexOf('top') > -1 ? 'top' : 'bottom');\n    }\n  }\n\n}\nMdToastProvider.$inject = [\"$$interimElementProvider\"];\n\n})();\n(function(){\n\"use strict\";\n\n/**\n * @ngdoc module\n * @name material.components.tabs\n * @description\n *\n *  Tabs, created with the `<md-tabs>` directive provide *tabbed* navigation with different styles.\n *  The Tabs component consists of clickable tabs that are aligned horizontally side-by-side.\n *\n *  Features include support for:\n *\n *  - static or dynamic tabs,\n *  - responsive designs,\n *  - accessibility support (ARIA),\n *  - tab pagination,\n *  - external or internal tab content,\n *  - focus indicators and arrow-key navigations,\n *  - programmatic lookup and access to tab controllers, and\n *  - dynamic transitions through different tab contents.\n *\n */\n/*\n * @see js folder for tabs implementation\n */\nangular.module('material.components.tabs', [\n  'material.core',\n  'material.components.icon'\n]);\n\n})();\n(function(){\n\"use strict\";\n\n/**\n * @ngdoc module\n * @name material.components.toolbar\n */\nangular.module('material.components.toolbar', [\n  'material.core',\n  'material.components.content'\n])\n  .directive('mdToolbar', mdToolbarDirective);\n\n/**\n * @ngdoc directive\n * @name mdToolbar\n * @module material.components.toolbar\n * @restrict E\n * @description\n * `md-toolbar` is used to place a toolbar in your app.\n *\n * Toolbars are usually used above a content area to display the title of the\n * current page, and show relevant action buttons for that page.\n *\n * You can change the height of the toolbar by adding either the\n * `md-medium-tall` or `md-tall` class to the toolbar.\n *\n * @usage\n * <hljs lang=\"html\">\n * <div layout=\"column\" layout-fill>\n *   <md-toolbar>\n *\n *     <div class=\"md-toolbar-tools\">\n *       <span>My App's Title</span>\n *\n *       <!-- fill up the space between left and right area -->\n *       <span flex></span>\n *\n *       <md-button>\n *         Right Bar Button\n *       </md-button>\n *     </div>\n *\n *   </md-toolbar>\n *   <md-content>\n *     Hello!\n *   </md-content>\n * </div>\n * </hljs>\n *\n * @param {boolean=} md-scroll-shrink Whether the header should shrink away as\n * the user scrolls down, and reveal itself as the user scrolls up.\n * Note: for scrollShrink to work, the toolbar must be a sibling of a\n * `md-content` element, placed before it. See the scroll shrink demo.\n *\n *\n * @param {number=} md-shrink-speed-factor How much to change the speed of the toolbar's\n * shrinking by. For example, if 0.25 is given then the toolbar will shrink\n * at one fourth the rate at which the user scrolls down. Default 0.5.\n */\nfunction mdToolbarDirective($$rAF, $mdConstant, $mdUtil, $mdTheming, $animate, $timeout) {\n\n  return {\n    restrict: 'E',\n    controller: angular.noop,\n    link: function(scope, element, attr) {\n      $mdTheming(element);\n\n      if (angular.isDefined(attr.mdScrollShrink)) {\n        setupScrollShrink();\n      }\n\n      function setupScrollShrink() {\n        // Current \"y\" position of scroll\n        var y = 0;\n        // Store the last scroll top position\n        var prevScrollTop = 0;\n\n        var shrinkSpeedFactor = attr.mdShrinkSpeedFactor || 0.5;\n\n        var toolbarHeight;\n        var contentElement;\n\n        var debouncedContentScroll = $$rAF.throttle(onContentScroll);\n        var debouncedUpdateHeight = $mdUtil.debounce(updateToolbarHeight, 5 * 1000);\n\n        // Wait for $mdContentLoaded event from mdContent directive.\n        // If the mdContent element is a sibling of our toolbar, hook it up\n        // to scroll events.\n        scope.$on('$mdContentLoaded', onMdContentLoad);\n\n        function onMdContentLoad($event, newContentEl) {\n          // Toolbar and content must be siblings\n          if (element.parent()[0] === newContentEl.parent()[0]) {\n            // unhook old content event listener if exists\n            if (contentElement) {\n              contentElement.off('scroll', debouncedContentScroll);\n            }\n\n            newContentEl.on('scroll', debouncedContentScroll);\n            newContentEl.attr('scroll-shrink', 'true');\n\n            contentElement = newContentEl;\n            $$rAF(updateToolbarHeight);\n          }\n        }\n\n        function updateToolbarHeight() {\n          toolbarHeight = element.prop('offsetHeight');\n          // Add a negative margin-top the size of the toolbar to the content el.\n          // The content will start transformed down the toolbarHeight amount,\n          // so everything looks normal.\n          //\n          // As the user scrolls down, the content will be transformed up slowly\n          // to put the content underneath where the toolbar was.\n          var margin =  (-toolbarHeight * shrinkSpeedFactor) + 'px';\n          contentElement.css('margin-top', margin);\n          contentElement.css('margin-bottom', margin);\n\n          onContentScroll();\n        }\n\n        function onContentScroll(e) {\n          var scrollTop = e ? e.target.scrollTop : prevScrollTop;\n\n          debouncedUpdateHeight();\n\n          y = Math.min(\n            toolbarHeight / shrinkSpeedFactor,\n            Math.max(0, y + scrollTop - prevScrollTop)\n          );\n\n          element.css(\n            $mdConstant.CSS.TRANSFORM,\n            'translate3d(0,' + (-y * shrinkSpeedFactor) + 'px,0)'\n          );\n          contentElement.css(\n            $mdConstant.CSS.TRANSFORM,\n            'translate3d(0,' + ((toolbarHeight - y) * shrinkSpeedFactor) + 'px,0)'\n          );\n\n          prevScrollTop = scrollTop;\n\n            if (element.hasClass('md-whiteframe-z1')) {\n              if (!y) {\n                $timeout(function () { $animate.removeClass(element, 'md-whiteframe-z1'); });\n              }\n            } else {\n              if (y) {\n                $timeout(function () { $animate.addClass(element, 'md-whiteframe-z1'); });\n              }\n            }\n        }\n\n      }\n\n    }\n  };\n\n}\nmdToolbarDirective.$inject = [\"$$rAF\", \"$mdConstant\", \"$mdUtil\", \"$mdTheming\", \"$animate\", \"$timeout\"];\n\n})();\n(function(){\n\"use strict\";\n\n/**\n * @ngdoc module\n * @name material.components.tooltip\n */\nangular\n    .module('material.components.tooltip', [ 'material.core' ])\n    .directive('mdTooltip', MdTooltipDirective);\n\n/**\n * @ngdoc directive\n * @name mdTooltip\n * @module material.components.tooltip\n * @description\n * Tooltips are used to describe elements that are interactive and primarily graphical (not textual).\n *\n * Place a `<md-tooltip>` as a child of the element it describes.\n *\n * A tooltip will activate when the user focuses, hovers over, or touches the parent.\n *\n * @usage\n * <hljs lang=\"html\">\n * <md-button class=\"md-fab md-accent\" aria-label=\"Play\">\n *   <md-tooltip>\n *     Play Music\n *   </md-tooltip>\n *   <md-icon icon=\"img/icons/ic_play_arrow_24px.svg\"></md-icon>\n * </md-button>\n * </hljs>\n *\n * @param {expression=} md-visible Boolean bound to whether the tooltip is\n * currently visible.\n * @param {number=} md-delay How many milliseconds to wait to show the tooltip after the user focuses, hovers, or touches the parent. Defaults to 400ms.\n * @param {string=} md-direction Which direction would you like the tooltip to go?  Supports left, right, top, and bottom.  Defaults to bottom.\n * @param {boolean=} md-autohide If present or provided with a boolean value, the tooltip will hide on mouse leave, regardless of focus\n */\nfunction MdTooltipDirective($timeout, $window, $$rAF, $document, $mdUtil, $mdTheming, $rootElement, $animate, $q) {\n\n  var TOOLTIP_SHOW_DELAY = 300;\n  var TOOLTIP_WINDOW_EDGE_SPACE = 8;\n\n  return {\n    restrict: 'E',\n    transclude: true,\n    priority:210, // Before ngAria\n    template: '\\\n        <div class=\"md-background\"></div>\\\n        <div class=\"md-content\" ng-transclude></div>',\n    scope: {\n      visible: '=?mdVisible',\n      delay: '=?mdDelay',\n      autohide: '=?mdAutohide'\n    },\n    link: postLink\n  };\n\n  function postLink(scope, element, attr) {\n\n    $mdTheming(element);\n\n    var parent        = getParentWithPointerEvents(),\n        background    = angular.element(element[0].getElementsByClassName('md-background')[0]),\n        content       = angular.element(element[0].getElementsByClassName('md-content')[0]),\n        direction     = attr.mdDirection,\n        current       = getNearestContentElement(),\n        tooltipParent = angular.element(current || document.body),\n        debouncedOnResize = $$rAF.throttle(function () { if (scope.visible) positionTooltip(); });\n\n    return init();\n\n    function init () {\n      setDefaults();\n      manipulateElement();\n      bindEvents();\n      configureWatchers();\n      addAriaLabel();\n    }\n\n    function setDefaults () {\n      if (!angular.isDefined(attr.mdDelay)) scope.delay = TOOLTIP_SHOW_DELAY;\n    }\n\n    function configureWatchers () {\n      scope.$on('$destroy', function() {\n        scope.visible = false;\n        element.remove();\n        angular.element($window).off('resize', debouncedOnResize);\n      });\n      scope.$watch('visible', function (isVisible) {\n        if (isVisible) showTooltip();\n        else hideTooltip();\n      });\n    }\n\n    function addAriaLabel () {\n      if (!parent.attr('aria-label') && !parent.text().trim()) {\n        parent.attr('aria-label', element.text().trim());\n      }\n    }\n\n    function manipulateElement () {\n      element.detach();\n      element.attr('role', 'tooltip');\n    }\n\n    function getParentWithPointerEvents () {\n      var parent = element.parent();\n      while (parent && $window.getComputedStyle(parent[0])['pointer-events'] == 'none') {\n        parent = parent.parent();\n      }\n      return parent;\n    }\n\n    function getNearestContentElement () {\n      var current = element.parent()[0];\n      // Look for the nearest parent md-content, stopping at the rootElement.\n      while (current && current !== $rootElement[0] && current !== document.body) {\n        if (current.tagName && current.tagName.toLowerCase() == 'md-content') break;\n        current = current.parentNode;\n      }\n      return current;\n    }\n\n    function hasComputedStyleValue(key, value) {\n        // Check if we should show it or not...\n        var computedStyles = $window.getComputedStyle(element[0]);\n        return angular.isDefined(computedStyles[key]) && (computedStyles[key] == value);\n    }\n\n    function bindEvents () {\n      var mouseActive = false;\n      var enterHandler = function() {\n        if (!hasComputedStyleValue('pointer-events','none')) {\n          setVisible(true);\n        }\n      };\n      var leaveHandler = function () {\n        var autohide = scope.hasOwnProperty('autohide') ? scope.autohide : attr.hasOwnProperty('mdAutohide');\n        if (autohide || mouseActive || ($document[0].activeElement !== parent[0]) ) {\n          setVisible(false);\n        }\n        mouseActive = false;\n      };\n\n      // to avoid `synthetic clicks` we listen to mousedown instead of `click`\n      parent.on('mousedown', function() { mouseActive = true; });\n      parent.on('focus mouseenter touchstart', enterHandler );\n      parent.on('blur mouseleave touchend touchcancel', leaveHandler );\n\n\n      angular.element($window).on('resize', debouncedOnResize);\n    }\n\n    function setVisible (value) {\n      setVisible.value = !!value;\n      if (!setVisible.queued) {\n        if (value) {\n          setVisible.queued = true;\n          $timeout(function() {\n            scope.visible = setVisible.value;\n            setVisible.queued = false;\n          }, scope.delay);\n        } else {\n          $timeout(function() { scope.visible = false; });\n        }\n      }\n    }\n\n    function showTooltip() {\n      // Insert the element before positioning it, so we can get the position\n      // and check if we should display it\n      tooltipParent.append(element);\n\n      // Check if we should display it or not.\n      // This handles hide-* and show-* along with any user defined css\n      if ( hasComputedStyleValue('display','none') ) {\n        scope.visible = false;\n        element.detach();\n        return;\n      }\n\n      positionTooltip();\n      angular.forEach([element, background, content], function (element) {\n        $animate.addClass(element, 'md-show');\n      });\n    }\n\n    function hideTooltip() {\n      $q.all([\n        $animate.removeClass(content, 'md-show'),\n        $animate.removeClass(background, 'md-show'),\n        $animate.removeClass(element, 'md-show')\n      ]).then(function () {\n        if (!scope.visible) element.detach();\n      });\n    }\n\n    function positionTooltip() {\n      var tipRect = $mdUtil.offsetRect(element, tooltipParent);\n      var parentRect = $mdUtil.offsetRect(parent, tooltipParent);\n      var newPosition = getPosition(direction);\n\n      // If the user provided a direction, just nudge the tooltip onto the screen\n      // Otherwise, recalculate based on 'top' since default is 'bottom'\n      if (direction) {\n        newPosition = fitInParent(newPosition);\n      } else if (newPosition.top > element.prop('offsetParent').scrollHeight - tipRect.height - TOOLTIP_WINDOW_EDGE_SPACE) {\n        newPosition = fitInParent(getPosition('top'));\n      }\n\n      element.css({top: newPosition.top + 'px', left: newPosition.left + 'px'});\n\n      positionBackground();\n\n      function positionBackground () {\n        var size = direction === 'left' || direction === 'right'\n              ? Math.sqrt(Math.pow(tipRect.width, 2) + Math.pow(tipRect.height / 2, 2)) * 2\n              : Math.sqrt(Math.pow(tipRect.width / 2, 2) + Math.pow(tipRect.height, 2)) * 2,\n            position = direction === 'left' ? { left: 100, top: 50 }\n              : direction === 'right' ? { left: 0, top: 50 }\n              : direction === 'top' ? { left: 50, top: 100 }\n              : { left: 50, top: 0 };\n        background.css({\n          width: size + 'px',\n          height: size + 'px',\n          left: position.left + '%',\n          top: position.top + '%'\n        });\n      }\n\n      function fitInParent (pos) {\n        var newPosition = { left: pos.left, top: pos.top };\n        newPosition.left = Math.min( newPosition.left, tooltipParent.prop('scrollWidth') - tipRect.width - TOOLTIP_WINDOW_EDGE_SPACE );\n        newPosition.left = Math.max( newPosition.left, TOOLTIP_WINDOW_EDGE_SPACE );\n        newPosition.top  = Math.min( newPosition.top,  tooltipParent.prop('scrollHeight') - tipRect.height - TOOLTIP_WINDOW_EDGE_SPACE );\n        newPosition.top  = Math.max( newPosition.top,  TOOLTIP_WINDOW_EDGE_SPACE );\n        return newPosition;\n      }\n\n      function getPosition (dir) {\n        return dir === 'left'\n          ? { left: parentRect.left - tipRect.width - TOOLTIP_WINDOW_EDGE_SPACE,\n              top: parentRect.top + parentRect.height / 2 - tipRect.height / 2 }\n          : dir === 'right'\n          ? { left: parentRect.left + parentRect.width + TOOLTIP_WINDOW_EDGE_SPACE,\n              top: parentRect.top + parentRect.height / 2 - tipRect.height / 2 }\n          : dir === 'top'\n          ? { left: parentRect.left + parentRect.width / 2 - tipRect.width / 2,\n              top: parentRect.top - tipRect.height - TOOLTIP_WINDOW_EDGE_SPACE }\n          : { left: parentRect.left + parentRect.width / 2 - tipRect.width / 2,\n              top: parentRect.top + parentRect.height + TOOLTIP_WINDOW_EDGE_SPACE };\n      }\n    }\n\n  }\n\n}\nMdTooltipDirective.$inject = [\"$timeout\", \"$window\", \"$$rAF\", \"$document\", \"$mdUtil\", \"$mdTheming\", \"$rootElement\", \"$animate\", \"$q\"];\n\n})();\n(function(){\n\"use strict\";\n\n/**\n * @ngdoc module\n * @name material.components.whiteframe\n */\nangular.module('material.components.whiteframe', []);\n\n})();\n(function(){\n\"use strict\";\n\nangular\n    .module('material.components.autocomplete')\n    .controller('MdAutocompleteCtrl', MdAutocompleteCtrl);\n\nvar ITEM_HEIGHT = 41,\n    MAX_HEIGHT = 5.5 * ITEM_HEIGHT,\n    MENU_PADDING = 8;\n\nfunction MdAutocompleteCtrl ($scope, $element, $mdUtil, $mdConstant, $timeout, $mdTheming, $window, $animate, $rootElement) {\n\n  //-- private variables\n\n  var self      = this,\n      itemParts = $scope.itemsExpr.split(/ in /i),\n      itemExpr  = itemParts[1],\n      elements  = null,\n      promise   = null,\n      cache     = {},\n      noBlur    = false,\n      selectedItemWatchers = [],\n      hasFocus  = false;\n\n  //-- public variables\n\n  self.scope    = $scope;\n  self.parent   = $scope.$parent;\n  self.itemName = itemParts[0];\n  self.matches  = [];\n  self.loading  = false;\n  self.hidden   = true;\n  self.index    = null;\n  self.messages = [];\n  self.id       = $mdUtil.nextUid();\n\n  //-- public methods\n\n  self.keydown  = keydown;\n  self.blur     = blur;\n  self.focus    = focus;\n  self.clear    = clearValue;\n  self.select   = select;\n  self.getCurrentDisplayValue         = getCurrentDisplayValue;\n  self.registerSelectedItemWatcher    = registerSelectedItemWatcher;\n  self.unregisterSelectedItemWatcher  = unregisterSelectedItemWatcher;\n\n  self.listEnter = function () { noBlur = true; };\n  self.listLeave = function () {\n    noBlur = false;\n    if (!hasFocus) self.hidden = true;\n  };\n  self.mouseUp   = function () { elements.input.focus(); };\n\n  return init();\n\n  //-- initialization methods\n\n  function init () {\n    configureWatchers();\n    $timeout(function () {\n      gatherElements();\n      focusElement();\n      moveDropdown();\n    });\n  }\n\n  function positionDropdown () {\n    if (!elements) return $timeout(positionDropdown, 0, false);\n    var hrect  = elements.wrap.getBoundingClientRect(),\n        vrect  = elements.snap.getBoundingClientRect(),\n        root   = elements.root.getBoundingClientRect(),\n        top    = vrect.bottom - root.top,\n        bot    = root.bottom - vrect.top,\n        left   = hrect.left - root.left,\n        width  = hrect.width,\n        styles = {\n          left:     left + 'px',\n          minWidth: width + 'px',\n          maxWidth: Math.max(hrect.right - root.left, root.right - hrect.left) - MENU_PADDING + 'px'\n        };\n    if (top > bot && root.height - hrect.bottom - MENU_PADDING < MAX_HEIGHT) {\n      styles.top = 'auto';\n      styles.bottom = bot + 'px';\n      styles.maxHeight = Math.min(MAX_HEIGHT, hrect.top - root.top - MENU_PADDING) + 'px';\n    } else {\n      styles.top = top + 'px';\n      styles.bottom = 'auto';\n      styles.maxHeight = Math.min(MAX_HEIGHT, root.bottom - hrect.bottom - MENU_PADDING) + 'px';\n    }\n    elements.$.ul.css(styles);\n    $timeout(correctHorizontalAlignment, 0, false);\n\n    function correctHorizontalAlignment () {\n      var dropdown = elements.ul.getBoundingClientRect(),\n          styles   = {};\n      if (dropdown.right > root.right - MENU_PADDING) {\n        styles.left = (hrect.right - dropdown.width) + 'px';\n      }\n      elements.$.ul.css(styles);\n    }\n  }\n\n  function moveDropdown () {\n    if (!elements.$.root.length) return;\n    $mdTheming(elements.$.ul);\n    elements.$.ul.detach();\n    elements.$.root.append(elements.$.ul);\n    if ($animate.pin) $animate.pin(elements.$.ul, $rootElement);\n  }\n\n  function focusElement () {\n    if ($scope.autofocus) elements.input.focus();\n  }\n\n  function configureWatchers () {\n    var wait = parseInt($scope.delay, 10) || 0;\n    $scope.$watch('searchText', wait\n        ? $mdUtil.debounce(handleSearchText, wait)\n        : handleSearchText);\n    registerSelectedItemWatcher(selectedItemChange);\n    $scope.$watch('selectedItem', handleSelectedItemChange);\n    $scope.$watch('$mdAutocompleteCtrl.hidden', function (hidden, oldHidden) {\n      if (!hidden && oldHidden) positionDropdown();\n    });\n    angular.element($window).on('resize', positionDropdown);\n  }\n\n  function gatherElements () {\n    elements = {\n      main:  $element[0],\n      ul:    $element.find('ul')[0],\n      input: $element.find('input')[0],\n      wrap:  $element.find('md-autocomplete-wrap')[0],\n      root:  document.body\n    };\n    elements.li = elements.ul.getElementsByTagName('li');\n    elements.snap = getSnapTarget();\n    elements.$ = getAngularElements(elements);\n  }\n\n  function getSnapTarget () {\n    for (var element = $element; element.length; element = element.parent()) {\n      if (angular.isDefined(element.attr('md-autocomplete-snap'))) return element[0];\n    }\n    return elements.wrap;\n  }\n\n  function getAngularElements (elements) {\n    var obj = {};\n    for (var key in elements) {\n      obj[key] = angular.element(elements[key]);\n    }\n    return obj;\n  }\n\n  //-- event/change handlers\n\n  function selectedItemChange (selectedItem, previousSelectedItem) {\n    if (selectedItem) {\n      $scope.searchText = getDisplayValue(selectedItem);\n    }\n    if ($scope.itemChange && selectedItem !== previousSelectedItem)\n      $scope.itemChange(getItemScope(selectedItem));\n  }\n\n  function handleSelectedItemChange(selectedItem, previousSelectedItem) {\n    for (var i = 0; i < selectedItemWatchers.length; ++i) {\n      selectedItemWatchers[i](selectedItem, previousSelectedItem);\n    }\n  }\n\n  /**\n   * Register a function to be called when the selected item changes.\n   * @param cb\n   */\n  function registerSelectedItemWatcher(cb) {\n    if (selectedItemWatchers.indexOf(cb) == -1) {\n      selectedItemWatchers.push(cb);\n    }\n  }\n\n  /**\n   * Unregister a function previously registered for selected item changes.\n   * @param cb\n   */\n  function unregisterSelectedItemWatcher(cb) {\n    var i = selectedItemWatchers.indexOf(cb);\n    if (i != -1) {\n      selectedItemWatchers.splice(i, 1);\n    }\n  }\n\n  function handleSearchText (searchText, previousSearchText) {\n    self.index = getDefaultIndex();\n    //-- do nothing on init\n    if (searchText === previousSearchText) return;\n    //-- clear selected item if search text no longer matches it\n    if (searchText !== getDisplayValue($scope.selectedItem)) $scope.selectedItem = null;\n    else return;\n    //-- trigger change event if available\n    if ($scope.textChange && searchText !== previousSearchText)\n      $scope.textChange(getItemScope($scope.selectedItem));\n    //-- cancel results if search text is not long enough\n    if (!isMinLengthMet()) {\n      self.loading = false;\n      self.matches = [];\n      self.hidden = shouldHide();\n      updateMessages();\n    } else {\n      handleQuery();\n    }\n  }\n\n  function blur () {\n    hasFocus = false;\n    if (!noBlur) self.hidden = true;\n  }\n\n  function focus () {\n    hasFocus = true;\n    //-- if searchText is null, let's force it to be a string\n    if (!angular.isString($scope.searchText)) $scope.searchText = '';\n    if ($scope.minLength > 0) return;\n    self.hidden = shouldHide();\n    if (!self.hidden) handleQuery();\n  }\n\n  function keydown (event) {\n    switch (event.keyCode) {\n      case $mdConstant.KEY_CODE.DOWN_ARROW:\n        if (self.loading) return;\n        event.preventDefault();\n        self.index = Math.min(self.index + 1, self.matches.length - 1);\n        updateScroll();\n        updateMessages();\n        break;\n      case $mdConstant.KEY_CODE.UP_ARROW:\n        if (self.loading) return;\n        event.preventDefault();\n        self.index = self.index < 0 ? self.matches.length - 1 : Math.max(0, self.index - 1);\n        updateScroll();\n        updateMessages();\n        break;\n      case $mdConstant.KEY_CODE.TAB:\n      case $mdConstant.KEY_CODE.ENTER:\n        if (self.hidden || self.loading || self.index < 0 || self.matches.length < 1) return;\n        event.preventDefault();\n        select(self.index);\n        break;\n      case $mdConstant.KEY_CODE.ESCAPE:\n        self.matches = [];\n        self.hidden = true;\n        self.index = getDefaultIndex();\n        break;\n      default:\n    }\n  }\n\n  //-- getters\n\n  function getMinLength () {\n    return angular.isNumber($scope.minLength) ? $scope.minLength : 1;\n  }\n\n  function getDisplayValue (item) {\n    return (item && $scope.itemText) ? $scope.itemText(getItemScope(item)) : item;\n  }\n\n  function getItemScope (item) {\n    if (!item) return;\n    var locals = {};\n    if (self.itemName) locals[self.itemName] = item;\n    return locals;\n  }\n\n  function getDefaultIndex () {\n    return $scope.autoselect ? 0 : -1;\n  }\n\n  function shouldHide () {\n    if (!isMinLengthMet()) return true;\n  }\n\n  function getCurrentDisplayValue () {\n    return getDisplayValue(self.matches[self.index]);\n  }\n\n  function isMinLengthMet () {\n    return $scope.searchText.length >= getMinLength();\n  }\n\n  //-- actions\n\n  function select (index) {\n    $scope.selectedItem = self.matches[index];\n    $scope.searchText = getDisplayValue($scope.selectedItem) || $scope.searchText;\n    self.hidden = true;\n    self.index = 0;\n    self.matches = [];\n  }\n\n  function clearValue () {\n    $scope.searchText = '';\n    select(-1);\n\n    // Per http://www.w3schools.com/jsref/event_oninput.asp\n    var eventObj = document.createEvent('CustomEvent');\n    eventObj.initCustomEvent('input', true, true, {value: $scope.searchText});\n    elements.input.dispatchEvent(eventObj);\n\n    elements.input.focus();\n  }\n\n  function fetchResults (searchText) {\n    var items = $scope.$parent.$eval(itemExpr),\n        term = searchText.toLowerCase();\n    if (angular.isArray(items)) {\n      handleResults(items);\n    } else {\n      self.loading = true;\n      if (items.success) items.success(handleResults);\n      if (items.then)    items.then(handleResults);\n      if (items.error)   items.error(function () { self.loading = false; });\n    }\n    function handleResults (matches) {\n      cache[term] = matches;\n      self.loading = false;\n      if (searchText !== $scope.searchText) return; //-- just cache the results if old request\n      promise = null;\n      self.matches = matches;\n      self.hidden = shouldHide();\n      updateMessages();\n      positionDropdown();\n    }\n  }\n\n  function updateMessages () {\n    self.messages = self.matches.length\n        ? [ getCountMessage(), getCurrentDisplayValue() ]\n        : [];\n  }\n\n  function getCountMessage () {\n    switch (self.matches.length) {\n      case 1:  return 'There is 1 match available.';\n      default: return 'There are ' + self.matches.length + ' matches available.';\n    }\n  }\n\n  function updateScroll () {\n    if (!elements.li[self.index]) return;\n    var li  = elements.li[self.index],\n        top = li.offsetTop,\n        bot = top + li.offsetHeight,\n        hgt = elements.ul.clientHeight;\n    if (top < elements.ul.scrollTop) {\n      elements.ul.scrollTop = top;\n    } else if (bot > elements.ul.scrollTop + hgt) {\n      elements.ul.scrollTop = bot - hgt;\n    }\n  }\n\n  function handleQuery () {\n    var searchText = $scope.searchText,\n        term = searchText.toLowerCase();\n    //-- cancel promise if a promise is in progress\n    if (promise && promise.cancel) {\n      promise.cancel();\n      promise = null;\n    }\n    //-- if results are cached, pull in cached results\n    if (!$scope.noCache && cache[term]) {\n      self.matches = cache[term];\n      updateMessages();\n    } else {\n      fetchResults(searchText);\n    }\n    if (hasFocus) self.hidden = shouldHide();\n  }\n\n}\nMdAutocompleteCtrl.$inject = [\"$scope\", \"$element\", \"$mdUtil\", \"$mdConstant\", \"$timeout\", \"$mdTheming\", \"$window\", \"$animate\", \"$rootElement\"];\n\n})();\n(function(){\n\"use strict\";\n\nangular\n    .module('material.components.autocomplete')\n    .directive('mdAutocomplete', MdAutocomplete);\n\n/**\n * @ngdoc directive\n * @name mdAutocomplete\n * @module material.components.autocomplete\n *\n * @description\n * `<md-autocomplete>` is a special input component with a drop-down of all possible matches to a custom query.\n * This component allows you to provide real-time suggestions as the user types in the input area.\n *\n * To start, you will need to specify the required parameters and provide a template for your results.\n * The content inside `md-autocomplete` will be treated as a template.\n *\n * In more complex cases, you may want to include other content such as a message to display when\n * no matches were found.  You can do this by wrapping your template in `md-item-template` and adding\n * a tag for `md-not-found`.  An example of this is shown below.\n * ### Validation\n *\n * You can use `ng-messages` to include validation the same way that you would normally validate;\n * however, if you want to replicate a standard input with a floating label, you will have to do the\n * following:\n *\n * - Make sure that your template is wrapped in `md-item-template`\n * - Add your `ng-messages` code inside of `md-autocomplete`\n * - Add your validation properties to `md-autocomplete` (ie. `required`)\n * - Add a `name` to `md-autocomplete` (to be used on the generated `input`)\n *\n * There is an example below of how this should look.\n *\n *\n * @param {expression} md-items An expression in the format of `item in items` to iterate over matches for your search.\n * @param {expression} md-selected-item-change An expression to be run each time a new item is selected\n * @param {expression} md-search-text-change An expression to be run each time the search text updates\n * @param {string=} md-search-text A model to bind the search query text to\n * @param {object=} md-selected-item A model to bind the selected item to\n * @param {string=} md-item-text An expression that will convert your object to a single string.\n * @param {string=} placeholder Placeholder text that will be forwarded to the input.\n * @param {boolean=} md-no-cache Disables the internal caching that happens in autocomplete\n * @param {boolean=} ng-disabled Determines whether or not to disable the input field\n * @param {number=} md-min-length Specifies the minimum length of text before autocomplete will make suggestions\n * @param {number=} md-delay Specifies the amount of time (in milliseconds) to wait before looking for results\n * @param {boolean=} md-autofocus If true, will immediately focus the input element\n * @param {boolean=} md-autoselect If true, the first item will be selected by default\n * @param {string=} md-menu-class This will be applied to the dropdown menu for styling\n *\n * @usage\n * ###Basic Example\n * <hljs lang=\"html\">\n *   <md-autocomplete\n *       md-selected-item=\"selectedItem\"\n *       md-search-text=\"searchText\"\n *       md-items=\"item in getMatches(searchText)\"\n *       md-item-text=\"item.display\">\n *     <span md-highlight-text=\"searchText\">{{item.display}}</span>\n *   </md-autocomplete>\n * </hljs>\n *\n * ###Example with \"not found\" message\n * <hljs lang=\"html\">\n * <md-autocomplete\n *     md-selected-item=\"selectedItem\"\n *     md-search-text=\"searchText\"\n *     md-items=\"item in getMatches(searchText)\"\n *     md-item-text=\"item.display\">\n *   <md-item-template>\n *     <span md-highlight-text=\"searchText\">{{item.display}}</span>\n *   </md-item-template>\n *   <md-not-found>\n *     No matches found.\n *   </md-not-found>\n * </md-autocomplete>\n * </hljs>\n *\n * In this example, our code utilizes `md-item-template` and `md-not-found` to specify the different\n * parts that make up our component.\n *\n * ### Example with validation\n * <hljs lang=\"html\">\n * <form name=\"autocompleteForm\">\n *   <md-autocomplete\n *       required\n *       input-name=\"autocomplete\"\n *       md-selected-item=\"selectedItem\"\n *       md-search-text=\"searchText\"\n *       md-items=\"item in getMatches(searchText)\"\n *       md-item-text=\"item.display\">\n *     <md-item-template>\n *       <span md-highlight-text=\"searchText\">{{item.display}}</span>\n *     </md-item-template>\n *     <div ng-messages=\"autocompleteForm.autocomplete.$error\">\n *       <div ng-message=\"required\">This field is required</div>\n *     </div>\n *   </md-autocomplete>\n * </form>\n * </hljs>\n *\n * In this example, our code utilizes `md-item-template` and `md-not-found` to specify the different\n * parts that make up our component.\n */\n\nfunction MdAutocomplete ($mdTheming, $mdUtil) {\n  return {\n    controller:   'MdAutocompleteCtrl',\n    controllerAs: '$mdAutocompleteCtrl',\n    link:         link,\n    scope:        {\n      inputName:      '@mdInputName',\n      inputMinlength: '@mdInputMinlength',\n      inputMaxlength: '@mdInputMaxlength',\n      searchText:     '=?mdSearchText',\n      selectedItem:   '=?mdSelectedItem',\n      itemsExpr:      '@mdItems',\n      itemText:       '&mdItemText',\n      placeholder:    '@placeholder',\n      noCache:        '=?mdNoCache',\n      itemChange:     '&?mdSelectedItemChange',\n      textChange:     '&?mdSearchTextChange',\n      minLength:      '=?mdMinLength',\n      delay:          '=?mdDelay',\n      autofocus:      '=?mdAutofocus',\n      floatingLabel:  '@?mdFloatingLabel',\n      autoselect:     '=?mdAutoselect',\n      menuClass:      '@?mdMenuClass'\n    },\n    template: function (element, attr) {\n      var noItemsTemplate = getNoItemsTemplate(),\n          itemTemplate = getItemTemplate(),\n          leftover = element.html();\n      return '\\\n        <md-autocomplete-wrap\\\n            layout=\"row\"\\\n            ng-class=\"{ \\'md-whiteframe-z1\\': !floatingLabel }\"\\\n            role=\"listbox\">\\\n          ' + getInputElement() + '\\\n          <button\\\n              type=\"button\"\\\n              tabindex=\"-1\"\\\n              ng-if=\"$mdAutocompleteCtrl.scope.searchText && !isDisabled\"\\\n              ng-click=\"$mdAutocompleteCtrl.clear()\">\\\n            <md-icon md-svg-icon=\"md-cancel\"></md-icon>\\\n            <span class=\"md-visually-hidden\">Clear</span>\\\n          </button>\\\n          <md-progress-linear\\\n              ng-if=\"$mdAutocompleteCtrl.loading\"\\\n              md-mode=\"indeterminate\"></md-progress-linear>\\\n          <ul role=\"presentation\"\\\n              class=\"md-autocomplete-suggestions md-whiteframe-z1 {{menuClass || \\'\\'}}\"\\\n              id=\"ul-{{$mdAutocompleteCtrl.id}}\"\\\n              ng-mouseenter=\"$mdAutocompleteCtrl.listEnter()\"\\\n              ng-mouseleave=\"$mdAutocompleteCtrl.listLeave()\"\\\n              ng-mouseup=\"$mdAutocompleteCtrl.mouseUp()\">\\\n            <li ng-repeat=\"(index, item) in $mdAutocompleteCtrl.matches\"\\\n                ng-class=\"{ selected: index === $mdAutocompleteCtrl.index }\"\\\n                ng-hide=\"$mdAutocompleteCtrl.hidden\"\\\n                ng-click=\"$mdAutocompleteCtrl.select(index)\"\\\n                md-autocomplete-list-item=\"$mdAutocompleteCtrl.itemName\">\\\n                ' + itemTemplate + '\\\n            </li>\\\n            ' + noItemsTemplate + '\\\n          </ul>\\\n        </md-autocomplete-wrap>\\\n        <aria-status\\\n            class=\"md-visually-hidden\"\\\n            role=\"status\"\\\n            aria-live=\"assertive\">\\\n          <p ng-repeat=\"message in $mdAutocompleteCtrl.messages\" ng-if=\"message\">{{message}}</p>\\\n        </aria-status>';\n\n      function getItemTemplate() {\n        var templateTag = element.find('md-item-template').remove(),\n            html = templateTag.length ? templateTag.html() : element.html();\n        if (!templateTag.length) element.empty();\n        return html;\n      }\n\n      function getNoItemsTemplate() {\n        var templateTag = element.find('md-not-found').remove(),\n            template = templateTag.length ? templateTag.html() : '';\n        return template\n            ? '<li ng-if=\"!$mdAutocompleteCtrl.matches.length && !$mdAutocompleteCtrl.loading\\\n                         && !$mdAutocompleteCtrl.hidden\"\\\n                         ng-hide=\"$mdAutocompleteCtrl.hidden\"\\\n                         md-autocomplete-parent-scope>' + template + '</li>'\n            : '';\n\n      }\n\n      function getInputElement() {\n        if (attr.mdFloatingLabel) {\n          return '\\\n            <md-input-container flex ng-if=\"floatingLabel\">\\\n              <label>{{floatingLabel}}</label>\\\n              <input type=\"search\"\\\n                  id=\"fl-input-{{$mdAutocompleteCtrl.id}}\"\\\n                  name=\"{{inputName}}\"\\\n                  autocomplete=\"off\"\\\n                  ng-required=\"isRequired\"\\\n                  ng-minlength=\"inputMinlength\"\\\n                  ng-maxlength=\"inputMaxlength\"\\\n                  ng-disabled=\"isDisabled\"\\\n                  ng-model=\"$mdAutocompleteCtrl.scope.searchText\"\\\n                  ng-keydown=\"$mdAutocompleteCtrl.keydown($event)\"\\\n                  ng-blur=\"$mdAutocompleteCtrl.blur()\"\\\n                  ng-focus=\"$mdAutocompleteCtrl.focus()\"\\\n                  aria-owns=\"ul-{{$mdAutocompleteCtrl.id}}\"\\\n                  aria-label=\"{{floatingLabel}}\"\\\n                  aria-autocomplete=\"list\"\\\n                  aria-haspopup=\"true\"\\\n                  aria-activedescendant=\"\"\\\n                  aria-expanded=\"{{!$mdAutocompleteCtrl.hidden}}\"/>\\\n              <div md-autocomplete-parent-scope md-autocomplete-replace>' + leftover + '</div>\\\n            </md-input-container>';\n        } else {\n          return '\\\n            <input flex type=\"search\"\\\n                id=\"input-{{$mdAutocompleteCtrl.id}}\"\\\n                name=\"{{inputName}}\"\\\n                ng-if=\"!floatingLabel\"\\\n                autocomplete=\"off\"\\\n                ng-required=\"isRequired\"\\\n                ng-disabled=\"isDisabled\"\\\n                ng-model=\"$mdAutocompleteCtrl.scope.searchText\"\\\n                ng-keydown=\"$mdAutocompleteCtrl.keydown($event)\"\\\n                ng-blur=\"$mdAutocompleteCtrl.blur()\"\\\n                ng-focus=\"$mdAutocompleteCtrl.focus()\"\\\n                placeholder=\"{{placeholder}}\"\\\n                aria-owns=\"ul-{{$mdAutocompleteCtrl.id}}\"\\\n                aria-label=\"{{placeholder}}\"\\\n                aria-autocomplete=\"list\"\\\n                aria-haspopup=\"true\"\\\n                aria-activedescendant=\"\"\\\n                aria-expanded=\"{{!$mdAutocompleteCtrl.hidden}}\"/>';\n        }\n      }\n    }\n  };\n\n  function link (scope, element, attr) {\n    attr.$observe('disabled', function (value) { scope.isDisabled = value; });\n    attr.$observe('required', function (value) { scope.isRequired = value !== null; });\n\n    $mdUtil.initOptionalProperties(scope, attr, {searchText:null, selectedItem:null} );\n\n    $mdTheming(element);\n  }\n}\nMdAutocomplete.$inject = [\"$mdTheming\", \"$mdUtil\"];\n\n})();\n(function(){\n\"use strict\";\n\nangular\n    .module('material.components.autocomplete')\n    .controller('MdHighlightCtrl', MdHighlightCtrl);\n\nfunction MdHighlightCtrl ($scope, $element, $interpolate) {\n  this.init = init;\n\n  return init();\n\n  function init (term) {\n    var unsafeText = $interpolate($element.html())($scope),\n        text = angular.element('<div>').text(unsafeText).html(),\n        flags = $element.attr('md-highlight-flags') || '',\n        watcher = $scope.$watch(term, function (term) {\n          var regex = getRegExp(term, flags),\n              html = text.replace(regex, '<span class=\"highlight\">$&</span>');\n          $element.html(html);\n        });\n    $element.on('$destroy', function () { watcher(); });\n  }\n\n  function sanitize (term) {\n    if (!term) return term;\n    return term.replace(/[\\\\\\^\\$\\*\\+\\?\\.\\(\\)\\|\\{\\}\\[\\]]/g, '\\\\$&');\n  }\n\n  function getRegExp (text, flags) {\n    var str = '';\n    if (flags.indexOf('^') >= 1) str += '^';\n    str += text;\n    if (flags.indexOf('$') >= 1) str += '$';\n    return new RegExp(sanitize(str), flags.replace(/[\\$\\^]/g, ''));\n  }\n}\nMdHighlightCtrl.$inject = [\"$scope\", \"$element\", \"$interpolate\"];\n\n})();\n(function(){\n\"use strict\";\n\nangular\n    .module('material.components.autocomplete')\n    .directive('mdHighlightText', MdHighlight);\n\n/**\n * @ngdoc directive\n * @name mdHighlightText\n * @module material.components.autocomplete\n *\n * @description\n * The `md-highlight-text` directive allows you to specify text that should be highlighted within\n * an element.  Highlighted text will be wrapped in `<span class=\"highlight\"></span>` which can\n * be styled through CSS.  Please note that child elements may not be used with this directive.\n *\n * @param {string} md-highlight-text A model to be searched for\n * @param {string=} md-highlight-flags A list of flags (loosely based on JavaScript RexExp flags).\n *    #### **Supported flags**:\n *    - `g`: Find all matches within the provided text\n *    - `i`: Ignore case when searching for matches\n *    - `$`: Only match if the text ends with the search term\n *    - `^`: Only match if the text begins with the search term\n *\n * @usage\n * <hljs lang=\"html\">\n * <input placeholder=\"Enter a search term...\" ng-model=\"searchTerm\" type=\"text\" />\n * <ul>\n *   <li ng-repeat=\"result in results\" md-highlight-text=\"searchTerm\">\n *     {{result.text}}\n *   </li>\n * </ul>\n * </hljs>\n */\n\nfunction MdHighlight () {\n  return {\n    terminal: true,\n    scope: false,\n    controller: 'MdHighlightCtrl',\n    link: function (scope, element, attr, ctrl) {\n      ctrl.init(attr.mdHighlightText);\n    }\n  };\n}\n\n})();\n(function(){\n\"use strict\";\n\nangular\n    .module('material.components.autocomplete')\n    .directive('mdAutocompleteListItem', MdAutocompleteListItem);\n\nfunction MdAutocompleteListItem ($compile, $mdUtil) {\n  return {\n    terminal: true,\n    link: postLink,\n    scope: false\n  };\n  function postLink (scope, element, attr) {\n    var ctrl     = scope.$parent.$mdAutocompleteCtrl,\n        newScope = ctrl.parent.$new(false, ctrl.parent),\n        itemName = ctrl.scope.$eval(attr.mdAutocompleteListItem);\n    newScope[itemName] = scope.item;\n    $compile(element.contents())(newScope);\n    element.attr({\n      role: 'option',\n      id: 'item_' + $mdUtil.nextUid()\n    });\n  }\n}\nMdAutocompleteListItem.$inject = [\"$compile\", \"$mdUtil\"];\n\n})();\n(function(){\n\"use strict\";\n\nangular\n    .module('material.components.autocomplete')\n    .directive('mdAutocompleteParentScope', MdAutocompleteParentScope);\n\nfunction MdAutocompleteParentScope ($compile, $mdUtil) {\n  return {\n    restrict: 'A',\n    terminal: true,\n    link: postLink,\n    scope: false\n  };\n  function postLink (scope, element, attr) {\n    var ctrl     = scope.$parent.$mdAutocompleteCtrl;\n    $compile(element.contents())(ctrl.parent);\n    if (attr.hasOwnProperty('mdAutocompleteReplace')) {\n      element.after(element.contents());\n      element.remove();\n    }\n  }\n}\nMdAutocompleteParentScope.$inject = [\"$compile\", \"$mdUtil\"];\n\n})();\n(function(){\n\"use strict\";\n\nangular\n    .module('material.components.chips')\n    .directive('mdChip', MdChip);\n\n/**\n * @ngdoc directive\n * @name mdChip\n * @module material.components.chips\n *\n * @description\n * `<md-chip>` is a component used within `<md-chips>` and is responsible for rendering individual\n * chips.\n *\n *\n * @usage\n * <hljs lang=\"html\">\n *   <md-chip>{{$chip}}</md-chip>\n * </hljs>\n *\n */\n\n// This hint text is hidden within a chip but used by screen readers to\n// inform the user how they can interact with a chip.\nvar DELETE_HINT_TEMPLATE = '\\\n    <span ng-if=\"!$mdChipsCtrl.readonly\" class=\"md-visually-hidden\">\\\n      {{$mdChipsCtrl.deleteHint}}\\\n    </span>';\n\n/**\n * MDChip Directive Definition\n *\n * @param $mdTheming\n * @param $mdInkRipple\n * @ngInject\n */\nfunction MdChip($mdTheming) {\n  return {\n    restrict: 'E',\n    require: '^?mdChips',\n    compile:  compile\n  };\n\n  function compile(element, attr) {\n    element.append(DELETE_HINT_TEMPLATE);\n    return function postLink(scope, element, attr, ctrl) {\n      element.addClass('md-chip');\n      $mdTheming(element);\n\n      if (ctrl) angular.element(element[0].querySelector('.md-chip-content'))\n          .on('blur', function () {\n            ctrl.selectedChip = -1;\n          });\n    };\n  }\n}\nMdChip.$inject = [\"$mdTheming\"];\n\n})();\n(function(){\n\"use strict\";\n\nangular\n    .module('material.components.chips')\n    .directive('mdChipRemove', MdChipRemove);\n\n/**\n * @ngdoc directive\n * @name mdChipRemove\n * @module material.components.chips\n *\n * @description\n * `<md-chip-remove>`\n * Designates an element to be used as the delete button for a chip. This\n * element is passed as a child of the `md-chips` element.\n *\n * @usage\n * <hljs lang=\"html\">\n *   <md-chips><button md-chip-remove>DEL</button></md-chips>\n * </hljs>\n */\n\n\n/**\n * MdChipRemove Directive Definition.\n * \n * @param $compile\n * @param $timeout\n * @returns {{restrict: string, require: string[], link: Function, scope: boolean}}\n * @constructor\n */\nfunction MdChipRemove ($timeout) {\n  return {\n    restrict: 'A',\n    require: '^mdChips',\n    scope: false,\n    link: postLink\n  };\n\n  function postLink(scope, element, attr, ctrl) {\n    element.on('click', function(event) {\n      scope.$apply(function() {\n        ctrl.removeChip(scope.$$replacedScope.$index);\n      });\n    });\n\n    // Child elements aren't available until after a $timeout tick as they are hidden by an\n    // `ng-if`. see http://goo.gl/zIWfuw\n    $timeout(function() {\n      element.attr({ tabindex: -1, ariaHidden: true });\n      element.find('button').attr('tabindex', '-1');\n    });\n  }\n}\nMdChipRemove.$inject = [\"$timeout\"];\n\n})();\n(function(){\n\"use strict\";\n\nangular\n    .module('material.components.chips')\n    .directive('mdChipTransclude', MdChipTransclude);\n\nfunction MdChipTransclude ($compile, $mdUtil) {\n  return {\n    restrict: 'EA',\n    terminal: true,\n    link: link,\n    scope: false\n  };\n  function link (scope, element, attr) {\n    var ctrl = scope.$parent.$mdChipsCtrl,\n        newScope = ctrl.parent.$new(false, ctrl.parent);\n    newScope.$$replacedScope = scope;\n    newScope.$chip = scope.$chip;\n    newScope.$mdChipsCtrl = ctrl;\n    element.html(ctrl.$scope.$eval(attr.mdChipTransclude));\n    $compile(element.contents())(newScope);\n  }\n}\nMdChipTransclude.$inject = [\"$compile\", \"$mdUtil\"];\n\n})();\n(function(){\n\"use strict\";\n\nangular\n    .module('material.components.chips')\n    .controller('MdChipsCtrl', MdChipsCtrl);\n\n/**\n * Controller for the MdChips component. Responsible for adding to and\n * removing from the list of chips, marking chips as selected, and binding to\n * the models of various input components.\n *\n * @param $scope\n * @param $mdConstant\n * @param $log\n * @param $element\n * @constructor\n */\nfunction MdChipsCtrl ($scope, $mdConstant, $log, $element, $timeout) {\n  /** @type {$timeout} **/\n  this.$timeout = $timeout;\n\n  /** @type {Object} */\n  this.$mdConstant = $mdConstant;\n\n  /** @type {angular.$scope} */\n  this.$scope = $scope;\n\n  /** @type {angular.$scope} */\n  this.parent = $scope.$parent;\n\n  /** @type {$log} */\n  this.$log = $log;\n\n  /** @type {$element} */\n  this.$element = $element;\n\n  /** @type {angular.NgModelController} */\n  this.ngModelCtrl = null;\n\n  /** @type {angular.NgModelController} */\n  this.userInputNgModelCtrl = null;\n\n  /** @type {Element} */\n  this.userInputElement = null;\n\n  /** @type {Array.<Object>} */\n  this.items = [];\n\n  /** @type {number} */\n  this.selectedChip = -1;\n\n\n  /**\n   * Hidden hint text for how to delete a chip. Used to give context to screen readers.\n   * @type {string}\n   */\n  this.deleteHint = 'Press delete to remove this chip.';\n\n  /**\n   * Hidden label for the delete button. Used to give context to screen readers.\n   * @type {string}\n   */\n  this.deleteButtonLabel = 'Remove';\n\n  /**\n   * Model used by the input element.\n   * @type {string}\n   */\n  this.chipBuffer = '';\n\n  /**\n   * Whether to use the mdOnAppend expression to transform the chip buffer\n   * before appending it to the list.\n   * @type {boolean}\n   */\n  this.useMdOnAppend = false;\n}\nMdChipsCtrl.$inject = [\"$scope\", \"$mdConstant\", \"$log\", \"$element\", \"$timeout\"];\n\n/**\n * Handles the keydown event on the input element: <enter> appends the\n * buffer to the chip list, while backspace removes the last chip in the list\n * if the current buffer is empty.\n * @param event\n */\nMdChipsCtrl.prototype.inputKeydown = function(event) {\n  var chipBuffer = this.getChipBuffer();\n  switch (event.keyCode) {\n    case this.$mdConstant.KEY_CODE.ENTER:\n      if (this.$scope.requireMatch || !chipBuffer) break;\n      event.preventDefault();\n      this.appendChip(chipBuffer);\n      this.resetChipBuffer();\n      break;\n    case this.$mdConstant.KEY_CODE.BACKSPACE:\n      if (chipBuffer) break;\n      event.stopPropagation();\n      if (this.items.length) this.selectAndFocusChipSafe(this.items.length - 1);\n      break;\n  }\n};\n\n/**\n * Handles the keydown event on the chip elements: backspace removes the selected chip, arrow\n * keys switch which chips is active\n * @param event\n */\nMdChipsCtrl.prototype.chipKeydown = function (event) {\n  if (this.getChipBuffer()) return;\n  switch (event.keyCode) {\n    case this.$mdConstant.KEY_CODE.BACKSPACE:\n    case this.$mdConstant.KEY_CODE.DELETE:\n      if (this.selectedChip < 0) return;\n      event.preventDefault();\n      this.removeAndSelectAdjacentChip(this.selectedChip);\n      break;\n    case this.$mdConstant.KEY_CODE.LEFT_ARROW:\n      event.preventDefault();\n      if (this.selectedChip < 0) this.selectedChip = this.items.length;\n      if (this.items.length) this.selectAndFocusChipSafe(this.selectedChip - 1);\n      break;\n    case this.$mdConstant.KEY_CODE.RIGHT_ARROW:\n      event.preventDefault();\n      this.selectAndFocusChipSafe(this.selectedChip + 1);\n      break;\n    case this.$mdConstant.KEY_CODE.ESCAPE:\n    case this.$mdConstant.KEY_CODE.TAB:\n      if (this.selectedChip < 0) return;\n      event.preventDefault();\n      this.onFocus();\n      break;\n  }\n};\n\n/**\n * Get the input's placeholder - uses `placeholder` when list is empty and `secondary-placeholder`\n * when the list is non-empty. If `secondary-placeholder` is not provided, `placeholder` is used\n * always.\n */\nMdChipsCtrl.prototype.getPlaceholder = function() {\n  // Allow `secondary-placeholder` to be blank.\n  var useSecondary = (this.items.length &&\n      (this.secondaryPlaceholder == '' || this.secondaryPlaceholder));\n  return useSecondary ? this.placeholder : this.secondaryPlaceholder;\n};\n\n/**\n * Removes chip at {@code index} and selects the adjacent chip.\n * @param index\n */\nMdChipsCtrl.prototype.removeAndSelectAdjacentChip = function(index) {\n  var selIndex = this.getAdjacentChipIndex(index);\n  this.removeChip(index);\n  this.$timeout(angular.bind(this, function () {\n      this.selectAndFocusChipSafe(selIndex);\n  }));\n};\n\n/**\n * Sets the selected chip index to -1.\n */\nMdChipsCtrl.prototype.resetSelectedChip = function() {\n  this.selectedChip = -1;\n};\n\n/**\n * Gets the index of an adjacent chip to select after deletion. Adjacency is\n * determined as the next chip in the list, unless the target chip is the\n * last in the list, then it is the chip immediately preceding the target. If\n * there is only one item in the list, -1 is returned (select none).\n * The number returned is the index to select AFTER the target has been\n * removed.\n * If the current chip is not selected, then -1 is returned to select none.\n */\nMdChipsCtrl.prototype.getAdjacentChipIndex = function(index) {\n  var len = this.items.length - 1;\n  return (len == 0) ? -1 :\n      (index == len) ? index -1 : index;\n};\n\n/**\n * Append the contents of the buffer to the chip list. This method will first\n * call out to the md-on-append method, if provided\n * @param newChip\n */\nMdChipsCtrl.prototype.appendChip = function(newChip) {\n  if (this.items.indexOf(newChip) + 1) return;\n  if (this.useMdOnAppend && this.mdOnAppend) {\n    newChip = this.mdOnAppend({'$chip': newChip});\n  }\n  this.items.push(newChip);\n};\n\n/**\n * Sets whether to use the md-on-append expression. This expression is\n * bound to scope and controller in {@code MdChipsDirective} as\n * {@code mdOnAppend}. Due to the nature of directive scope bindings, the\n * controller cannot know on its own/from the scope whether an expression was\n * actually provided.\n */\nMdChipsCtrl.prototype.useMdOnAppendExpression = function() {\n  this.useMdOnAppend = true;\n};\n\n/**\n * Gets the input buffer. The input buffer can be the model bound to the\n * default input item {@code this.chipBuffer}, the {@code selectedItem}\n * model of an {@code md-autocomplete}, or, through some magic, the model\n * bound to any inpput or text area element found within a\n * {@code md-input-container} element.\n * @return {Object|string}\n */\nMdChipsCtrl.prototype.getChipBuffer = function() {\n  return !this.userInputElement ? this.chipBuffer :\n      this.userInputNgModelCtrl ? this.userInputNgModelCtrl.$viewValue :\n          this.userInputElement[0].value;\n};\n\n/**\n * Resets the input buffer for either the internal input or user provided input element.\n */\nMdChipsCtrl.prototype.resetChipBuffer = function() {\n  if (this.userInputElement) {\n    if (this.userInputNgModelCtrl) {\n      this.userInputNgModelCtrl.$setViewValue('');\n      this.userInputNgModelCtrl.$render();\n    } else {\n      this.userInputElement[0].value = '';\n    }\n  } else {\n    this.chipBuffer = '';\n  }\n};\n\n/**\n * Removes the chip at the given index.\n * @param index\n */\nMdChipsCtrl.prototype.removeChip = function(index) {\n  this.items.splice(index, 1);\n};\n\nMdChipsCtrl.prototype.removeChipAndFocusInput = function (index) {\n  this.removeChip(index);\n  this.onFocus();\n};\n/**\n * Selects the chip at `index`,\n * @param index\n */\nMdChipsCtrl.prototype.selectAndFocusChipSafe = function(index) {\n  if (!this.items.length) {\n    this.selectChip(-1);\n    this.onFocus();\n    return;\n  }\n  if (index === this.items.length) return this.onFocus();\n  index = Math.max(index, 0);\n  index = Math.min(index, this.items.length - 1);\n  this.selectChip(index);\n  this.focusChip(index);\n};\n\n/**\n * Marks the chip at the given index as selected.\n * @param index\n */\nMdChipsCtrl.prototype.selectChip = function(index) {\n  if (index >= -1 && index <= this.items.length) {\n    this.selectedChip = index;\n  } else {\n    this.$log.warn('Selected Chip index out of bounds; ignoring.');\n  }\n};\n\n/**\n * Selects the chip at `index` and gives it focus.\n * @param index\n */\nMdChipsCtrl.prototype.selectAndFocusChip = function(index) {\n  this.selectChip(index);\n  if (index != -1) {\n    this.focusChip(index);\n  }\n};\n\n/**\n * Call `focus()` on the chip at `index`\n */\nMdChipsCtrl.prototype.focusChip = function(index) {\n  this.$element[0].querySelector('md-chip[index=\"' + index + '\"] .md-chip-content').focus();\n};\n\n/**\n * Configures the required interactions with the ngModel Controller.\n * Specifically, set {@code this.items} to the {@code NgModelCtrl#$viewVale}.\n * @param ngModelCtrl\n */\nMdChipsCtrl.prototype.configureNgModel = function(ngModelCtrl) {\n  this.ngModelCtrl = ngModelCtrl;\n\n  var self = this;\n  ngModelCtrl.$render = function() {\n    // model is updated. do something.\n    self.items = self.ngModelCtrl.$viewValue;\n  };\n};\n\nMdChipsCtrl.prototype.onFocus = function () {\n  var input = this.$element[0].querySelector('input');\n  input && input.focus();\n  this.resetSelectedChip();\n};\n\nMdChipsCtrl.prototype.onInputFocus = function () {\n  this.inputHasFocus = true;\n  this.resetSelectedChip();\n};\n\nMdChipsCtrl.prototype.onInputBlur = function () {\n  this.inputHasFocus = false;\n};\n\n/**\n * Configure event bindings on a user-provided input element.\n * @param inputElement\n */\nMdChipsCtrl.prototype.configureUserInput = function(inputElement) {\n  this.userInputElement = inputElement;\n\n  // Find the NgModelCtrl for the input element\n  var ngModelCtrl = inputElement.controller('ngModel');\n  // `.controller` will look in the parent as well.\n  if (ngModelCtrl != this.ngModelCtrl) {\n    this.userInputNgModelCtrl = ngModelCtrl;\n  }\n\n  // Bind to keydown and focus events of input\n  var scope = this.$scope;\n  var ctrl = this;\n  inputElement\n      .attr({ tabindex: 0 })\n      .on('keydown', function(event) { scope.$apply( angular.bind(ctrl, function() { ctrl.inputKeydown(event); })) })\n      .on('focus', angular.bind(ctrl, ctrl.onInputFocus))\n      .on('blur', angular.bind(ctrl, ctrl.onInputBlur));\n};\n\nMdChipsCtrl.prototype.configureAutocomplete = function(ctrl) {\n\n  ctrl.registerSelectedItemWatcher(angular.bind(this, function (item) {\n    if (item) {\n      this.appendChip(item);\n      this.resetChipBuffer();\n    }\n  }));\n\n  this.$element.find('input')\n      .on('focus',angular.bind(this, this.onInputFocus) )\n      .on('blur', angular.bind(this, this.onInputBlur) );\n};\n\nMdChipsCtrl.prototype.hasFocus = function () {\n  return this.inputHasFocus || this.selectedChip >= 0;\n};\n\n})();\n(function(){\n\"use strict\";\n\n  angular\n      .module('material.components.chips')\n      .directive('mdChips', MdChips);\n\n  /**\n   * @ngdoc directive\n   * @name mdChips\n   * @module material.components.chips\n   *\n   * @description\n   * `<md-chips>` is an input component for building lists of strings or objects. The list items are\n   * displayed as 'chips'. This component can make use of an `<input>` element or an\n   * `<md-autocomplete>` element.\n   *\n   * <strong>Custom `<md-chip-template>` template</strong>\n   * A custom template may be provided to render the content of each chip. This is achieved by\n   * specifying an `<md-chip-template>` element as a child of `<md-chips>`. Note: Any attributes on\n   * `<md-chip-template>` will be dropped as only the innerHTML is used for the chip template. The\n   * variables `$chip` and `$index` are available in the scope of `<md-chip-template>`, representing\n   * the chip object and its index in the list of chips, respectively.\n   * To override the chip delete control, include an element (ideally a button) with the attribute\n   * `md-chip-remove`. A click listener to remove the chip will be added automatically. The element\n   * is also placed as a sibling to the chip content (on which there are also click listeners) to\n   * avoid a nested ng-click situation.\n   *\n   * <h3> Pending Features </h3>\n   * <ul style=\"padding-left:20px;\">\n   *\n   *   <ul>Style\n   *     <li>Colours for hover, press states (ripple?).</li>\n   *   </ul>\n   *\n   *   <ul>List Manipulation\n   *     <li>delete item via DEL or backspace keys when selected</li>\n   *   </ul>\n   *\n   *   <ul>Validation\n   *     <li>de-dupe values (or support duplicates, but fix the ng-repeat duplicate key issue)</li>\n   *     <li>allow a validation callback</li>\n   *     <li>hilighting style for invalid chips</li>\n   *   </ul>\n   *\n   *   <ul>Item mutation\n   *     <li>Support `\n   *       <md-chip-edit>` template, show/hide the edit element on tap/click? double tap/double\n   *       click?\n   *     </li>\n   *   </ul>\n   *\n   *   <ul>Truncation and Disambiguation (?)\n   *     <li>Truncate chip text where possible, but do not truncate entries such that two are\n   *     indistinguishable.</li>\n   *   </ul>\n   *\n   *   <ul>Drag and Drop\n   *     <li>Drag and drop chips between related `<md-chips>` elements.\n   *     </li>\n   *   </ul>\n   * </ul>\n   *\n   *  <span style=\"font-size:.8em;text-align:center\">\n   *    Warning: This component is a WORK IN PROGRESS. If you use it now,\n   *    it will probably break on you in the future.\n   *  </span>\n   *\n   * @param {string=|object=} ng-model A model to bind the list of items to\n   * @param {string=} placeholder Placeholder text that will be forwarded to the input.\n   * @param {string=} secondary-placeholder Placeholder text that will be forwarded to the input,\n   *    displayed when there is at least on item in the list\n   * @param {boolean=} readonly Disables list manipulation (deleting or adding list items), hiding\n   *    the input and delete buttons\n   * @param {expression} md-on-append An expression expected to convert the input string into an\n   *    object when adding a chip.\n   * @param {string=} delete-hint A string read by screen readers instructing users that pressing\n   *    the delete key will remove the chip.\n   * @param {string=} delete-button-label A label for the delete button. Also hidden and read by\n   *    screen readers.\n   *\n   * @usage\n   * <hljs lang=\"html\">\n   *   <md-chips\n   *       ng-model=\"myItems\"\n   *       placeholder=\"Add an item\"\n   *       readonly=\"isReadOnly\">\n   *   </md-chips>\n   * </hljs>\n   *\n   */\n\n\n  var MD_CHIPS_TEMPLATE = '\\\n      <md-chips-wrap\\\n          ng-if=\"!$mdChipsCtrl.readonly || $mdChipsCtrl.items.length > 0\"\\\n          ng-keydown=\"$mdChipsCtrl.chipKeydown($event)\"\\\n          ng-class=\"{ \\'md-focused\\': $mdChipsCtrl.hasFocus() }\"\\\n          class=\"md-chips\">\\\n        <md-chip ng-repeat=\"$chip in $mdChipsCtrl.items\"\\\n            index=\"{{$index}}\"\\\n            ng-class=\"{\\'md-focused\\': $mdChipsCtrl.selectedChip == $index}\">\\\n          <div class=\"md-chip-content\"\\\n              tabindex=\"-1\"\\\n              aria-hidden=\"true\"\\\n              ng-focus=\"!$mdChipsCtrl.readonly && $mdChipsCtrl.selectChip($index)\"\\\n              md-chip-transclude=\"$mdChipsCtrl.chipContentsTemplate\"></div>\\\n          <div class=\"md-chip-remove-container\"\\\n              md-chip-transclude=\"$mdChipsCtrl.chipRemoveTemplate\"></div>\\\n        </md-chip>\\\n        <div ng-if=\"!$mdChipsCtrl.readonly && $mdChipsCtrl.ngModelCtrl\"\\\n            class=\"md-chip-input-container\"\\\n            md-chip-transclude=\"$mdChipsCtrl.chipInputTemplate\"></div>\\\n        </div>\\\n      </md-chips-wrap>';\n\n  var CHIP_INPUT_TEMPLATE = '\\\n        <input\\\n            tabindex=\"0\"\\\n            placeholder=\"{{$mdChipsCtrl.getPlaceholder()}}\"\\\n            aria-label=\"{{$mdChipsCtrl.getPlaceholder()}}\"\\\n            ng-model=\"$mdChipsCtrl.chipBuffer\"\\\n            ng-focus=\"$mdChipsCtrl.onInputFocus()\"\\\n            ng-blur=\"$mdChipsCtrl.onInputBlur()\"\\\n            ng-keydown=\"$mdChipsCtrl.inputKeydown($event)\">';\n\n  var CHIP_DEFAULT_TEMPLATE = '\\\n      <span>{{$chip}}</span>';\n\n  var CHIP_REMOVE_TEMPLATE = '\\\n      <button\\\n          class=\"md-chip-remove\"\\\n          ng-if=\"!$mdChipsCtrl.readonly\"\\\n          ng-click=\"$mdChipsCtrl.removeChipAndFocusInput($$replacedScope.$index)\"\\\n          type=\"button\"\\\n          aria-hidden=\"true\"\\\n          tabindex=\"-1\">\\\n        <md-icon md-svg-icon=\"md-close\"></md-icon>\\\n        <span class=\"md-visually-hidden\">\\\n          {{$mdChipsCtrl.deleteButtonLabel}}\\\n        </span>\\\n      </button>';\n\n  /**\n   * MDChips Directive Definition\n   */\n  function MdChips ($mdTheming, $mdUtil, $compile, $log, $timeout) {\n    return {\n      template: function(element, attrs) {\n        // Clone the element into an attribute. By prepending the attribute\n        // name with '$', Angular won't write it into the DOM. The cloned\n        // element propagates to the link function via the attrs argument,\n        // where various contained-elements can be consumed.\n        var content = attrs['$mdUserTemplate'] = element.clone();\n        return MD_CHIPS_TEMPLATE;\n      },\n      require: ['mdChips'],\n      restrict: 'E',\n      controller: 'MdChipsCtrl',\n      controllerAs: '$mdChipsCtrl',\n      bindToController: true,\n      compile: compile,\n      scope: {\n        readonly: '=readonly',\n        placeholder: '@',\n        secondaryPlaceholder: '@',\n        mdOnAppend: '&',\n        deleteHint: '@',\n        deleteButtonLabel: '@',\n        requireMatch: '=?mdRequireMatch'\n      }\n    };\n\n    /**\n     * Builds the final template for `md-chips` and returns the postLink function.\n     *\n     * Building the template involves 3 key components:\n     * static chips\n     * chip template\n     * input control\n     *\n     * If no `ng-model` is provided, only the static chip work needs to be done.\n     *\n     * If no user-passed `md-chip-template` exists, the default template is used. This resulting\n     * template is appended to the chip content element.\n     *\n     * The remove button may be overridden by passing an element with an md-chip-remove attribute.\n     *\n     * If an `input` or `md-autocomplete` element is provided by the caller, it is set aside for\n     * transclusion later. The transclusion happens in `postLink` as the parent scope is required.\n     * If no user input is provided, a default one is appended to the input container node in the\n     * template.\n     *\n     * Static Chips (i.e. `md-chip` elements passed from the caller) are gathered and set aside for\n     * transclusion in the `postLink` function.\n     *\n     *\n     * @param element\n     * @param attr\n     * @returns {Function}\n     */\n    function compile(element, attr) {\n      // Grab the user template from attr and reset the attribute to null.\n      var userTemplate = attr['$mdUserTemplate'];\n      attr['$mdUserTemplate'] = null;\n\n      // Set the chip remove, chip contents and chip input templates. The link function will put\n      // them on the scope for transclusion later.\n      var chipRemoveTemplate   = getTemplateByQuery('md-chips>*[md-chip-remove]') || CHIP_REMOVE_TEMPLATE,\n          chipContentsTemplate = getTemplateByQuery('md-chips>md-chip-template') || CHIP_DEFAULT_TEMPLATE,\n          chipInputTemplate    = getTemplateByQuery('md-chips>md-autocomplete')\n              || getTemplateByQuery('md-chips>input')\n              || CHIP_INPUT_TEMPLATE,\n          staticChips = userTemplate.find('md-chip');\n\n      // Warn of malformed template. See #2545\n      if (userTemplate[0].querySelector('md-chip-template>*[md-chip-remove]')) {\n        $log.warn('invalid placement of md-chip-remove within md-chip-template.');\n      }\n\n      function getTemplateByQuery (query) {\n        if (!attr.ngModel) return;\n        var element = userTemplate[0].querySelector(query);\n        return element && element.outerHTML;\n      }\n\n      /**\n       * Configures controller and transcludes.\n       */\n      return function postLink(scope, element, attrs, controllers) {\n\n        $mdUtil.initOptionalProperties(scope, attr);\n\n        $mdTheming(element);\n        var mdChipsCtrl = controllers[0];\n        mdChipsCtrl.chipContentsTemplate = chipContentsTemplate;\n        mdChipsCtrl.chipRemoveTemplate   = chipRemoveTemplate;\n        mdChipsCtrl.chipInputTemplate    = chipInputTemplate;\n\n        element\n            .attr({ ariaHidden: true, tabindex: -1 })\n            .on('focus', function () { mdChipsCtrl.onFocus(); });\n\n        if (attr.ngModel) {\n          mdChipsCtrl.configureNgModel(element.controller('ngModel'));\n\n          // If an `md-on-append` attribute was set, tell the controller to use the expression\n          // when appending chips.\n          if (attrs.mdOnAppend) mdChipsCtrl.useMdOnAppendExpression();\n\n          // The md-autocomplete and input elements won't be compiled until after this directive\n          // is complete (due to their nested nature). Wait a tick before looking for them to\n          // configure the controller.\n          if (chipInputTemplate != CHIP_INPUT_TEMPLATE) {\n            $timeout(function() {\n              if (chipInputTemplate.indexOf('<md-autocomplete') === 0)\n                mdChipsCtrl\n                    .configureAutocomplete(element.find('md-autocomplete')\n                        .controller('mdAutocomplete'));\n              mdChipsCtrl.configureUserInput(element.find('input'));\n            });\n          }\n        }\n\n        // Compile with the parent's scope and prepend any static chips to the wrapper.\n        if (staticChips.length > 0) {\n          var compiledStaticChips = $compile(staticChips)(scope.$parent);\n          $timeout(function() { element.find('md-chips-wrap').prepend(compiledStaticChips); });\n        }\n      };\n    }\n  }\n  MdChips.$inject = [\"$mdTheming\", \"$mdUtil\", \"$compile\", \"$log\", \"$timeout\"];\n\n})();\n(function(){\n\"use strict\";\n\nangular\n    .module('material.components.chips')\n    .controller('MdContactChipsCtrl', MdContactChipsCtrl);\n\n\n\n/**\n * Controller for the MdContactChips component\n * @constructor\n */\nfunction MdContactChipsCtrl () {\n  /** @type {Object} */\n  this.selectedItem = null;\n\n  /** @type {string} */\n  this.searchText = '';\n}\n\n\nMdContactChipsCtrl.prototype.queryContact = function(searchText) {\n  var results = this.contactQuery({'$query': searchText});\n  return this.filterSelected ?\n      results.filter(angular.bind(this, this.filterSelectedContacts)) : results;\n};\n\n\nMdContactChipsCtrl.prototype.filterSelectedContacts = function(contact) {\n  return this.contacts.indexOf(contact) == -1;\n};\n\n})();\n(function(){\n\"use strict\";\n\n  angular\n      .module('material.components.chips')\n      .directive('mdContactChips', MdContactChips);\n\n  /**\n   * @ngdoc directive\n   * @name mdContactChips\n   * @module material.components.chips\n   *\n   * @description\n   * `<md-contact-chips>` is an input component based on `md-chips` and makes use of an\n   *    `md-autocomplete` element. The component allows the caller to supply a query expression\n   *    which returns  a list of possible contacts. The user can select one of these and add it to\n   *    the list of chips.\n   *\n   * @param {string=|object=} ng-model A model to bind the list of items to\n   * @param {string=} placeholder Placeholder text that will be forwarded to the input.\n   * @param {string=} secondary-placeholder Placeholder text that will be forwarded to the input,\n   *    displayed when there is at least on item in the list\n   * @param {expression} md-contacts An expression expected to return contacts matching the search\n   *    test, `$query`.\n   * @param {string} md-contact-name The field name of the contact object representing the\n   *    contact's name.\n   * @param {string} md-contact-email The field name of the contact object representing the\n   *    contact's email address.\n   * @param {string} md-contact-image The field name of the contact object representing the\n   *    contact's image.\n   *\n   *\n   * // The following attribute has been removed but may come back.\n   * @param {expression=} filter-selected Whether to filter selected contacts from the list of\n   *    suggestions shown in the autocomplete.\n   *\n   *\n   *\n   * @usage\n   * <hljs lang=\"html\">\n   *   <md-contact-chips\n   *       ng-model=\"ctrl.contacts\"\n   *       md-contacts=\"ctrl.querySearch($query)\"\n   *       md-contact-name=\"name\"\n   *       md-contact-image=\"image\"\n   *       md-contact-email=\"email\"\n   *       placeholder=\"To\">\n   *   </md-contact-chips>\n   * </hljs>\n   *\n   */\n\n\n  var MD_CONTACT_CHIPS_TEMPLATE = '\\\n      <md-chips class=\"md-contact-chips\"\\\n          ng-model=\"$mdContactChipsCtrl.contacts\"\\\n          md-require-match=\"$mdContactChipsCtrl.requireMatch\"\\\n          md-autocomplete-snap>\\\n          <md-autocomplete\\\n              md-menu-class=\"md-contact-chips-suggestions\"\\\n              md-selected-item=\"$mdContactChipsCtrl.selectedItem\"\\\n              md-search-text=\"$mdContactChipsCtrl.searchText\"\\\n              md-items=\"item in $mdContactChipsCtrl.queryContact($mdContactChipsCtrl.searchText)\"\\\n              md-item-text=\"$mdContactChipsCtrl.mdContactName\"\\\n              md-no-cache=\"true\"\\\n              md-autoselect\\\n              placeholder=\"{{$mdContactChipsCtrl.contacts.length == 0 ?\\\n                  $mdContactChipsCtrl.placeholder : $mdContactChipsCtrl.secondaryPlaceholder}}\">\\\n            <div class=\"md-contact-suggestion\">\\\n              <img \\\n                  ng-src=\"{{item[$mdContactChipsCtrl.contactImage]}}\"\\\n                  alt=\"{{item[$mdContactChipsCtrl.contactName]}}\" />\\\n              <span class=\"md-contact-name\" md-highlight-text=\"$mdContactChipsCtrl.searchText\">\\\n                {{item[$mdContactChipsCtrl.contactName]}}\\\n              </span>\\\n              <span class=\"md-contact-email\" >{{item[$mdContactChipsCtrl.contactEmail]}}</span>\\\n            </div>\\\n          </md-autocomplete>\\\n          <md-chip-template>\\\n            <div class=\"md-contact-avatar\">\\\n              <img \\\n                  ng-src=\"{{$chip[$mdContactChipsCtrl.contactImage]}}\"\\\n                  alt=\"{{$chip[$mdContactChipsCtrl.contactName]}}\" />\\\n            </div>\\\n            <div class=\"md-contact-name\">\\\n              {{$chip[$mdContactChipsCtrl.contactName]}}\\\n            </div>\\\n          </md-chip-template>\\\n      </md-chips>';\n\n\n  /**\n   * MDContactChips Directive Definition\n   *\n   * @param $mdTheming\n   * @returns {*}\n   * @ngInject\n   */\n  function MdContactChips ($mdTheming, $mdUtil) {\n    return {\n      template: function(element, attrs) {\n        return MD_CONTACT_CHIPS_TEMPLATE;\n      },\n      restrict: 'E',\n      controller: 'MdContactChipsCtrl',\n      controllerAs: '$mdContactChipsCtrl',\n      bindToController: true,\n      compile: compile,\n      scope: {\n        contactQuery: '&mdContacts',\n        placeholder: '@',\n        secondaryPlaceholder: '@',\n        contactName: '@mdContactName',\n        contactImage: '@mdContactImage',\n        contactEmail: '@mdContactEmail',\n        contacts: '=ngModel',\n        requireMatch: '=?mdRequireMatch'\n      }\n    };\n\n    function compile(element, attr) {\n      return function postLink(scope, element, attrs, controllers) {\n\n        $mdUtil.initOptionalProperties(scope, attr);\n        $mdTheming(element);\n\n        element.attr('tabindex', '-1');\n      };\n    }\n  }\n  MdContactChips.$inject = [\"$mdTheming\", \"$mdUtil\"];\n\n})();\n(function(){\n\"use strict\";\n\n/**\n * @ngdoc directive\n * @name mdTab\n * @module material.components.tabs\n *\n * @restrict E\n *\n * @description\n * Use the `<md-tab>` a nested directive used within `<md-tabs>` to specify a tab with a **label** and optional *view content*.\n *\n * If the `label` attribute is not specified, then an optional `<md-tab-label>` tag can be used to specify more\n * complex tab header markup. If neither the **label** nor the **md-tab-label** are specified, then the nested\n * markup of the `<md-tab>` is used as the tab header markup.\n *\n * Please note that if you use `<md-tab-label>`, your content **MUST** be wrapped in the `<md-tab-body>` tag.  This\n * is to define a clear separation between the tab content and the tab label.\n *\n * If a tab **label** has been identified, then any **non-**`<md-tab-label>` markup\n * will be considered tab content and will be transcluded to the internal `<div class=\"md-tabs-content\">` container.\n *\n * This container is used by the TabsController to show/hide the active tab's content view. This synchronization is\n * automatically managed by the internal TabsController whenever the tab selection changes. Selection changes can\n * be initiated via data binding changes, programmatic invocation, or user gestures.\n *\n * @param {string=} label Optional attribute to specify a simple string as the tab label\n * @param {boolean=} disabled If present, disabled tab selection.\n * @param {expression=} md-on-deselect Expression to be evaluated after the tab has been de-selected.\n * @param {expression=} md-on-select Expression to be evaluated after the tab has been selected.\n *\n *\n * @usage\n *\n * <hljs lang=\"html\">\n * <md-tab label=\"\" disabled=\"\" md-on-select=\"\" md-on-deselect=\"\" >\n *   <h3>My Tab content</h3>\n * </md-tab>\n *\n * <md-tab >\n *   <md-tab-label>\n *     <h3>My Tab content</h3>\n *   </md-tab-label>\n *   <md-tab-body>\n *     <p>\n *       Sed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium,\n *       totam rem aperiam, eaque ipsa quae ab illo inventore veritatis et quasi architecto beatae vitae\n *       dicta sunt explicabo. Nemo enim ipsam voluptatem quia voluptas sit aspernatur aut odit aut fugit,\n *       sed quia consequuntur magni dolores eos qui ratione voluptatem sequi nesciunt.\n *     </p>\n *   </md-tab-body>\n * </md-tab>\n * </hljs>\n *\n */\nangular\n    .module('material.components.tabs')\n    .directive('mdTab', MdTab);\n\nfunction MdTab () {\n  return {\n    require: '^?mdTabs',\n    terminal: true,\n    template: function (element, attr) {\n      var label = getLabel(),\n          body  = getTemplate();\n      return '' +\n          '<md-tab-label>' + label + '</md-tab-label>' +\n          '<md-tab-body>' + body + '</md-tab-body>';\n      function getLabel () {\n        return getLabelAttribute() || getLabelElement() || getElementContents();\n        function getLabelAttribute () { return attr.label; }\n        function getLabelElement () {\n          var label = element.find('md-tab-label');\n          if (label.length) return label.remove().html();\n        }\n        function getElementContents () {\n          var html = element.html();\n          element.empty();\n          return html;\n        }\n      }\n      function getTemplate () {\n        var content = element.find('md-tab-body'),\n            template = content.length ? content.html() : attr.label ? element.html() : '';\n        if (content.length) content.remove();\n        else if (attr.label) element.empty();\n        return template;\n      }\n    },\n    scope: {\n      active:   '=?mdActive',\n      disabled: '=?ngDisabled',\n      select:   '&?mdOnSelect',\n      deselect: '&?mdOnDeselect'\n    },\n    link: postLink\n  };\n\n  function postLink (scope, element, attr, ctrl) {\n    if (!ctrl) return;\n    var tabs = element.parent()[0].getElementsByTagName('md-tab'),\n        index = Array.prototype.indexOf.call(tabs, element[0]),\n        data = ctrl.insertTab({\n          scope:    scope,\n          parent:   scope.$parent,\n          index:    index,\n          element:  element,\n          template: element.find('md-tab-body').html(),\n          label:    element.find('md-tab-label').html()\n        }, index);\n\n    scope.select   = scope.select   || angular.noop;\n    scope.deselect = scope.deselect || angular.noop;\n\n    scope.$watch('active', function (active) { if (active) ctrl.select(data.getIndex()); });\n    scope.$watch('disabled', function () { ctrl.refreshIndex(); });\n    scope.$watch(\n        function () {\n          return Array.prototype.indexOf.call(tabs, element[0]);\n        },\n        function (newIndex) {\n          data.index = newIndex;\n          ctrl.updateTabOrder();\n        }\n    );\n    scope.$on('$destroy', function () { ctrl.removeTab(data); });\n\n  }\n}\n\n})();\n(function(){\n\"use strict\";\n\nangular\n    .module('material.components.tabs')\n    .directive('mdTabItem', MdTabItem);\n\nfunction MdTabItem () {\n  return {\n    require: '^?mdTabs',\n    link: function link (scope, element, attr, ctrl) {\n      if (!ctrl) return;\n      ctrl.attachRipple(scope, element);\n    }\n  };\n}\n\n})();\n(function(){\n\"use strict\";\n\nangular\n    .module('material.components.tabs')\n    .directive('mdTabLabel', MdTabLabel);\n\nfunction MdTabLabel () {\n  return { terminal: true };\n}\n\n\n})();\n(function(){\n\"use strict\";\n\nangular.module('material.components.tabs')\n    .directive('mdTabScroll', MdTabScroll);\n\nfunction MdTabScroll ($parse) {\n  return {\n    restrict: 'A',\n    compile: function ($element, attr) {\n      var fn = $parse(attr.mdTabScroll, null, true);\n      return function ngEventHandler (scope, element) {\n        element.on('mousewheel', function (event) {\n          scope.$apply(function () { fn(scope, { $event: event }); });\n        });\n      };\n    }\n  }\n}\nMdTabScroll.$inject = [\"$parse\"];\n\n})();\n(function(){\n\"use strict\";\n\nangular\n    .module('material.components.tabs')\n    .controller('MdTabsController', MdTabsController);\n\n/**\n * @ngInject\n */\nfunction MdTabsController ($scope, $element, $window, $timeout, $mdConstant, $mdTabInkRipple,\n                           $mdUtil, $animate) {\n  var ctrl     = this,\n      locked   = false,\n      elements = getElements(),\n      queue    = [];\n\n  ctrl.scope = $scope;\n  ctrl.parent = $scope.$parent;\n  ctrl.tabs = [];\n  ctrl.lastSelectedIndex = null;\n  ctrl.focusIndex = $scope.selectedIndex || 0;\n  ctrl.offsetLeft = 0;\n  ctrl.hasContent = false;\n  ctrl.hasFocus = false;\n  ctrl.lastClick = true;\n\n  ctrl.redirectFocus = redirectFocus;\n  ctrl.attachRipple = attachRipple;\n  ctrl.shouldStretchTabs = shouldStretchTabs;\n  ctrl.shouldPaginate = shouldPaginate;\n  ctrl.shouldCenterTabs = shouldCenterTabs;\n  ctrl.insertTab = insertTab;\n  ctrl.removeTab = removeTab;\n  ctrl.select = select;\n  ctrl.scroll = scroll;\n  ctrl.nextPage = nextPage;\n  ctrl.previousPage = previousPage;\n  ctrl.keydown = keydown;\n  ctrl.canPageForward = canPageForward;\n  ctrl.canPageBack = canPageBack;\n  ctrl.refreshIndex = refreshIndex;\n  ctrl.incrementSelectedIndex = incrementSelectedIndex;\n  ctrl.updateInkBarStyles = $mdUtil.debounce(updateInkBarStyles, 100);\n  ctrl.updateTabOrder = $mdUtil.debounce(updateTabOrder, 100);\n\n  init();\n\n  function init () {\n    $scope.$watch('selectedIndex', handleSelectedIndexChange);\n    $scope.$watch('$mdTabsCtrl.focusIndex', handleFocusIndexChange);\n    $scope.$watch('$mdTabsCtrl.offsetLeft', handleOffsetChange);\n    $scope.$watch('$mdTabsCtrl.hasContent', handleHasContent);\n    angular.element($window).on('resize', handleWindowResize);\n    angular.element(elements.paging).on('DOMSubtreeModified', ctrl.updateInkBarStyles);\n    $timeout(updateHeightFromContent, 0, false);\n    $timeout(adjustOffset);\n    $scope.$on('$destroy', cleanup);\n  }\n\n  function cleanup () {\n    angular.element($window).off('resize', handleWindowResize);\n    angular.element(elements.paging).off('DOMSubtreeModified', ctrl.updateInkBarStyles);\n  }\n\n  //-- Change handlers\n\n  function handleHasContent (hasContent) {\n    $element[hasContent ? 'removeClass' : 'addClass']('md-no-tab-content');\n  }\n\n  function handleOffsetChange (left) {\n    var newValue = shouldCenterTabs() ? '' : '-' + left + 'px';\n    angular.element(elements.paging).css('transform', 'translate3d(' + newValue + ', 0, 0)');\n    $scope.$broadcast('$mdTabsPaginationChanged');\n  }\n\n  function handleFocusIndexChange (newIndex, oldIndex) {\n    if (newIndex === oldIndex) return;\n    if (!elements.tabs[newIndex]) return;\n    adjustOffset();\n    redirectFocus();\n  }\n\n  function handleSelectedIndexChange (newValue, oldValue) {\n    if (newValue === oldValue) return;\n\n    $scope.selectedIndex = getNearestSafeIndex(newValue);\n    ctrl.lastSelectedIndex = oldValue;\n    ctrl.updateInkBarStyles();\n    updateHeightFromContent();\n    $scope.$broadcast('$mdTabsChanged');\n    ctrl.tabs[oldValue] && ctrl.tabs[oldValue].scope.deselect();\n    ctrl.tabs[newValue] && ctrl.tabs[newValue].scope.select();\n  }\n\n  function handleResizeWhenVisible () {\n    //-- if there is already a watcher waiting for resize, do nothing\n    if (handleResizeWhenVisible.watcher) return;\n    //-- otherwise, we will abuse the $watch function to check for visible\n    handleResizeWhenVisible.watcher = $scope.$watch(function () {\n      //-- since we are checking for DOM size, we use $timeout to wait for after the DOM updates\n      $timeout(function () {\n        //-- if the watcher has already run (ie. multiple digests in one cycle), do nothing\n        if (!handleResizeWhenVisible.watcher) return;\n\n        if ($element.prop('offsetParent')) {\n          handleResizeWhenVisible.watcher();\n          handleResizeWhenVisible.watcher = null;\n\n          //-- we have to trigger our own $apply so that the DOM bindings will update\n          handleWindowResize();\n        }\n      }, 0, false);\n    });\n  }\n\n  //-- Event handlers / actions\n\n  function keydown (event) {\n    switch (event.keyCode) {\n      case $mdConstant.KEY_CODE.LEFT_ARROW:\n        event.preventDefault();\n        incrementSelectedIndex(-1, true);\n        break;\n      case $mdConstant.KEY_CODE.RIGHT_ARROW:\n        event.preventDefault();\n        incrementSelectedIndex(1, true);\n        break;\n      case $mdConstant.KEY_CODE.SPACE:\n      case $mdConstant.KEY_CODE.ENTER:\n        event.preventDefault();\n        if (!locked) $scope.selectedIndex = ctrl.focusIndex;\n        break;\n    }\n    ctrl.lastClick = false;\n  }\n\n  function select (index) {\n    if (!locked) ctrl.focusIndex = $scope.selectedIndex = index;\n    ctrl.lastClick = true;\n    ctrl.tabs[index].element.triggerHandler('click');\n  }\n\n  function scroll (event) {\n    if (!shouldPaginate()) return;\n    event.preventDefault();\n    ctrl.offsetLeft = fixOffset(ctrl.offsetLeft - event.wheelDelta);\n  }\n\n  function nextPage () {\n    var viewportWidth = elements.canvas.clientWidth,\n        totalWidth = viewportWidth + ctrl.offsetLeft,\n        i, tab;\n    for (i = 0; i < elements.tabs.length; i++) {\n      tab = elements.tabs[i];\n      if (tab.offsetLeft + tab.offsetWidth > totalWidth) break;\n    }\n    ctrl.offsetLeft = fixOffset(tab.offsetLeft);\n  }\n\n  function previousPage () {\n    var i, tab;\n    for (i = 0; i < elements.tabs.length; i++) {\n      tab = elements.tabs[i];\n      if (tab.offsetLeft + tab.offsetWidth >= ctrl.offsetLeft) break;\n    }\n    ctrl.offsetLeft = fixOffset(tab.offsetLeft + tab.offsetWidth - elements.canvas.clientWidth);\n  }\n\n  function handleWindowResize () {\n    $scope.$apply(function () {\n      ctrl.lastSelectedIndex = $scope.selectedIndex;\n      ctrl.offsetLeft = fixOffset(ctrl.offsetLeft);\n      $timeout(ctrl.updateInkBarStyles, 0, false);\n    });\n  }\n\n  function removeTab (tabData) {\n    var selectedIndex = $scope.selectedIndex,\n        tab = ctrl.tabs.splice(tabData.getIndex(), 1)[0];\n    refreshIndex();\n    //-- when removing a tab, if the selected index did not change, we have to manually trigger the\n    //   tab select/deselect events\n    if ($scope.selectedIndex === selectedIndex) {\n      tab.scope.deselect();\n      ctrl.tabs[$scope.selectedIndex] && ctrl.tabs[$scope.selectedIndex].scope.select();\n    }\n    $timeout(function () {\n      ctrl.offsetLeft = fixOffset(ctrl.offsetLeft);\n    });\n  }\n\n  function insertTab (tabData, index) {\n    var proto = {\n          getIndex: function () { return ctrl.tabs.indexOf(tab); },\n          isActive: function () { return this.getIndex() === $scope.selectedIndex; },\n          isLeft:   function () { return this.getIndex() < $scope.selectedIndex; },\n          isRight:  function () { return this.getIndex() > $scope.selectedIndex; },\n          hasFocus: function () { return !ctrl.lastClick && ctrl.hasFocus && this.getIndex() === ctrl.focusIndex; },\n          id:       $mdUtil.nextUid()\n        },\n        tab = angular.extend(proto, tabData);\n    if (angular.isDefined(index)) {\n      ctrl.tabs.splice(index, 0, tab);\n    } else {\n      ctrl.tabs.push(tab);\n    }\n    processQueue();\n    updateHasContent();\n    return tab;\n  }\n\n  //-- Getter methods\n\n  function getElements () {\n    var elements      = {};\n\n    //-- gather tab bar elements\n    elements.wrapper  = $element[0].getElementsByTagName('md-tabs-wrapper')[0];\n    elements.canvas   = elements.wrapper.getElementsByTagName('md-tabs-canvas')[0];\n    elements.paging   = elements.canvas.getElementsByTagName('md-pagination-wrapper')[0];\n    elements.tabs     = elements.paging.getElementsByTagName('md-tab-item');\n    elements.dummies  = elements.canvas.getElementsByTagName('md-dummy-tab');\n    elements.inkBar   = elements.paging.getElementsByTagName('md-ink-bar')[0];\n\n    //-- gather tab content elements\n    elements.contentsWrapper = $element[0].getElementsByTagName('md-tabs-content-wrapper')[0];\n    elements.contents = elements.contentsWrapper.getElementsByTagName('md-tab-content');\n\n    return elements;\n  }\n\n  function canPageBack () {\n    return ctrl.offsetLeft > 0;\n  }\n\n  function canPageForward () {\n    var lastTab = elements.tabs[elements.tabs.length - 1];\n    return lastTab && lastTab.offsetLeft + lastTab.offsetWidth > elements.canvas.clientWidth + ctrl.offsetLeft;\n  }\n\n  function shouldStretchTabs () {\n    switch ($scope.stretchTabs) {\n      case 'always': return true;\n      case 'never':  return false;\n      default:       return !shouldPaginate() && $window.matchMedia('(max-width: 600px)').matches;\n    }\n  }\n\n  function shouldCenterTabs () {\n    return $scope.centerTabs && !shouldPaginate();\n  }\n\n  function shouldPaginate () {\n    if ($scope.noPagination) return false;\n    var canvasWidth = $element.prop('clientWidth');\n    angular.forEach(elements.tabs, function (tab) { canvasWidth -= tab.offsetWidth; });\n    return canvasWidth < 0;\n  }\n\n  function getNearestSafeIndex(newIndex) {\n    var maxOffset = Math.max(ctrl.tabs.length - newIndex, newIndex),\n        i, tab;\n    for (i = 0; i <= maxOffset; i++) {\n      tab = ctrl.tabs[newIndex + i];\n      if (tab && (tab.scope.disabled !== true)) return tab.getIndex();\n      tab = ctrl.tabs[newIndex - i];\n      if (tab && (tab.scope.disabled !== true)) return tab.getIndex();\n    }\n    return newIndex;\n  }\n\n  //-- Utility methods\n\n  function updateTabOrder () {\n    var selectedItem = ctrl.tabs[$scope.selectedIndex],\n        focusItem = ctrl.tabs[ctrl.focusIndex];\n    ctrl.tabs = ctrl.tabs.sort(function (a, b) {\n      return a.index - b.index;\n    });\n    $scope.selectedIndex = ctrl.tabs.indexOf(selectedItem);\n    ctrl.focusIndex = ctrl.tabs.indexOf(focusItem);\n  }\n\n  function incrementSelectedIndex (inc, focus) {\n    var newIndex,\n        index = focus ? ctrl.focusIndex : $scope.selectedIndex;\n    for (newIndex = index + inc;\n         ctrl.tabs[newIndex] && ctrl.tabs[newIndex].scope.disabled;\n         newIndex += inc) {}\n    if (ctrl.tabs[newIndex]) {\n      if (focus) ctrl.focusIndex = newIndex;\n      else $scope.selectedIndex = newIndex;\n    }\n  }\n\n  function redirectFocus () {\n    elements.dummies[ctrl.focusIndex].focus();\n  }\n\n  function adjustOffset () {\n    if (shouldCenterTabs()) return;\n    var tab = elements.tabs[ctrl.focusIndex],\n        left = tab.offsetLeft,\n        right = tab.offsetWidth + left;\n    ctrl.offsetLeft = Math.max(ctrl.offsetLeft, fixOffset(right - elements.canvas.clientWidth));\n    ctrl.offsetLeft = Math.min(ctrl.offsetLeft, fixOffset(left));\n  }\n\n  function processQueue () {\n    queue.forEach(function (func) { $timeout(func); });\n    queue = [];\n  }\n\n  function updateHasContent () {\n    var hasContent = false;\n    angular.forEach(ctrl.tabs, function (tab) {\n      if (tab.template) hasContent = true;\n    });\n    ctrl.hasContent = hasContent;\n  }\n\n  function refreshIndex () {\n    $scope.selectedIndex = getNearestSafeIndex($scope.selectedIndex);\n    ctrl.focusIndex = getNearestSafeIndex(ctrl.focusIndex);\n  }\n\n  function updateHeightFromContent () {\n    if (!$scope.dynamicHeight) return $element.css('height', '');\n    if (!ctrl.tabs.length) return queue.push(updateHeightFromContent);\n    var tabContent    = elements.contents[$scope.selectedIndex],\n        contentHeight = tabContent ? tabContent.offsetHeight : 0,\n        tabsHeight    = elements.wrapper.offsetHeight,\n        newHeight     = contentHeight + tabsHeight,\n        currentHeight = $element.prop('clientHeight');\n    if (currentHeight === newHeight) return;\n    locked = true;\n    $animate\n        .animate(\n          $element,\n          { height: currentHeight + 'px' },\n          { height: newHeight + 'px'}\n        )\n        .then(function () {\n          $element.css('height', '');\n          locked = false;\n        });\n  }\n\n  function updateInkBarStyles () {\n    if (!elements.tabs[$scope.selectedIndex]) return;\n    if (!ctrl.tabs.length) return queue.push(ctrl.updateInkBarStyles);\n    //-- if the element is not visible, we will not be able to calculate sizes until it is\n    //-- we should treat that as a resize event rather than just updating the ink bar\n    if (!$element.prop('offsetParent')) return handleResizeWhenVisible();\n    var index = $scope.selectedIndex,\n        totalWidth = elements.paging.offsetWidth,\n        tab = elements.tabs[index],\n        left = tab.offsetLeft,\n        right = totalWidth - left - tab.offsetWidth;\n    updateInkBarClassName();\n    angular.element(elements.inkBar).css({ left: left + 'px', right: right + 'px' });\n  }\n\n  function updateInkBarClassName () {\n    var newIndex = $scope.selectedIndex,\n        oldIndex = ctrl.lastSelectedIndex,\n        ink = angular.element(elements.inkBar);\n    ink.removeClass('md-left md-right');\n    if (!angular.isNumber(oldIndex)) return;\n    if (newIndex < oldIndex) {\n      ink.addClass('md-left');\n    } else if (newIndex > oldIndex) {\n      ink.addClass('md-right');\n    }\n  }\n\n  function fixOffset (value) {\n    if (!elements.tabs.length || !shouldPaginate()) return 0;\n    var lastTab = elements.tabs[elements.tabs.length - 1],\n        totalWidth = lastTab.offsetLeft + lastTab.offsetWidth;\n    value = Math.max(0, value);\n    value = Math.min(totalWidth - elements.canvas.clientWidth, value);\n    return value;\n  }\n\n  function attachRipple (scope, element) {\n    var options = { colorElement: angular.element(elements.inkBar) };\n    $mdTabInkRipple.attach(scope, element, options);\n  }\n}\nMdTabsController.$inject = [\"$scope\", \"$element\", \"$window\", \"$timeout\", \"$mdConstant\", \"$mdTabInkRipple\", \"$mdUtil\", \"$animate\"];\n\n})();\n(function(){\n\"use strict\";\n\n/**\n * @ngdoc directive\n * @name mdTabs\n * @module material.components.tabs\n *\n * @restrict E\n *\n * @description\n * The `<md-tabs>` directive serves as the container for 1..n `<md-tab>` child directives to produces a Tabs components.\n * In turn, the nested `<md-tab>` directive is used to specify a tab label for the **header button** and a [optional] tab view\n * content that will be associated with each tab button.\n *\n * Below is the markup for its simplest usage:\n *\n *  <hljs lang=\"html\">\n *  <md-tabs>\n *    <md-tab label=\"Tab #1\"></md-tab>\n *    <md-tab label=\"Tab #2\"></md-tab>\n *    <md-tab label=\"Tab #3\"></md-tab>\n *  </md-tabs>\n *  </hljs>\n *\n * Tabs supports three (3) usage scenarios:\n *\n *  1. Tabs (buttons only)\n *  2. Tabs with internal view content\n *  3. Tabs with external view content\n *\n * **Tab-only** support is useful when tab buttons are used for custom navigation regardless of any other components, content, or views.\n * **Tabs with internal views** are the traditional usages where each tab has associated view content and the view switching is managed internally by the Tabs component.\n * **Tabs with external view content** is often useful when content associated with each tab is independently managed and data-binding notifications announce tab selection changes.\n *\n * Additional features also include:\n *\n * *  Content can include any markup.\n * *  If a tab is disabled while active/selected, then the next tab will be auto-selected.\n *\n * ### Explanation of tab stretching\n *\n * Initially, tabs will have an inherent size.  This size will either be defined by how much space is needed to accommodate their text or set by the user through CSS.  Calculations will be based on this size.\n *\n * On mobile devices, tabs will be expanded to fill the available horizontal space.  When this happens, all tabs will become the same size.\n *\n * On desktops, by default, stretching will never occur.\n *\n * This default behavior can be overridden through the `md-stretch-tabs` attribute.  Here is a table showing when stretching will occur:\n *\n * `md-stretch-tabs` | mobile    | desktop\n * ------------------|-----------|--------\n * `auto`            | stretched | ---\n * `always`          | stretched | stretched\n * `never`           | ---       | ---\n *\n * @param {integer=} md-selected Index of the active/selected tab\n * @param {boolean=} md-no-ink If present, disables ink ripple effects.\n * @param {boolean=} md-no-bar If present, disables the selection ink bar.\n * @param {string=}  md-align-tabs Attribute to indicate position of tab buttons: `bottom` or `top`; default is `top`\n * @param {string=} md-stretch-tabs Attribute to indicate whether or not to stretch tabs: `auto`, `always`, or `never`; default is `auto`\n * @param {boolean=} md-dynamic-height When enabled, the tab wrapper will resize based on the contents of the selected tab\n * @param {boolean=} md-center-tabs When enabled, tabs will be centered provided there is no need for pagination\n * @param {boolean=} md-no-pagination When enabled, pagination will remain off\n *\n * @usage\n * <hljs lang=\"html\">\n * <md-tabs md-selected=\"selectedIndex\" >\n *   <img ng-src=\"img/angular.png\" class=\"centered\">\n *   <md-tab\n *       ng-repeat=\"tab in tabs | orderBy:predicate:reversed\"\n *       md-on-select=\"onTabSelected(tab)\"\n *       md-on-deselect=\"announceDeselected(tab)\"\n *       ng-disabled=\"tab.disabled\">\n *     <md-tab-label>\n *       {{tab.title}}\n *       <img src=\"img/removeTab.png\" ng-click=\"removeTab(tab)\" class=\"delete\">\n *     </md-tab-label>\n *     <md-tab-body>\n *       {{tab.content}}\n *     </md-tab-body>\n *   </md-tab>\n * </md-tabs>\n * </hljs>\n *\n */\nangular\n    .module('material.components.tabs')\n    .directive('mdTabs', MdTabs);\n\nfunction MdTabs ($mdTheming, $mdUtil, $compile) {\n  return {\n    scope: {\n      noPagination:  '=?mdNoPagination',\n      dynamicHeight: '=?mdDynamicHeight',\n      centerTabs:    '=?mdCenterTabs',\n      selectedIndex: '=?mdSelected',\n      stretchTabs:   '@?mdStretchTabs'\n    },\n    template: function (element, attr) {\n      attr[\"$mdTabsTemplate\"] = element.html();\n      return '\\\n        <md-tabs-wrapper ng-class=\"{ \\'md-stretch-tabs\\': $mdTabsCtrl.shouldStretchTabs() }\">\\\n          <md-tab-data></md-tab-data>\\\n          <md-prev-button\\\n              tabindex=\"-1\"\\\n              role=\"button\"\\\n              aria-label=\"Previous Page\"\\\n              aria-disabled=\"{{!$mdTabsCtrl.canPageBack()}}\"\\\n              ng-class=\"{ \\'md-disabled\\': !$mdTabsCtrl.canPageBack() }\"\\\n              ng-if=\"$mdTabsCtrl.shouldPaginate()\"\\\n              ng-click=\"$mdTabsCtrl.previousPage()\">\\\n            <md-icon md-svg-icon=\"md-tabs-arrow\"></md-icon>\\\n          </md-prev-button>\\\n          <md-next-button\\\n              tabindex=\"-1\"\\\n              role=\"button\"\\\n              aria-label=\"Next Page\"\\\n              aria-disabled=\"{{!$mdTabsCtrl.canPageForward()}}\"\\\n              ng-class=\"{ \\'md-disabled\\': !$mdTabsCtrl.canPageForward() }\"\\\n              ng-if=\"$mdTabsCtrl.shouldPaginate()\"\\\n              ng-click=\"$mdTabsCtrl.nextPage()\">\\\n            <md-icon md-svg-icon=\"md-tabs-arrow\"></md-icon>\\\n          </md-next-button>\\\n          <md-tabs-canvas\\\n              tabindex=\"0\"\\\n              aria-activedescendant=\"tab-item-{{$mdTabsCtrl.tabs[$mdTabsCtrl.focusIndex].id}}\"\\\n              ng-focus=\"$mdTabsCtrl.redirectFocus()\"\\\n              ng-class=\"{\\\n                  \\'md-paginated\\': $mdTabsCtrl.shouldPaginate(),\\\n                  \\'md-center-tabs\\': $mdTabsCtrl.shouldCenterTabs()\\\n              }\"\\\n              ng-keydown=\"$mdTabsCtrl.keydown($event)\"\\\n              role=\"tablist\">\\\n            <md-pagination-wrapper\\\n                ng-class=\"{ \\'md-center-tabs\\': $mdTabsCtrl.shouldCenterTabs() }\"\\\n                md-tab-scroll=\"$mdTabsCtrl.scroll($event)\">\\\n              <md-tab-item\\\n                  tabindex=\"-1\"\\\n                  class=\"md-tab\"\\\n                  style=\"max-width: {{ tabWidth ? tabWidth + \\'px\\' : \\'none\\' }}\"\\\n                  ng-repeat=\"tab in $mdTabsCtrl.tabs\"\\\n                  role=\"tab\"\\\n                  aria-controls=\"tab-content-{{tab.id}}\"\\\n                  aria-selected=\"{{tab.isActive()}}\"\\\n                  aria-disabled=\"{{tab.scope.disabled || \\'false\\'}}\"\\\n                  ng-click=\"$mdTabsCtrl.select(tab.getIndex())\"\\\n                  ng-class=\"{\\\n                      \\'md-active\\':    tab.isActive(),\\\n                      \\'md-focused\\':   tab.hasFocus(),\\\n                      \\'md-disabled\\':  tab.scope.disabled\\\n                  }\"\\\n                  ng-disabled=\"tab.scope.disabled\"\\\n                  md-swipe-left=\"$mdTabsCtrl.nextPage()\"\\\n                  md-swipe-right=\"$mdTabsCtrl.previousPage()\"\\\n                  md-template=\"tab.label\"\\\n                  md-scope=\"tab.parent\"></md-tab-item>\\\n              <md-ink-bar ng-hide=\"noInkBar\"></md-ink-bar>\\\n            </md-pagination-wrapper>\\\n            <div class=\"md-visually-hidden md-dummy-wrapper\">\\\n              <md-dummy-tab\\\n                  tabindex=\"-1\"\\\n                  id=\"tab-item-{{tab.id}}\"\\\n                  role=\"tab\"\\\n                  aria-controls=\"tab-content-{{tab.id}}\"\\\n                  aria-selected=\"{{tab.isActive()}}\"\\\n                  aria-disabled=\"{{tab.scope.disabled || \\'false\\'}}\"\\\n                  ng-focus=\"$mdTabsCtrl.hasFocus = true\"\\\n                  ng-blur=\"$mdTabsCtrl.hasFocus = false\"\\\n                  ng-repeat=\"tab in $mdTabsCtrl.tabs\"\\\n                  md-template=\"tab.label\"\\\n                  md-scope=\"tab.parent\"></md-dummy-tab>\\\n            </div>\\\n          </md-tabs-canvas>\\\n        </md-tabs-wrapper>\\\n        <md-tabs-content-wrapper ng-show=\"$mdTabsCtrl.hasContent\">\\\n          <md-tab-content\\\n              id=\"tab-content-{{tab.id}}\"\\\n              role=\"tabpanel\"\\\n              aria-labelledby=\"tab-item-{{tab.id}}\"\\\n              md-swipe-left=\"$mdTabsCtrl.incrementSelectedIndex(1)\"\\\n              md-swipe-right=\"$mdTabsCtrl.incrementSelectedIndex(-1)\"\\\n              ng-if=\"$mdTabsCtrl.hasContent\"\\\n              ng-repeat=\"(index, tab) in $mdTabsCtrl.tabs\" \\\n              md-template=\"tab.template\"\\\n              md-scope=\"tab.parent\"\\\n              md-connected-if=\"tab.isActive()\"\\\n              ng-class=\"{\\\n                \\'md-no-transition\\': $mdTabsCtrl.lastSelectedIndex == null,\\\n                \\'md-active\\':        tab.isActive(),\\\n                \\'md-left\\':          tab.isLeft(),\\\n                \\'md-right\\':         tab.isRight(),\\\n                \\'md-no-scroll\\':     dynamicHeight\\\n              }\"></md-tab-content>\\\n        </md-tabs-content-wrapper>\\\n      ';\n    },\n    controller: 'MdTabsController',\n    controllerAs: '$mdTabsCtrl',\n    link: function (scope, element, attr) {\n      compileTabData(attr.$mdTabsTemplate);\n      delete attr.$mdTabsTemplate;\n\n      $mdUtil.initOptionalProperties(scope, attr);\n\n      //-- watch attributes\n      attr.$observe('mdNoBar', function (value) { scope.noInkBar = angular.isDefined(value); });\n      //-- set default value for selectedIndex\n      scope.selectedIndex = angular.isNumber(scope.selectedIndex) ? scope.selectedIndex : 0;\n      //-- apply themes\n      $mdTheming(element);\n\n      function compileTabData (template) {\n        var dataElement = element.find('md-tab-data');\n        dataElement.html(template);\n        $compile(dataElement.contents())(scope.$parent);\n      }\n    }\n  };\n}\nMdTabs.$inject = [\"$mdTheming\", \"$mdUtil\", \"$compile\"];\n\n})();\n(function(){\n\"use strict\";\n\nangular\n    .module('material.components.tabs')\n    .directive('mdTemplate', MdTemplate);\n\nfunction MdTemplate ($compile, $mdUtil, $timeout) {\n  return {\n    restrict: 'A',\n    link: link,\n    scope: {\n      template: '=mdTemplate',\n      compileScope: '=mdScope',\n      connected: '=?mdConnectedIf'\n    },\n    require: '^?mdTabs'\n  };\n  function link (scope, element, attr, ctrl) {\n    if (!ctrl) return;\n    var compileScope = scope.compileScope.$new();\n    element.html(scope.template);\n    $compile(element.contents())(compileScope);\n    return $timeout(handleScope);\n    function handleScope () {\n      scope.$watch('connected', function (value) { value === false ? disconnect() : reconnect(); });\n      scope.$on('$destroy', reconnect);\n    }\n    function disconnect () {\n      $mdUtil.disconnectScope(compileScope);\n    }\n    function reconnect () {\n      $mdUtil.reconnectScope(compileScope);\n    }\n  }\n}\nMdTemplate.$inject = [\"$compile\", \"$mdUtil\", \"$timeout\"];\n\n})();\n(function(){ \nangular.module(\"material.core\").constant(\"$MD_THEME_CSS\", \"/* mixin definition ; sets LTR and RTL within the same style call */md-autocomplete.md-THEME_NAME-theme {  background: '{{background-50}}'; }  md-autocomplete.md-THEME_NAME-theme button md-icon path {    fill: '{{background-600}}'; }  md-autocomplete.md-THEME_NAME-theme button:after {    background: '{{background-600-0.3}}'; }.md-autocomplete-suggestions.md-THEME_NAME-theme {  background: '{{background-50}}'; }  .md-autocomplete-suggestions.md-THEME_NAME-theme li {    color: '{{background-900}}'; }    .md-autocomplete-suggestions.md-THEME_NAME-theme li .highlight {      color: '{{background-600}}'; }    .md-autocomplete-suggestions.md-THEME_NAME-theme li:hover, .md-autocomplete-suggestions.md-THEME_NAME-theme li.selected {      background: '{{background-200}}'; }md-backdrop.md-opaque.md-THEME_NAME-theme {  background-color: '{{foreground-4-0.5}}'; }md-bottom-sheet.md-THEME_NAME-theme {  background-color: '{{background-50}}';  border-top-color: '{{background-300}}'; }  md-bottom-sheet.md-THEME_NAME-theme.md-list md-list-item {    color: '{{foreground-1}}'; }  md-bottom-sheet.md-THEME_NAME-theme .md-subheader {    background-color: '{{background-50}}'; }  md-bottom-sheet.md-THEME_NAME-theme .md-subheader {    color: '{{foreground-1}}'; }a.md-button.md-THEME_NAME-theme, .md-button.md-THEME_NAME-theme {  border-radius: 3px; }  a.md-button.md-THEME_NAME-theme:not([disabled]):hover, .md-button.md-THEME_NAME-theme:not([disabled]):hover {    background-color: '{{background-500-0.2}}'; }  a.md-button.md-THEME_NAME-theme:not([disabled]).md-focused, .md-button.md-THEME_NAME-theme:not([disabled]).md-focused {    background-color: '{{background-500-0.2}}'; }  a.md-button.md-THEME_NAME-theme:not([disabled]).md-icon-button:hover, .md-button.md-THEME_NAME-theme:not([disabled]).md-icon-button:hover {    background-color: transparent; }  a.md-button.md-THEME_NAME-theme.md-fab, .md-button.md-THEME_NAME-theme.md-fab {    border-radius: 50%;    background-color: '{{accent-color}}';    color: '{{accent-contrast}}'; }    a.md-button.md-THEME_NAME-theme.md-fab md-icon, .md-button.md-THEME_NAME-theme.md-fab md-icon {      color: '{{accent-contrast}}'; }    a.md-button.md-THEME_NAME-theme.md-fab:not([disabled]):hover, .md-button.md-THEME_NAME-theme.md-fab:not([disabled]):hover {      background-color: '{{accent-color}}'; }    a.md-button.md-THEME_NAME-theme.md-fab:not([disabled]).md-focused, .md-button.md-THEME_NAME-theme.md-fab:not([disabled]).md-focused {      background-color: '{{accent-A700}}'; }  a.md-button.md-THEME_NAME-theme.md-icon-button, .md-button.md-THEME_NAME-theme.md-icon-button {    border-radius: 50%; }  a.md-button.md-THEME_NAME-theme.md-primary, .md-button.md-THEME_NAME-theme.md-primary {    color: '{{primary-color}}'; }    a.md-button.md-THEME_NAME-theme.md-primary.md-raised, a.md-button.md-THEME_NAME-theme.md-primary.md-fab, .md-button.md-THEME_NAME-theme.md-primary.md-raised, .md-button.md-THEME_NAME-theme.md-primary.md-fab {      color: '{{primary-contrast}}';      background-color: '{{primary-color}}'; }      a.md-button.md-THEME_NAME-theme.md-primary.md-raised:not([disabled]) md-icon, a.md-button.md-THEME_NAME-theme.md-primary.md-fab:not([disabled]) md-icon, .md-button.md-THEME_NAME-theme.md-primary.md-raised:not([disabled]) md-icon, .md-button.md-THEME_NAME-theme.md-primary.md-fab:not([disabled]) md-icon {        color: '{{primary-contrast}}'; }      a.md-button.md-THEME_NAME-theme.md-primary.md-raised:not([disabled]):hover, a.md-button.md-THEME_NAME-theme.md-primary.md-fab:not([disabled]):hover, .md-button.md-THEME_NAME-theme.md-primary.md-raised:not([disabled]):hover, .md-button.md-THEME_NAME-theme.md-primary.md-fab:not([disabled]):hover {        background-color: '{{primary-color}}'; }      a.md-button.md-THEME_NAME-theme.md-primary.md-raised:not([disabled]).md-focused, a.md-button.md-THEME_NAME-theme.md-primary.md-fab:not([disabled]).md-focused, .md-button.md-THEME_NAME-theme.md-primary.md-raised:not([disabled]).md-focused, .md-button.md-THEME_NAME-theme.md-primary.md-fab:not([disabled]).md-focused {        background-color: '{{primary-600}}'; }    a.md-button.md-THEME_NAME-theme.md-primary:not([disabled]) md-icon, .md-button.md-THEME_NAME-theme.md-primary:not([disabled]) md-icon {      color: '{{primary-color}}'; }  a.md-button.md-THEME_NAME-theme.md-fab, .md-button.md-THEME_NAME-theme.md-fab {    border-radius: 50%;    background-color: '{{accent-color}}';    color: '{{accent-contrast}}'; }    a.md-button.md-THEME_NAME-theme.md-fab:not([disabled]) .md-icon, .md-button.md-THEME_NAME-theme.md-fab:not([disabled]) .md-icon {      color: '{{accent-contrast}}'; }    a.md-button.md-THEME_NAME-theme.md-fab:not([disabled]):hover, .md-button.md-THEME_NAME-theme.md-fab:not([disabled]):hover {      background-color: '{{accent-color}}'; }    a.md-button.md-THEME_NAME-theme.md-fab:not([disabled]).md-focused, .md-button.md-THEME_NAME-theme.md-fab:not([disabled]).md-focused {      background-color: '{{accent-A700}}'; }  a.md-button.md-THEME_NAME-theme.md-raised, .md-button.md-THEME_NAME-theme.md-raised {    color: '{{background-contrast}}';    background-color: '{{background-50}}'; }    a.md-button.md-THEME_NAME-theme.md-raised:not([disabled]) .md-icon, .md-button.md-THEME_NAME-theme.md-raised:not([disabled]) .md-icon {      color: '{{background-contrast}}'; }    a.md-button.md-THEME_NAME-theme.md-raised:not([disabled]):hover, .md-button.md-THEME_NAME-theme.md-raised:not([disabled]):hover {      background-color: '{{background-50}}'; }    a.md-button.md-THEME_NAME-theme.md-raised:not([disabled]).md-focused, .md-button.md-THEME_NAME-theme.md-raised:not([disabled]).md-focused {      background-color: '{{background-200}}'; }  a.md-button.md-THEME_NAME-theme.md-warn, .md-button.md-THEME_NAME-theme.md-warn {    color: '{{warn-color}}'; }    a.md-button.md-THEME_NAME-theme.md-warn.md-raised, a.md-button.md-THEME_NAME-theme.md-warn.md-fab, .md-button.md-THEME_NAME-theme.md-warn.md-raised, .md-button.md-THEME_NAME-theme.md-warn.md-fab {      color: '{{warn-contrast}}';      background-color: '{{warn-color}}'; }      a.md-button.md-THEME_NAME-theme.md-warn.md-raised:not([disabled]) md-icon, a.md-button.md-THEME_NAME-theme.md-warn.md-fab:not([disabled]) md-icon, .md-button.md-THEME_NAME-theme.md-warn.md-raised:not([disabled]) md-icon, .md-button.md-THEME_NAME-theme.md-warn.md-fab:not([disabled]) md-icon {        color: '{{warn-contrast}}'; }      a.md-button.md-THEME_NAME-theme.md-warn.md-raised:not([disabled]):hover, a.md-button.md-THEME_NAME-theme.md-warn.md-fab:not([disabled]):hover, .md-button.md-THEME_NAME-theme.md-warn.md-raised:not([disabled]):hover, .md-button.md-THEME_NAME-theme.md-warn.md-fab:not([disabled]):hover {        background-color: '{{warn-color}}'; }      a.md-button.md-THEME_NAME-theme.md-warn.md-raised:not([disabled]).md-focused, a.md-button.md-THEME_NAME-theme.md-warn.md-fab:not([disabled]).md-focused, .md-button.md-THEME_NAME-theme.md-warn.md-raised:not([disabled]).md-focused, .md-button.md-THEME_NAME-theme.md-warn.md-fab:not([disabled]).md-focused {        background-color: '{{warn-700}}'; }    a.md-button.md-THEME_NAME-theme.md-warn:not([disabled]) md-icon, .md-button.md-THEME_NAME-theme.md-warn:not([disabled]) md-icon {      color: '{{warn-color}}'; }  a.md-button.md-THEME_NAME-theme.md-accent, .md-button.md-THEME_NAME-theme.md-accent {    color: '{{accent-color}}'; }    a.md-button.md-THEME_NAME-theme.md-accent.md-raised, a.md-button.md-THEME_NAME-theme.md-accent.md-fab, .md-button.md-THEME_NAME-theme.md-accent.md-raised, .md-button.md-THEME_NAME-theme.md-accent.md-fab {      color: '{{accent-contrast}}';      background-color: '{{accent-color}}'; }      a.md-button.md-THEME_NAME-theme.md-accent.md-raised:not([disabled]) md-icon, a.md-button.md-THEME_NAME-theme.md-accent.md-fab:not([disabled]) md-icon, .md-button.md-THEME_NAME-theme.md-accent.md-raised:not([disabled]) md-icon, .md-button.md-THEME_NAME-theme.md-accent.md-fab:not([disabled]) md-icon {        color: '{{accent-contrast}}'; }      a.md-button.md-THEME_NAME-theme.md-accent.md-raised:not([disabled]):hover, a.md-button.md-THEME_NAME-theme.md-accent.md-fab:not([disabled]):hover, .md-button.md-THEME_NAME-theme.md-accent.md-raised:not([disabled]):hover, .md-button.md-THEME_NAME-theme.md-accent.md-fab:not([disabled]):hover {        background-color: '{{accent-color}}'; }      a.md-button.md-THEME_NAME-theme.md-accent.md-raised:not([disabled]).md-focused, a.md-button.md-THEME_NAME-theme.md-accent.md-fab:not([disabled]).md-focused, .md-button.md-THEME_NAME-theme.md-accent.md-raised:not([disabled]).md-focused, .md-button.md-THEME_NAME-theme.md-accent.md-fab:not([disabled]).md-focused {        background-color: '{{accent-700}}'; }    a.md-button.md-THEME_NAME-theme.md-accent:not([disabled]) md-icon, .md-button.md-THEME_NAME-theme.md-accent:not([disabled]) md-icon {      color: '{{accent-color}}'; }  a.md-button.md-THEME_NAME-theme[disabled], a.md-button.md-THEME_NAME-theme.md-raised[disabled], a.md-button.md-THEME_NAME-theme.md-fab[disabled], a.md-button.md-THEME_NAME-theme.md-accent[disabled], a.md-button.md-THEME_NAME-theme.md-warn[disabled], .md-button.md-THEME_NAME-theme[disabled], .md-button.md-THEME_NAME-theme.md-raised[disabled], .md-button.md-THEME_NAME-theme.md-fab[disabled], .md-button.md-THEME_NAME-theme.md-accent[disabled], .md-button.md-THEME_NAME-theme.md-warn[disabled] {    color: '{{foreground-3}}';    cursor: not-allowed; }    a.md-button.md-THEME_NAME-theme[disabled] md-icon, a.md-button.md-THEME_NAME-theme.md-raised[disabled] md-icon, a.md-button.md-THEME_NAME-theme.md-fab[disabled] md-icon, a.md-button.md-THEME_NAME-theme.md-accent[disabled] md-icon, a.md-button.md-THEME_NAME-theme.md-warn[disabled] md-icon, .md-button.md-THEME_NAME-theme[disabled] md-icon, .md-button.md-THEME_NAME-theme.md-raised[disabled] md-icon, .md-button.md-THEME_NAME-theme.md-fab[disabled] md-icon, .md-button.md-THEME_NAME-theme.md-accent[disabled] md-icon, .md-button.md-THEME_NAME-theme.md-warn[disabled] md-icon {      color: '{{foreground-3}}'; }  a.md-button.md-THEME_NAME-theme.md-raised[disabled], a.md-button.md-THEME_NAME-theme.md-fab[disabled], .md-button.md-THEME_NAME-theme.md-raised[disabled], .md-button.md-THEME_NAME-theme.md-fab[disabled] {    background-color: '{{foreground-4}}'; }  a.md-button.md-THEME_NAME-theme[disabled], .md-button.md-THEME_NAME-theme[disabled] {    background-color: transparent; }md-card.md-THEME_NAME-theme {  background-color: '{{background-color}}';  border-radius: 2px; }  md-card.md-THEME_NAME-theme .md-card-image {    border-radius: 2px 2px 0 0; }md-checkbox.md-THEME_NAME-theme .md-ripple {  color: '{{accent-600}}'; }md-checkbox.md-THEME_NAME-theme.md-checked .md-ripple {  color: '{{background-600}}'; }md-checkbox.md-THEME_NAME-theme.md-checked.md-focused .md-container:before {  background-color: '{{accent-color-0.26}}'; }md-checkbox.md-THEME_NAME-theme .md-icon {  border-color: '{{foreground-2}}'; }md-checkbox.md-THEME_NAME-theme.md-checked .md-icon {  background-color: '{{accent-color-0.87}}'; }md-checkbox.md-THEME_NAME-theme.md-checked .md-icon:after {  border-color: '{{background-200}}'; }md-checkbox.md-THEME_NAME-theme:not([disabled]).md-primary .md-ripple {  color: '{{primary-600}}'; }md-checkbox.md-THEME_NAME-theme:not([disabled]).md-primary.md-checked .md-ripple {  color: '{{background-600}}'; }md-checkbox.md-THEME_NAME-theme:not([disabled]).md-primary .md-icon {  border-color: '{{foreground-2}}'; }md-checkbox.md-THEME_NAME-theme:not([disabled]).md-primary.md-checked .md-icon {  background-color: '{{primary-color-0.87}}'; }md-checkbox.md-THEME_NAME-theme:not([disabled]).md-primary.md-checked.md-focused .md-container:before {  background-color: '{{primary-color-0.26}}'; }md-checkbox.md-THEME_NAME-theme:not([disabled]).md-primary.md-checked .md-icon:after {  border-color: '{{background-200}}'; }md-checkbox.md-THEME_NAME-theme:not([disabled]).md-warn .md-ripple {  color: '{{warn-600}}'; }md-checkbox.md-THEME_NAME-theme:not([disabled]).md-warn .md-icon {  border-color: '{{foreground-2}}'; }md-checkbox.md-THEME_NAME-theme:not([disabled]).md-warn.md-checked .md-icon {  background-color: '{{warn-color-0.87}}'; }md-checkbox.md-THEME_NAME-theme:not([disabled]).md-warn.md-checked.md-focused:not([disabled]) .md-container:before {  background-color: '{{warn-color-0.26}}'; }md-checkbox.md-THEME_NAME-theme:not([disabled]).md-warn.md-checked .md-icon:after {  border-color: '{{background-200}}'; }md-checkbox.md-THEME_NAME-theme[disabled] .md-icon {  border-color: '{{foreground-3}}'; }md-checkbox.md-THEME_NAME-theme[disabled].md-checked .md-icon {  background-color: '{{foreground-3}}'; }md-checkbox.md-THEME_NAME-theme[disabled] .md-label {  color: '{{foreground-3}}'; }md-chips.md-THEME_NAME-theme .md-chips {  box-shadow: 0 1px '{{background-300}}'; }  md-chips.md-THEME_NAME-theme .md-chips.md-focused {    box-shadow: 0 2px '{{primary-color}}'; }md-chips.md-THEME_NAME-theme .md-chip {  background: '{{background-300}}';  color: '{{background-800}}'; }  md-chips.md-THEME_NAME-theme .md-chip.md-focused {    background: '{{primary-color}}';    color: '{{primary-contrast}}'; }    md-chips.md-THEME_NAME-theme .md-chip.md-focused md-icon {      color: '{{primary-contrast}}'; }md-chips.md-THEME_NAME-theme md-chip-remove .md-button md-icon path {  fill: '{{background-500}}'; }.md-contact-suggestion span.md-contact-email {  color: '{{background-400}}'; }md-content.md-THEME_NAME-theme {  background-color: '{{background-color}}'; }md-dialog.md-THEME_NAME-theme {  border-radius: 4px;  background-color: '{{background-color}}'; }  md-dialog.md-THEME_NAME-theme.md-content-overflow .md-actions {    border-top-color: '{{foreground-4}}'; }md-divider.md-THEME_NAME-theme {  border-top-color: '{{foreground-4}}'; }md-icon.md-THEME_NAME-theme {  color: '{{foreground-2}}'; }  md-icon.md-THEME_NAME-theme.md-primary {    color: '{{primary-color}}'; }  md-icon.md-THEME_NAME-theme.md-accent {    color: '{{accent-color}}'; }  md-icon.md-THEME_NAME-theme.md-warn {    color: '{{warn-color}}'; }md-input-container.md-THEME_NAME-theme .md-input {  color: '{{foreground-1}}';  border-color: '{{foreground-4}}';  text-shadow: '{{foreground-shadow}}'; }  md-input-container.md-THEME_NAME-theme .md-input::-webkit-input-placeholder, md-input-container.md-THEME_NAME-theme .md-input::-moz-placeholder, md-input-container.md-THEME_NAME-theme .md-input:-moz-placeholder, md-input-container.md-THEME_NAME-theme .md-input:-ms-input-placeholder {    color: '{{foreground-3}}'; }md-input-container.md-THEME_NAME-theme > md-icon {  color: '{{foreground-1}}'; }md-input-container.md-THEME_NAME-theme label, md-input-container.md-THEME_NAME-theme .md-placeholder {  text-shadow: '{{foreground-shadow}}';  color: '{{foreground-3}}'; }md-input-container.md-THEME_NAME-theme ng-messages, md-input-container.md-THEME_NAME-theme [ng-message], md-input-container.md-THEME_NAME-theme [data-ng-message], md-input-container.md-THEME_NAME-theme [x-ng-message] {  color: '{{warn-500}}'; }md-input-container.md-THEME_NAME-theme:not(.md-input-invalid).md-input-has-value label {  color: '{{foreground-2}}'; }md-input-container.md-THEME_NAME-theme:not(.md-input-invalid).md-input-focused .md-input {  border-color: '{{primary-500}}'; }md-input-container.md-THEME_NAME-theme:not(.md-input-invalid).md-input-focused label {  color: '{{primary-500}}'; }md-input-container.md-THEME_NAME-theme:not(.md-input-invalid).md-input-focused md-icon {  color: '{{primary-500}}'; }md-input-container.md-THEME_NAME-theme:not(.md-input-invalid).md-input-focused.md-accent .md-input {  border-color: '{{accent-500}}'; }md-input-container.md-THEME_NAME-theme:not(.md-input-invalid).md-input-focused.md-accent label {  color: '{{accent-500}}'; }md-input-container.md-THEME_NAME-theme:not(.md-input-invalid).md-input-focused.md-warn .md-input {  border-color: '{{warn-500}}'; }md-input-container.md-THEME_NAME-theme:not(.md-input-invalid).md-input-focused.md-warn label {  color: '{{warn-500}}'; }md-input-container.md-THEME_NAME-theme.md-input-invalid .md-input {  border-color: '{{warn-500}}'; }md-input-container.md-THEME_NAME-theme.md-input-invalid.md-input-focused label {  color: '{{warn-500}}'; }md-input-container.md-THEME_NAME-theme.md-input-invalid ng-message, md-input-container.md-THEME_NAME-theme.md-input-invalid data-ng-message, md-input-container.md-THEME_NAME-theme.md-input-invalid x-ng-message, md-input-container.md-THEME_NAME-theme.md-input-invalid [ng-message], md-input-container.md-THEME_NAME-theme.md-input-invalid [data-ng-message], md-input-container.md-THEME_NAME-theme.md-input-invalid [x-ng-message], md-input-container.md-THEME_NAME-theme.md-input-invalid .md-char-counter {  color: '{{warn-500}}'; }md-input-container.md-THEME_NAME-theme .md-input[disabled], [disabled] md-input-container.md-THEME_NAME-theme .md-input {  border-bottom-color: transparent;  color: '{{foreground-3}}';  background-image: linear-gradient(to right, '{{foreground-3}}' 0%, '{{foreground-3}}' 33%, transparent 0%);  background-image: -ms-linear-gradient(left, transparent 0%, '{{foreground-3}}' 100%); }md-list.md-THEME_NAME-theme md-list-item.md-2-line .md-list-item-text h3, md-list.md-THEME_NAME-theme md-list-item.md-2-line .md-list-item-text h4, md-list.md-THEME_NAME-theme md-list-item.md-3-line .md-list-item-text h3, md-list.md-THEME_NAME-theme md-list-item.md-3-line .md-list-item-text h4 {  color: '{{foreground-1}}'; }md-list.md-THEME_NAME-theme md-list-item.md-2-line .md-list-item-text p, md-list.md-THEME_NAME-theme md-list-item.md-3-line .md-list-item-text p {  color: '{{foreground-2}}'; }md-list.md-THEME_NAME-theme .md-proxy-focus.md-focused div.md-no-style {  background-color: '{{background-100}}'; }md-list.md-THEME_NAME-theme md-list-item > md-icon {  color: '{{foreground-2}}'; }  md-list.md-THEME_NAME-theme md-list-item > md-icon.md-highlight {    color: '{{primary-color}}'; }    md-list.md-THEME_NAME-theme md-list-item > md-icon.md-highlight.md-accent {      color: '{{accent-color}}'; }md-list.md-THEME_NAME-theme md-list-item button {  background-color: '{{background-color}}'; }  md-list.md-THEME_NAME-theme md-list-item button.md-button:not([disabled]):hover {    background-color: '{{background-color}}'; }md-progress-circular.md-THEME_NAME-theme {  background-color: transparent; }  md-progress-circular.md-THEME_NAME-theme .md-inner .md-gap {    border-top-color: '{{primary-color}}';    border-bottom-color: '{{primary-color}}'; }  md-progress-circular.md-THEME_NAME-theme .md-inner .md-left .md-half-circle, md-progress-circular.md-THEME_NAME-theme .md-inner .md-right .md-half-circle {    border-top-color: '{{primary-color}}'; }  md-progress-circular.md-THEME_NAME-theme .md-inner .md-right .md-half-circle {    border-right-color: '{{primary-color}}'; }  md-progress-circular.md-THEME_NAME-theme .md-inner .md-left .md-half-circle {    border-left-color: '{{primary-color}}'; }  md-progress-circular.md-THEME_NAME-theme.md-warn .md-inner .md-gap {    border-top-color: '{{warn-color}}';    border-bottom-color: '{{warn-color}}'; }  md-progress-circular.md-THEME_NAME-theme.md-warn .md-inner .md-left .md-half-circle, md-progress-circular.md-THEME_NAME-theme.md-warn .md-inner .md-right .md-half-circle {    border-top-color: '{{warn-color}}'; }  md-progress-circular.md-THEME_NAME-theme.md-warn .md-inner .md-right .md-half-circle {    border-right-color: '{{warn-color}}'; }  md-progress-circular.md-THEME_NAME-theme.md-warn .md-inner .md-left .md-half-circle {    border-left-color: '{{warn-color}}'; }  md-progress-circular.md-THEME_NAME-theme.md-accent .md-inner .md-gap {    border-top-color: '{{accent-color}}';    border-bottom-color: '{{accent-color}}'; }  md-progress-circular.md-THEME_NAME-theme.md-accent .md-inner .md-left .md-half-circle, md-progress-circular.md-THEME_NAME-theme.md-accent .md-inner .md-right .md-half-circle {    border-top-color: '{{accent-color}}'; }  md-progress-circular.md-THEME_NAME-theme.md-accent .md-inner .md-right .md-half-circle {    border-right-color: '{{accent-color}}'; }  md-progress-circular.md-THEME_NAME-theme.md-accent .md-inner .md-left .md-half-circle {    border-left-color: '{{accent-color}}'; }md-progress-linear.md-THEME_NAME-theme .md-container {  background-color: '{{primary-100}}'; }md-progress-linear.md-THEME_NAME-theme .md-bar {  background-color: '{{primary-color}}'; }md-progress-linear.md-THEME_NAME-theme.md-warn .md-container {  background-color: '{{warn-100}}'; }md-progress-linear.md-THEME_NAME-theme.md-warn .md-bar {  background-color: '{{warn-color}}'; }md-progress-linear.md-THEME_NAME-theme.md-accent .md-container {  background-color: '{{accent-100}}'; }md-progress-linear.md-THEME_NAME-theme.md-accent .md-bar {  background-color: '{{accent-color}}'; }md-progress-linear.md-THEME_NAME-theme[md-mode=buffer].md-warn .md-bar1 {  background-color: '{{warn-100}}'; }md-progress-linear.md-THEME_NAME-theme[md-mode=buffer].md-warn .md-dashed:before {  background: radial-gradient('{{warn-100}}' 0%, '{{warn-100}}' 16%, transparent 42%); }md-progress-linear.md-THEME_NAME-theme[md-mode=buffer].md-accent .md-bar1 {  background-color: '{{accent-100}}'; }md-progress-linear.md-THEME_NAME-theme[md-mode=buffer].md-accent .md-dashed:before {  background: radial-gradient('{{accent-100}}' 0%, '{{accent-100}}' 16%, transparent 42%); }md-radio-button.md-THEME_NAME-theme .md-off {  border-color: '{{foreground-2}}'; }md-radio-button.md-THEME_NAME-theme .md-on {  background-color: '{{accent-color-0.87}}'; }md-radio-button.md-THEME_NAME-theme.md-checked .md-off {  border-color: '{{accent-color-0.87}}'; }md-radio-button.md-THEME_NAME-theme.md-checked .md-ink-ripple {  color: '{{accent-color-0.87}}'; }md-radio-button.md-THEME_NAME-theme .md-container .md-ripple {  color: '{{accent-600}}'; }md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-primary .md-on, md-radio-group.md-THEME_NAME-theme:not([disabled]).md-primary .md-on, md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-primary .md-on, md-radio-button.md-THEME_NAME-theme:not([disabled]).md-primary .md-on {  background-color: '{{primary-color-0.87}}'; }md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-primary .md-checked .md-off, md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-primary.md-checked .md-off, md-radio-group.md-THEME_NAME-theme:not([disabled]).md-primary .md-checked .md-off, md-radio-group.md-THEME_NAME-theme:not([disabled]).md-primary.md-checked .md-off, md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-primary .md-checked .md-off, md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-primary.md-checked .md-off, md-radio-button.md-THEME_NAME-theme:not([disabled]).md-primary .md-checked .md-off, md-radio-button.md-THEME_NAME-theme:not([disabled]).md-primary.md-checked .md-off {  border-color: '{{primary-color-0.87}}'; }md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-primary .md-checked .md-ink-ripple, md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-primary.md-checked .md-ink-ripple, md-radio-group.md-THEME_NAME-theme:not([disabled]).md-primary .md-checked .md-ink-ripple, md-radio-group.md-THEME_NAME-theme:not([disabled]).md-primary.md-checked .md-ink-ripple, md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-primary .md-checked .md-ink-ripple, md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-primary.md-checked .md-ink-ripple, md-radio-button.md-THEME_NAME-theme:not([disabled]).md-primary .md-checked .md-ink-ripple, md-radio-button.md-THEME_NAME-theme:not([disabled]).md-primary.md-checked .md-ink-ripple {  color: '{{primary-color-0.87}}'; }md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-primary .md-container .md-ripple, md-radio-group.md-THEME_NAME-theme:not([disabled]).md-primary .md-container .md-ripple, md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-primary .md-container .md-ripple, md-radio-button.md-THEME_NAME-theme:not([disabled]).md-primary .md-container .md-ripple {  color: '{{primary-600}}'; }md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-warn .md-on, md-radio-group.md-THEME_NAME-theme:not([disabled]).md-warn .md-on, md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-warn .md-on, md-radio-button.md-THEME_NAME-theme:not([disabled]).md-warn .md-on {  background-color: '{{warn-color-0.87}}'; }md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-warn .md-checked .md-off, md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-warn.md-checked .md-off, md-radio-group.md-THEME_NAME-theme:not([disabled]).md-warn .md-checked .md-off, md-radio-group.md-THEME_NAME-theme:not([disabled]).md-warn.md-checked .md-off, md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-warn .md-checked .md-off, md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-warn.md-checked .md-off, md-radio-button.md-THEME_NAME-theme:not([disabled]).md-warn .md-checked .md-off, md-radio-button.md-THEME_NAME-theme:not([disabled]).md-warn.md-checked .md-off {  border-color: '{{warn-color-0.87}}'; }md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-warn .md-checked .md-ink-ripple, md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-warn.md-checked .md-ink-ripple, md-radio-group.md-THEME_NAME-theme:not([disabled]).md-warn .md-checked .md-ink-ripple, md-radio-group.md-THEME_NAME-theme:not([disabled]).md-warn.md-checked .md-ink-ripple, md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-warn .md-checked .md-ink-ripple, md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-warn.md-checked .md-ink-ripple, md-radio-button.md-THEME_NAME-theme:not([disabled]).md-warn .md-checked .md-ink-ripple, md-radio-button.md-THEME_NAME-theme:not([disabled]).md-warn.md-checked .md-ink-ripple {  color: '{{warn-color-0.87}}'; }md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-warn .md-container .md-ripple, md-radio-group.md-THEME_NAME-theme:not([disabled]).md-warn .md-container .md-ripple, md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-warn .md-container .md-ripple, md-radio-button.md-THEME_NAME-theme:not([disabled]).md-warn .md-container .md-ripple {  color: '{{warn-600}}'; }md-radio-group.md-THEME_NAME-theme[disabled], md-radio-button.md-THEME_NAME-theme[disabled] {  color: '{{foreground-3}}'; }  md-radio-group.md-THEME_NAME-theme[disabled] .md-container .md-off, md-radio-button.md-THEME_NAME-theme[disabled] .md-container .md-off {    border-color: '{{foreground-3}}'; }  md-radio-group.md-THEME_NAME-theme[disabled] .md-container .md-on, md-radio-button.md-THEME_NAME-theme[disabled] .md-container .md-on {    border-color: '{{foreground-3}}'; }md-radio-group.md-THEME_NAME-theme.md-focused:not(:empty) .md-checked .md-container:before {  background-color: '{{accent-color-0.26}}'; }md-radio-group.md-THEME_NAME-theme.md-focused:not(:empty) .md-checked:not([disabled]).md-primary .md-container:before {  background-color: '{{primary-color-0.26}}'; }md-radio-group.md-THEME_NAME-theme.md-focused:not(:empty) .md-checked.md-primary .md-container:before {  background-color: '{{warn-color-0.26}}'; }md-select.md-THEME_NAME-theme.ng-invalid.ng-dirty .md-select-label {  color: '{{warn-500}}' !important;  border-bottom-color: '{{warn-500}}' !important; }md-select.md-THEME_NAME-theme:not([disabled]):focus .md-select-label {  border-bottom-color: '{{primary-color}}';  color: '{{ foreground-1 }}'; }  md-select.md-THEME_NAME-theme:not([disabled]):focus .md-select-label.md-placeholder {    color: '{{ foreground-1 }}'; }md-select.md-THEME_NAME-theme:not([disabled]):focus.md-accent .md-select-label {  border-bottom-color: '{{accent-color}}'; }md-select.md-THEME_NAME-theme:not([disabled]):focus.md-warn .md-select-label {  border-bottom-color: '{{warn-color}}'; }md-select.md-THEME_NAME-theme[disabled] .md-select-label {  color: '{{foreground-3}}'; }  md-select.md-THEME_NAME-theme[disabled] .md-select-label.md-placeholder {    color: '{{foreground-3}}'; }md-select.md-THEME_NAME-theme .md-select-label {  border-bottom-color: '{{foreground-4}}'; }  md-select.md-THEME_NAME-theme .md-select-label.md-placeholder {    color: '{{foreground-2}}'; }md-select-menu.md-THEME_NAME-theme md-optgroup {  color: '{{foreground-2}}'; }  md-select-menu.md-THEME_NAME-theme md-optgroup md-option {    color: '{{foreground-1}}'; }md-select-menu.md-THEME_NAME-theme md-option[selected] {  color: '{{primary-500}}'; }  md-select-menu.md-THEME_NAME-theme md-option[selected]:focus {    color: '{{primary-600}}'; }  md-select-menu.md-THEME_NAME-theme md-option[selected].md-accent {    color: '{{accent-500}}'; }    md-select-menu.md-THEME_NAME-theme md-option[selected].md-accent:focus {      color: '{{accent-600}}'; }md-select-menu.md-THEME_NAME-theme md-option:focus:not([selected]) {  background: '{{background-200}}'; }md-sidenav.md-THEME_NAME-theme {  background-color: '{{background-color}}'; }md-slider.md-THEME_NAME-theme .md-track {  background-color: '{{foreground-3}}'; }md-slider.md-THEME_NAME-theme .md-track-ticks {  background-color: '{{foreground-4}}'; }md-slider.md-THEME_NAME-theme .md-focus-thumb {  background-color: '{{foreground-2}}'; }md-slider.md-THEME_NAME-theme .md-focus-ring {  border-color: '{{foreground-4}}'; }md-slider.md-THEME_NAME-theme .md-disabled-thumb {  border-color: '{{background-color}}'; }md-slider.md-THEME_NAME-theme.md-min .md-thumb:after {  background-color: '{{background-color}}'; }md-slider.md-THEME_NAME-theme .md-track.md-track-fill {  background-color: '{{accent-color}}'; }md-slider.md-THEME_NAME-theme .md-thumb:after {  border-color: '{{accent-color}}';  background-color: '{{accent-color}}'; }md-slider.md-THEME_NAME-theme .md-sign {  background-color: '{{accent-color}}'; }  md-slider.md-THEME_NAME-theme .md-sign:after {    border-top-color: '{{accent-color}}'; }md-slider.md-THEME_NAME-theme .md-thumb-text {  color: '{{accent-contrast}}'; }md-slider.md-THEME_NAME-theme.md-warn .md-track.md-track-fill {  background-color: '{{warn-color}}'; }md-slider.md-THEME_NAME-theme.md-warn .md-thumb:after {  border-color: '{{warn-color}}';  background-color: '{{warn-color}}'; }md-slider.md-THEME_NAME-theme.md-warn .md-sign {  background-color: '{{warn-color}}'; }  md-slider.md-THEME_NAME-theme.md-warn .md-sign:after {    border-top-color: '{{warn-color}}'; }md-slider.md-THEME_NAME-theme.md-warn .md-thumb-text {  color: '{{warn-contrast}}'; }md-slider.md-THEME_NAME-theme.md-primary .md-track.md-track-fill {  background-color: '{{primary-color}}'; }md-slider.md-THEME_NAME-theme.md-primary .md-thumb:after {  border-color: '{{primary-color}}';  background-color: '{{primary-color}}'; }md-slider.md-THEME_NAME-theme.md-primary .md-sign {  background-color: '{{primary-color}}'; }  md-slider.md-THEME_NAME-theme.md-primary .md-sign:after {    border-top-color: '{{primary-color}}'; }md-slider.md-THEME_NAME-theme.md-primary .md-thumb-text {  color: '{{primary-contrast}}'; }md-slider.md-THEME_NAME-theme[disabled] .md-thumb:after {  border-color: '{{foreground-3}}'; }md-slider.md-THEME_NAME-theme[disabled]:not(.md-min) .md-thumb:after {  background-color: '{{foreground-3}}'; }.md-subheader.md-THEME_NAME-theme {  color: '{{ foreground-2-0.23 }}';  background-color: '{{background-color}}'; }  .md-subheader.md-THEME_NAME-theme.md-primary {    color: '{{primary-color}}'; }  .md-subheader.md-THEME_NAME-theme.md-accent {    color: '{{accent-color}}'; }  .md-subheader.md-THEME_NAME-theme.md-warn {    color: '{{warn-color}}'; }md-switch.md-THEME_NAME-theme .md-thumb {  background-color: '{{background-50}}'; }md-switch.md-THEME_NAME-theme .md-bar {  background-color: '{{background-500}}'; }md-switch.md-THEME_NAME-theme.md-checked .md-thumb {  background-color: '{{accent-color}}'; }md-switch.md-THEME_NAME-theme.md-checked .md-bar {  background-color: '{{accent-color-0.5}}'; }md-switch.md-THEME_NAME-theme.md-checked.md-focused .md-thumb:before {  background-color: '{{accent-color-0.26}}'; }md-switch.md-THEME_NAME-theme.md-checked.md-primary .md-thumb {  background-color: '{{primary-color}}'; }md-switch.md-THEME_NAME-theme.md-checked.md-primary .md-bar {  background-color: '{{primary-color-0.5}}'; }md-switch.md-THEME_NAME-theme.md-checked.md-primary.md-focused .md-thumb:before {  background-color: '{{primary-color-0.26}}'; }md-switch.md-THEME_NAME-theme.md-checked.md-warn .md-thumb {  background-color: '{{warn-color}}'; }md-switch.md-THEME_NAME-theme.md-checked.md-warn .md-bar {  background-color: '{{warn-color-0.5}}'; }md-switch.md-THEME_NAME-theme.md-checked.md-warn.md-focused .md-thumb:before {  background-color: '{{warn-color-0.26}}'; }md-switch.md-THEME_NAME-theme[disabled] .md-thumb {  background-color: '{{background-400}}'; }md-switch.md-THEME_NAME-theme[disabled] .md-bar {  background-color: '{{foreground-4}}'; }md-toast.md-THEME_NAME-theme {  background-color: #323232;  color: '{{background-50}}'; }  md-toast.md-THEME_NAME-theme .md-button {    color: '{{background-50}}'; }    md-toast.md-THEME_NAME-theme .md-button.md-highlight {      color: '{{primary-A200}}'; }      md-toast.md-THEME_NAME-theme .md-button.md-highlight.md-accent {        color: '{{accent-A200}}'; }      md-toast.md-THEME_NAME-theme .md-button.md-highlight.md-warn {        color: '{{warn-A200}}'; }md-tabs.md-THEME_NAME-theme md-tabs-wrapper {  background-color: transparent;  border-color: '{{foreground-4}}'; }md-tabs.md-THEME_NAME-theme .md-paginator md-icon {  color: '{{primary-color}}'; }md-tabs.md-THEME_NAME-theme md-ink-bar {  color: '{{accent-color}}';  background: '{{accent-color}}'; }md-tabs.md-THEME_NAME-theme .md-tab {  color: '{{foreground-2}}'; }  md-tabs.md-THEME_NAME-theme .md-tab[disabled] {    color: '{{foreground-3}}'; }  md-tabs.md-THEME_NAME-theme .md-tab.md-active, md-tabs.md-THEME_NAME-theme .md-tab.md-focused {    color: '{{primary-color}}'; }  md-tabs.md-THEME_NAME-theme .md-tab.md-focused {    background: '{{primary-color-0.1}}'; }  md-tabs.md-THEME_NAME-theme .md-tab .md-ripple-container {    color: '{{accent-100}}'; }md-tabs.md-THEME_NAME-theme.md-accent md-tabs-wrapper {  background-color: '{{accent-color}}'; }md-tabs.md-THEME_NAME-theme.md-accent md-tab-item:not([disabled]) {  color: '{{accent-100}}'; }  md-tabs.md-THEME_NAME-theme.md-accent md-tab-item:not([disabled]).md-active, md-tabs.md-THEME_NAME-theme.md-accent md-tab-item:not([disabled]).md-focused {    color: '{{accent-contrast}}'; }  md-tabs.md-THEME_NAME-theme.md-accent md-tab-item:not([disabled]).md-focused {    background: '{{accent-contrast-0.1}}'; }md-tabs.md-THEME_NAME-theme.md-accent md-ink-bar {  color: '{{primary-600-1}}';  background: '{{primary-600-1}}'; }md-tabs.md-THEME_NAME-theme.md-primary md-tabs-wrapper {  background-color: '{{primary-color}}'; }md-tabs.md-THEME_NAME-theme.md-primary md-tab-item:not([disabled]) {  color: '{{primary-100}}'; }  md-tabs.md-THEME_NAME-theme.md-primary md-tab-item:not([disabled]).md-active, md-tabs.md-THEME_NAME-theme.md-primary md-tab-item:not([disabled]).md-focused {    color: '{{primary-contrast}}'; }  md-tabs.md-THEME_NAME-theme.md-primary md-tab-item:not([disabled]).md-focused {    background: '{{primary-contrast-0.1}}'; }md-tabs.md-THEME_NAME-theme.md-warn md-tabs-wrapper {  background-color: '{{warn-color}}'; }md-tabs.md-THEME_NAME-theme.md-warn md-tab-item:not([disabled]) {  color: '{{warn-100}}'; }  md-tabs.md-THEME_NAME-theme.md-warn md-tab-item:not([disabled]).md-active, md-tabs.md-THEME_NAME-theme.md-warn md-tab-item:not([disabled]).md-focused {    color: '{{warn-contrast}}'; }  md-tabs.md-THEME_NAME-theme.md-warn md-tab-item:not([disabled]).md-focused {    background: '{{warn-contrast-0.1}}'; }md-toolbar > md-tabs.md-THEME_NAME-theme md-tabs-wrapper {  background-color: '{{primary-color}}'; }md-toolbar > md-tabs.md-THEME_NAME-theme md-tab-item:not([disabled]) {  color: '{{primary-100}}'; }  md-toolbar > md-tabs.md-THEME_NAME-theme md-tab-item:not([disabled]).md-active, md-toolbar > md-tabs.md-THEME_NAME-theme md-tab-item:not([disabled]).md-focused {    color: '{{primary-contrast}}'; }  md-toolbar > md-tabs.md-THEME_NAME-theme md-tab-item:not([disabled]).md-focused {    background: '{{primary-contrast-0.1}}'; }md-toolbar.md-accent > md-tabs.md-THEME_NAME-theme md-tabs-wrapper {  background-color: '{{accent-color}}'; }md-toolbar.md-accent > md-tabs.md-THEME_NAME-theme md-tab-item:not([disabled]) {  color: '{{accent-100}}'; }  md-toolbar.md-accent > md-tabs.md-THEME_NAME-theme md-tab-item:not([disabled]).md-active, md-toolbar.md-accent > md-tabs.md-THEME_NAME-theme md-tab-item:not([disabled]).md-focused {    color: '{{accent-contrast}}'; }  md-toolbar.md-accent > md-tabs.md-THEME_NAME-theme md-tab-item:not([disabled]).md-focused {    background: '{{accent-contrast-0.1}}'; }md-toolbar.md-accent > md-tabs.md-THEME_NAME-theme md-ink-bar {  color: '{{primary-600-1}}';  background: '{{primary-600-1}}'; }md-toolbar.md-warn > md-tabs.md-THEME_NAME-theme md-tabs-wrapper {  background-color: '{{warn-color}}'; }md-toolbar.md-warn > md-tabs.md-THEME_NAME-theme md-tab-item:not([disabled]) {  color: '{{warn-100}}'; }  md-toolbar.md-warn > md-tabs.md-THEME_NAME-theme md-tab-item:not([disabled]).md-active, md-toolbar.md-warn > md-tabs.md-THEME_NAME-theme md-tab-item:not([disabled]).md-focused {    color: '{{warn-contrast}}'; }  md-toolbar.md-warn > md-tabs.md-THEME_NAME-theme md-tab-item:not([disabled]).md-focused {    background: '{{warn-contrast-0.1}}'; }md-toolbar.md-THEME_NAME-theme {  background-color: '{{primary-color}}';  color: '{{primary-contrast}}'; }  md-toolbar.md-THEME_NAME-theme md-icon {    color: '{{primary-contrast}}'; }  md-toolbar.md-THEME_NAME-theme .md-button {    color: '{{primary-contrast}}'; }  md-toolbar.md-THEME_NAME-theme.md-accent {    background-color: '{{accent-color}}';    color: '{{accent-contrast}}'; }  md-toolbar.md-THEME_NAME-theme.md-warn {    background-color: '{{warn-color}}';    color: '{{warn-contrast}}'; }md-tooltip.md-THEME_NAME-theme {  color: '{{background-A100}}'; }  md-tooltip.md-THEME_NAME-theme .md-background {    background-color: '{{foreground-2}}'; }\"); \n})();\n\n\n})(window, window.angular);"]}